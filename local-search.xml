<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MIT6.824Lab1思路总结</title>
    <link href="/2023/11/07/MIT6-824Lab1%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <url>/2023/11/07/MIT6-824Lab1%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>因为824的老师不希望我们开源代码，所以我就放在gitee上（doge），外国人总不会用gitee吧</p><p>Gitee仓库地址：<a href="https://gitee.com/MadFray/mit6.824">MadFray&#x2F;MIT6.824 (gitee.com)</a></p><p>然后用写篇blog记录一下在做lab1时候的思路和遇到坑点</p><p>在最开始做的时候，因为论文讲述的是在cluster下的情况，现在放到了单机实现，有一定的上手难度，但是最无语的一件事是没有看完hint就去做，导致当时想要通过协程来实现，这不合老师们的想法（hint没有这方面的提示），同时这方面是思路是空白的，也就是说实现起来会相对比较困难（但其实后面单独测试的时候，去改脚本发现其实他的脚本就是挂后台启动了好几个worker，这也就意味着，这个worker应该是既可以做map也可以做reduce的）。</p><p>在后面看了一篇csdn的博客后，自己私下里又把hint完完整整的看完了一遍，才真正算是理清楚了思路，大致知道了老师们希望我们怎么做。理清楚了思路做起来就快了真正开始动手做到完成lab大花了1天半多的时间，加上看论文等资料，实际需要的时间我估计应该在最多3天左右，当然我指的是一天的大部分时间都花在这上面，需要3天</p><p>接下来就来说一下我的思路和一下经验总结</p><p>我是首先实现的worker</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Worker</span><span class="hljs-params">(mapffunc(<span class="hljs-type">string</span>,<span class="hljs-type">string</span>)</span></span> []KeyValue,<br><br>reduceffunc(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)<span class="hljs-type">string</span>) &#123;<br><br><span class="hljs-comment">// Your worker implementation here.</span><br><br><span class="hljs-keyword">for</span> &#123;<br><br>task := GetTask()<br><br><span class="hljs-keyword">switch</span> task.TaskType &#123;<br><br><span class="hljs-keyword">case</span> MapTask:<br><br>&#123;<br><br>DoMap(mapf, task)<br><br>DoneTask(task)<br><br>&#125;<br><br><span class="hljs-keyword">case</span> CompleteTask:<br><br>&#123;<br><br><span class="hljs-comment">//exit</span><br><br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">case</span> ReduceTask:<br><br>&#123;<br><br>DoReduceTask(reducef,task)<br><br>DoneTask(task)<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">// uncomment to send the Example RPC to the coordinator.</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>因为上面提到过，worker要map和reduce都能处理，所以我们要根据穿过来的task参数中的tasktype来进行判断应该做什么处理</p><p>这边提一下我并没有去维护worker的状态，而只使用了task的状态，只维护task的状态相对来讲会更加简单</p><p>然后在实现DoMap的时候，这里一开始实现的时候没有注意到并发问题（当然，在并发问题之前其实还有一个小问题，我把create文件放到了for循环里，这导致所有的key value都没有追加到对应的tmp文件中，而是后面覆盖前面（create会如果已经存在了同名文件，那么就会进行覆盖），导致到了最后处理完了所有的out都只有一条记录，犯傻了，我好菜&gt;_&lt;🥺）</p><p>如果不使用临时文件的话，可以使用另一种方法：将所有的key value都处理好，然后使用一个二维数组进行存储，最后统一一次性创建文件然后将全部写入文件</p><p>也就是说如果不使用临时文件这一种方法的话，那么就将所有的kv都存在内存中，最后一起写入到文件中来避免并发问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoMap</span><span class="hljs-params">(mapffunc(<span class="hljs-type">string</span>,<span class="hljs-type">string</span>)</span></span> []KeyValue, raw Task) &#123;<span class="hljs-comment">//这里应该有并发问题,已经解决</span><br><br><span class="hljs-comment">//ps： 因为都在GFS里，所以知道了filename就可以直接读(自认为)</span><br><br>file, err := os.Open(raw.Filename)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><br>log.Fatalf(<span class="hljs-string">&quot;cannot open %v&quot;</span>, raw.Filename)<br><br>&#125;<br><br>content, err := io.ReadAll(file)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><br>log.Fatalf(<span class="hljs-string">&quot;cannot read %v&quot;</span>, raw.Filename)<br><br>&#125;<br><br>file.Close()<br><br>kva := mapf(raw.Filename,<span class="hljs-type">string</span>(content))<br><br><span class="hljs-comment">//intermediate = append(intermediate, kva...)</span><br><br><span class="hljs-comment">//create intermediate file  what&#x27;s the mean of k and y</span><br><br><span class="hljs-comment">// use json</span><br><br><span class="hljs-comment">//提前创建好文件</span><br><br>dir, _ := os.Getwd()<br><br>Mapfiles := []*os.File&#123;&#125;<br><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;raw.ReduceSum;i++&#123;<br><br>oname,_:=os.CreateTemp(dir,<span class="hljs-string">&quot;&quot;</span>)<br><br><span class="hljs-comment">//newfile, _ := os.Create(&quot;mr-&quot; + fmt.Sprint(raw.TaskNum)+ &quot;-&quot; + fmt.Sprint(i)) //use ihash to confirm reduceNum</span><br><br>Mapfiles = <span class="hljs-built_in">append</span>(Mapfiles,oname)<br><br>&#125;<br><br><span class="hljs-keyword">for</span> _, v :=<span class="hljs-keyword">range</span> kva &#123;  <span class="hljs-comment">//如果文件存在会将所有文件内容清空，所以不能每次都用create创建一个</span><br><br><span class="hljs-comment">//newfile, _ := os.Create(&quot;mr-&quot; + fmt.Sprint(raw.TaskNum)+ &quot;-&quot; + fmt.Sprint(ihash(v.Key)%raw.ReduceSum)) //use ihash to confirm reduceNum</span><br><br>f := Mapfiles[ihash(v.Key)%raw.ReduceSum]<br><br>enc := json.NewEncoder(f)<br><br>err := enc.Encode(&amp;v)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><br>log.Println(err)<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">for</span> i,v:=<span class="hljs-keyword">range</span> Mapfiles&#123;<br><br>err := os.Rename(v.Name(),fmt.Sprintf(<span class="hljs-string">&quot;mr-%d-%d&quot;</span>, raw.TaskNum, i)) <span class="hljs-comment">//use ihash to confirm reduceNum</span><br><br><span class="hljs-keyword">if</span> err!= <span class="hljs-literal">nil</span> &#123;<br><br>log.Println(err)<br><br>&#125;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>worker相对来说比较简单，这边就先简单的把我踩到的坑写出来给大家吸取教训，Doreduce等比较简单，这边就不再多提</p><p>接下来讲一下coodinator，我个人觉得这一块相较worker来说还是有点难度的，但也还好，100多行代码就能完成，因为我们只维护worker的状态</p><p>然后coodinator关键点在于task的分配，这里hint有提示，我们需要在确保map全部都完成后在分配reduce任务</p><p>这边提一下我在第三次测试是时候有一个job count 测试点过不去，他通过要求的map次数是8次，但是不知道为什么我的会执行出9次来</p><p>后面调了一节课，分析了一波问题有关的上下游，最后发现FinishedTask加的锁给他去掉就能够通过了</p><p>我在一开始写的时候也觉得并不是很有必要加锁，他都是改成true，就算有可能同时修改一个，那他们的结果也是相同的，都是修改成true，实际影响不大</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> FinishedTask(args *FinishArgs, reply *Task) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">//标记任务是否完成</span><br><span class="hljs-comment">//todo 有必要加锁吗， 确实是共享的变量</span><br><span class="hljs-comment">//事实证明是不需要加锁的</span><br><span class="hljs-keyword">switch</span> args.Ts.TaskType &#123;<br><span class="hljs-keyword">case</span> MapTask:<br>c.finishedMapfiles[args.Ts.TaskNum] = <span class="hljs-literal">true</span><br>fmt.Println(args.Ts.TaskNum)<br><br><span class="hljs-keyword">case</span> ReduceTask:<br>c.finishedReducefiles[args.Ts.TaskNum] = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是为什么这里加锁会导致出问题呢？</p><p>我个人分析，可能有不正确的地方，欢迎到gitee上指出</p><p>他的shell脚本会启动3个worker，进行并发，当其中6个都完成了只剩下最后一个没完成是，其中两个worker会在gettask中不断循环，循环会有checkfinish，checkfinish也会对isfinish数组进行访问，此时rpc调用完成借口并且加锁，可能是导致不能及时讲任务的isfinish数组设置true的原因</p><p>最后附上我的结构体定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Coordinator <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Your definitions here.</span><br>mu sync.Mutex<br>nReduce <span class="hljs-type">int</span> <span class="hljs-comment">//how much tasks need to done </span><br>files    []<span class="hljs-type">string</span><br>finishedMapfiles []<span class="hljs-type">bool</span><br>TimesfinishedMapfiles []time.Time<br>finishedReducefiles []<span class="hljs-type">bool</span><br>TimesfinishedReducefiles []time.Time<br>Isdone <span class="hljs-type">bool</span> <span class="hljs-comment">//是否全部完成</span><br><br>&#125;<br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>TaskType   TaskType   <br>TaskNum <span class="hljs-type">int</span>     <span class="hljs-comment">//任务的序号</span><br>ReduceSum <span class="hljs-type">int</span> <span class="hljs-comment">//the sum of tasks needed to reduce</span><br>MapSum <span class="hljs-type">int</span> <span class="hljs-comment">// the sum of tasks needed to map</span><br>Filename   <span class="hljs-type">string</span>   <br>&#125;<br><br><span class="hljs-keyword">type</span> TaskArgs <span class="hljs-keyword">struct</span>&#123;<br>TaskType   TaskType   <br>TaskNum <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> FinishArgs <span class="hljs-keyword">struct</span>&#123;<br>Ts Task<br>&#125;<br><br><span class="hljs-keyword">type</span> TaskType <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>MapTask TaskType = <span class="hljs-literal">iota</span><br>ReduceTask<br>CompleteTask    <br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Distributed system</category>
      
      <category>lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法题型思路总结</title>
    <link href="/2023/09/19/%E7%AE%97%E6%B3%95%E9%A2%98%E5%9E%8B%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/19/%E7%AE%97%E6%B3%95%E9%A2%98%E5%9E%8B%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>用于记录个人刷到用时较长或者没有思路的题目记录一下解题思路</p><p>前期用c++刷了一部分剑指offer的题目，后期看要不全转go吧</p><p>记录 9.25 开始刷leetcode热题100 ， 剑指offer差模拟，位运算和其他算法  现已切换到go</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>题目索引 : <a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=23291&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13"><strong>字符串的排列</strong></a></p><p>只能说回溯忘的差不多了，通过这题来回顾一下</p><p>这边主要是用到了一个set，通过set集合来去除重复的部分，让题目变的更加简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param str string字符串</span><br><span class="hljs-comment">     * @return string字符串vector</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-type">int</span> book[<span class="hljs-number">10</span>];<br>    set&lt;string&gt; v;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string tmp, string str, vector&lt;<span class="hljs-type">int</span>&gt; vis)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tmp.<span class="hljs-built_in">size</span>() == str.<span class="hljs-built_in">size</span>()) &#123;<br>            v.<span class="hljs-built_in">insert</span>(tmp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (vis[i])<br>                <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">//标记为使用过</span><br>            vis[i] = <span class="hljs-number">1</span>;  <br>            <span class="hljs-comment">//加入临时字符串</span><br>            tmp.<span class="hljs-built_in">push_back</span>(str[i]);<br>            <span class="hljs-built_in">dfs</span>( tmp, str, vis);<br>            <span class="hljs-comment">//回溯</span><br>            vis[i] = <span class="hljs-number">0</span>;<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br><br>    &#125;<br><br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>    <br>        <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">empty</span>()) &#123;<br>           <span class="hljs-keyword">return</span>  vector&lt;string&gt;&#123;&#125;;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(str.size(), <span class="hljs-number">0</span>)</span></span>;<br>        string tmp;<br>    <br>        <span class="hljs-built_in">dfs</span>(tmp, str, vis);<br><br>        <span class="hljs-keyword">return</span> vector&lt;string&gt;&#123;v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>()&#125;;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h3><p>题目链接： <a href="https://www.nowcoder.com/practice/48d2ff79b8564c40a50fa79f9d5fa9c7?tpId=13&tqId=2276769&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">最长不含重复字符的子字符串</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param s string字符串 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span> &gt;m;<br>        <span class="hljs-type">int</span> length = <span class="hljs-number">0</span> ;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            m[s[i]]++;<br>            right = i;<br>            <span class="hljs-keyword">while</span> (m[s[i]]&gt;<span class="hljs-number">1</span>) &#123;<br>                m[s[left++]]--;<br><br>            &#125;<br>             <span class="hljs-type">int</span> m_size = m.<span class="hljs-built_in">size</span>();<br>            length = <span class="hljs-built_in">max</span>(length,right - left +<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h3><p>题目连接 ：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></p><p>自己的只通过了62&#x2F;65个测试用例 ，后面节省时间直接看答案了，发现答案写的比我写的简洁多了 QAQ</p><p>大体思路是差不多的，可能我有些详解没处理好吧，插个眼后面再来一遍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findAnagrams</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p <span class="hljs-type">string</span>)</span></span>(ans []<span class="hljs-type">int</span>) &#123;<br> sLen, pLen := <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(p)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &lt; <span class="hljs-built_in">len</span>(p) &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> sCount, pCount [<span class="hljs-number">26</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> p &#123;<br>        sCount[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>        pCount[ch-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>    &#125;<br><span class="hljs-keyword">if</span> sCount == pCount &#123;<br>        ans = <span class="hljs-built_in">append</span>(ans, <span class="hljs-number">0</span>)<br>    &#125;<br><br> <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> s[:sLen-pLen] &#123;<br>        sCount[ch-<span class="hljs-string">&#x27;a&#x27;</span>]--<br>        sCount[s[i+pLen]-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>        <span class="hljs-keyword">if</span> sCount == pCount &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, i+<span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br><br><br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a>和为 K 的子数组</h3><p>题目连接 ： <a href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为 K 的子数组</a></p><p>利用前缀和 与 map 降低复杂度</p><p>pre[i] - pre[j] &#x3D;&#x3D;k</p><p>通过map来记录 m[pre[i]-k]是否存在 ，以及有多少个等于这个值的前缀和</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">var</span> pre <span class="hljs-type">int</span><br>    pre = <span class="hljs-number">0</span><br>    count:= <span class="hljs-number">0</span><br>    m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;<br>        pre = pre+nums[i]<br>        v,ok:=m[pre-k]<br>        <span class="hljs-keyword">if</span> ok &#123;<br>            count+=v<br>        &#125;<br>     m[pre] += <span class="hljs-number">1</span><br>    &#125;<br><span class="hljs-keyword">return</span> count<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h3><p>题目链接：<a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></p><p>自己花了挺长时间才做出来，记录下思路</p><p>其实看到这题的想法是正确的，滑动窗口，map记录</p><p>但是这个窗口怎么定，我一开始的思路是不太好的，我一开始规定了窗口的大小</p><p>然后看了题解的，一开始将窗口定为0，然后如果没有包含字串就移动右指针，如果包含就移动左指针找最小子串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minWindow</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br>left, right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>minn := <span class="hljs-number">99999999</span><br>idx_left, idx_right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> t &#123;<br>m[<span class="hljs-type">byte</span>(v)]++<br>&#125;<br><br>count := <span class="hljs-number">0</span><br>_, ok := m[s[<span class="hljs-number">0</span>]]<br><span class="hljs-keyword">if</span> ok &#123;<br>m2[s[<span class="hljs-number">0</span>]]++<br><span class="hljs-keyword">if</span> m2[s[<span class="hljs-number">0</span>]] == m[s[<span class="hljs-number">0</span>]] &#123;<br>count++<br>&#125;<br>&#125;<br>right++<br><span class="hljs-keyword">for</span> right &lt;= <span class="hljs-built_in">len</span>(s) &#123;<br><span class="hljs-keyword">if</span> count == <span class="hljs-built_in">len</span>(m) &#123;<br><span class="hljs-keyword">if</span> minn &gt; right-left+<span class="hljs-number">1</span> &#123;<br>minn = right - left + <span class="hljs-number">1</span><br>idx_left = left<br>idx_right = right<br>&#125;<br>_, ok := m[s[left]]<br><span class="hljs-keyword">if</span> ok &#123;<br>m2[s[left]]--<br><span class="hljs-keyword">if</span> m2[s[left]] &lt; m[s[left]] &#123;<br>count--<br>&#125;<br>&#125;<br>left++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> right == <span class="hljs-built_in">len</span>(s) &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>_, ok := m[s[right]]<br><span class="hljs-keyword">if</span> ok &#123;<br>m2[s[right]]++<br><span class="hljs-keyword">if</span> m2[s[right]] == m[s[right]] &#123;<br>count++<br>&#125;<br>&#125;<br>right++<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> s[idx_left:idx_right]<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="数字序列中某一位的数字-模拟题"><a href="#数字序列中某一位的数字-模拟题" class="headerlink" title="数字序列中某一位的数字 (模拟题)"></a><strong>数字序列中某一位的数字</strong> (模拟题)</h3><p>题目链接：<a href="https://www.nowcoder.com/practice/29311ff7404d44e0b07077f4201418f5?tpId=13&tqId=2285751&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13"><strong>数字序列中某一位的数字</strong></a></p><p>这题难点主要是时间复杂度怎么降下来，不然当n等于10亿的时候会超时</p><p>我也是看了大佬的题解</p><p>1到9有9个数 9个单个数字</p><p>10到99 有 90个个数 ， 180个单个数字</p><p>100到999有900个个数， 2700个单个数字，由此类推</p><p>我们只需要将n与当前阶段所有的单个数字做个比较</p><p>当n小于当前阶段所有的单个数字后，就说明n在这个范围内</p><p>然后我们通过 n&#x2F;count（count表示当前阶段是几位数）来确定n所在是数是多少</p><p>通过n%count来确定n表示的是所在数的第几个数字</p><p>这边尤其要注意n得减去一，因为数组的下标是从0开始的，如果不减去1的话会越界</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> deep = <span class="hljs-number">9</span>;<br>        <span class="hljs-type">int</span> num =<span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span>  sum = <span class="hljs-number">9</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span> ;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (n&gt;sum) &#123;<br>           n-=sum;<br>           deep*=<span class="hljs-number">10</span>;<br>           count ++;<br>           sum = deep*count;<br>        &#125;<br>       <span class="hljs-type">int</span> index =  (n<span class="hljs-number">-1</span>)/count;<br>       string ans =    <span class="hljs-built_in">to_string</span>(deep/<span class="hljs-number">9</span> + index);<br>       n= (n<span class="hljs-number">-1</span>)%count;<br><br>        <span class="hljs-keyword">return</span> ans[n] -<span class="hljs-string">&#x27;0&#x27;</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote><p>个人对于这一块比较薄弱，所以开始可能会比较多的题目以及这些题目可能在后面基础扎实了后会觉得非常简单的题目，见谅~</p></blockquote><h3 id="JZ42-连续子数组的最大和"><a href="#JZ42-连续子数组的最大和" class="headerlink" title="JZ42 连续子数组的最大和"></a>JZ42 连续子数组的最大和</h3><p>题目链接： <a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=23259&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">连续子数组的最大和</a></p><p> 重新捡起动态规划的第一题。之前有一定的动态规划基础，所以见到这题就想用状态机，上来就来一个book[30000][2],来表示选或者不选对应的数，但发现无从下手（题刷少了，思维还是太僵硬了）</p><p>后直接看大佬的解析，然后领会到了意思后，很快就写出来了</p><p>因为是选数都要是连续的，所以我们可以将array[i]作为当前子数组dp[i]的结尾，这样的话就能构成递推关系了，我们只需要将array[i]和dp[i-1]+array[i]进行对比取最大的就可以得到dp[i]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param array int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-type">int</span> dp[<span class="hljs-number">30000</span>];<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; array)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        dp[<span class="hljs-number">0</span>]= array[<span class="hljs-number">0</span>];<br>         <span class="hljs-type">int</span> max1 = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]+array[i],array[i]);<br>            <span class="hljs-keyword">if</span> (max1&lt;dp[i]) &#123;<br>               max1 = dp[i];<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">return</span> max1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="买股票的最佳时机"><a href="#买股票的最佳时机" class="headerlink" title="买股票的最佳时机"></a>买股票的最佳时机</h3><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><p>题目链接： <a href="https://leetcode.cn/problems/target-sum/">目标和</a></p><p>经过数学转换后就是01背包问题</p><p>递归解法 ： 时间复杂度很差</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>,index <span class="hljs-type">int</span> )</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span>  &#123;<br>         <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <br>    &#125;<br>   <br>    <span class="hljs-keyword">if</span> nums[index]&gt; target &#123;<br>        <span class="hljs-keyword">return</span> dfs(nums,target,index<span class="hljs-number">-1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(nums,target,index<span class="hljs-number">-1</span>)+dfs(nums,target-nums[index],index<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//设选择的正数的和是p</span><br>    <span class="hljs-comment">//那么负数的和就是s , 总和是t    s = t -p </span><br>    <span class="hljs-comment">//所以  target =  p - t +p = 2p - t   p = (target+t) /2</span><br>    t :=  <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> _,v :=  <span class="hljs-keyword">range</span> nums&#123;<br>        t+=v<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (target + t )%<span class="hljs-number">2</span>!= <span class="hljs-number">0</span>  &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <br>    <span class="hljs-keyword">return</span>  dfs(nums,(target+t)/<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>动态规划解法，时间复杂度已经是最优的了，占用内存比上面的大些</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//设选择的正数的和是p</span><br>    <span class="hljs-comment">//那么负数的和就是s , 总和是t    s = t -p </span><br>    <span class="hljs-comment">//所以  target =  p - t +p = 2p - t   p = (target+t) /2</span><br>    t :=  <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> _,v :=  <span class="hljs-keyword">range</span> nums&#123;<br>        t+=v<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (target + t )%<span class="hljs-number">2</span>!= <span class="hljs-number">0</span> || target+t &lt; <span class="hljs-number">0</span>  &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <br>    target =  (target + t )/<span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> dp [<span class="hljs-number">21</span>][<span class="hljs-number">1100</span>]<span class="hljs-type">int</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] =<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i,v :=  <span class="hljs-keyword">range</span> nums&#123;<br>        <span class="hljs-keyword">for</span> j:= <span class="hljs-number">0</span> ;j&lt;target+<span class="hljs-number">1</span> ; j++&#123;<br>            <span class="hljs-keyword">if</span> j &lt; v &#123;<br>                dp[i+<span class="hljs-number">1</span>][j] = dp[i][j]<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i+<span class="hljs-number">1</span>][j] = dp[i][j] + dp[i][j-v]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)][target]  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h3><p>题目链接：<a href="https://leetcode.cn/problems/word-break/">单词拆分</a></p><p>代码很少，看起来也很简单，但是我当时在做的时候没思路QAQ，还是动态规划题刷太少了</p><p>用dp，先取字符串的子串，然后判断字串能否被字典里的字符串拼接表示</p><p>我当时觉得难主要是想着一个字符串可以拆成”l” “e” e” “t”等等，拆出非常多来</p><p>但后面发现其实都是子问题罢了 :joy:</p><p>还是太菜了，要狠狠的刷题！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(s <span class="hljs-type">string</span>, wordDict []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br>    <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> wordDict &#123;<br>         m[v] = <span class="hljs-literal">true</span><br>    &#125;<br>    dp:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>,<span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(s);i++ &#123;<br>        <span class="hljs-keyword">for</span> j :=<span class="hljs-number">0</span> ; j&lt;i;j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[j]&amp;&amp;m[s[j:i]]&#123;<br>                dp[i] = <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></p><p>时间复杂度和空间复杂度都比较差的做法，用了两个循环 O(n^2)</p><p>dp[i]表示当前以第 <em>i</em>个数字结尾的最长上升子序列的长度</p><p>所以如果nums[i]&gt; nums[j] 那么会有dp[i] &#x3D; dp[j]+1 (如果比dp【i】大的话)</p><p>自己当时做的时候想到了dp【i】的含义，但是就过程怎么计算出了点问题</p><p>还可以进行优化，插个眼</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>)<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>m := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>dp[i] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br><span class="hljs-keyword">if</span> nums[j] &lt; nums[i] &#123;<br>dp[i] = max(dp[i], dp[j]+<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br>m = max(m, dp[i])<br>&#125;<br><span class="hljs-keyword">return</span> m<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span> )</span></span><span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a&lt;b&#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span>  a<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a><strong>把数字翻译成字符串</strong></h3><p>题目链接：<a href="https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=13&tqId=1024831&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">把数字翻译成字符串</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;streambuf&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 解码</span><br><span class="hljs-comment">     * @param nums string字符串 数字串</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>   <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string nums)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>          <span class="hljs-type">int</span> dp[nums.<span class="hljs-built_in">size</span>()] ;<br>          <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                dp[i] += dp[i -<br>                            <span class="hljs-number">1</span>]; <span class="hljs-comment">// 如果nums[i]不为0，那么就可以单独作为一个数进行解析</span><br>            &#125;<br><br>            <span class="hljs-comment">//接着判断是否可以和nums[i-1]进行组合翻译</span><br>            <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                string str;<br>                str.<span class="hljs-built_in">push_back</span>(nums[i - <span class="hljs-number">1</span>]);<br>                str.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stoi</span>(str) &gt;= <span class="hljs-number">10</span> &amp;&amp; <span class="hljs-built_in">stoi</span>(str) &lt;= <span class="hljs-number">26</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//即f(2)，因为不存在f(0)，所以需要特殊处理：</span><br>                        dp[i] += <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i] += dp[i - <span class="hljs-number">2</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>];<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p>题目链接： <a href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">1</span>)<br>    m[<span class="hljs-number">0</span>] =<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++ &#123;<br>        minn:= math.MaxInt32<br>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>; j*j&lt;=i;j++ &#123;<br>            minn = min(minn,m[i-j*j])<br>        &#125;<br>        m[i] = minn+<span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> m[n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span> )</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a&lt;b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/maximum-product-subarray/">乘积最大子数组</a></p><p>题解的思路非常的巧妙简洁</p><p>题解用了两种状态进行记录而不是一种</p><p>并且使用滚动数组将空间复杂度降到了O(1), 因为包含当前下标乘积dp[i] 和他的前一个dp[i-1]是强相关的</p><p>为什么使用两种状态会是使得代码变得更简洁更优雅</p><p>使用一种状态的话，对于nums[i]大于等于0的时候是没有影响的</p><p>但是当nums[i]小于0的时候，dp[i]和dp[i-1]不是强相关的</p><p>如果dp[i]是正的，如果使用nums[i]大于0的递推公式，那么比如 -2 3 -4  ，会因为dp[1] &#x3D;3 ,3* -4 &#x3D; -12 而使得dp[2] &#x3D; -4,但是实际上dp[2]&#x3D; -2* 3 *-4 &#x3D; 24</p><p>如果要处理的话要加很多条件语句进行判断</p><p>但如果使用两种状态的话，比如定义一个max和min ，分别用于计入下标i之前最大值和最小值</p><p>当nums[i]大于0的时候，乘上最大值，那么得到的就是dp[i]的最大值</p><p>当nums[i]是小于0时，可以尝试乘上最小值，如果最小值是小于0的，那么就会的到一个最大值，这样就可以解决nums[i]为负数的问题</p><p>引入一个最小值的状态，可谓是画龙点睛之笔</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>m := nums[<span class="hljs-number">0</span>]<br>    mi:=  nums[<span class="hljs-number">0</span>]<br>    ans := nums[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;    <br>    mx, mn := m, mi<br>m= max(max(nums[i], mx*nums[i]),nums[i]*mn)<br>    mi = min( min(nums[i], mn*nums[i]),mx*nums[i])     <br>         ans =max(ans,m)<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span> )</span></span><span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a&lt;b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span> )</span></span><span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a&gt;b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></p><p>虽然一次就做出了并且ac了，并且代码也还算优雅</p><p>但一看时间复杂度和空间复杂度。。。我太菜了还是QAQ</p><p>记录一下自己的解法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">//就是个类0-1背包</span><br>count := <span class="hljs-number">0</span><br>ans := <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>count += v<br>&#125;<br><span class="hljs-keyword">if</span> count%<span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><span class="hljs-keyword">var</span> dp [<span class="hljs-number">210</span>][<span class="hljs-number">20010</span>]<span class="hljs-type">int</span><br>dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]] = nums[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; count; j++ &#123;<br><span class="hljs-keyword">if</span> dp[i<span class="hljs-number">-1</span>][j] != <span class="hljs-number">0</span> &#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]<br>&#125;<br><span class="hljs-keyword">if</span> dp[i<span class="hljs-number">-1</span>][j] != <span class="hljs-number">0</span> &amp;&amp; dp[i][j]+nums[i] == dp[i<span class="hljs-number">-1</span>][j]+nums[i] &#123;<br>dp[i][j+nums[i]] = dp[i<span class="hljs-number">-1</span>][j] + nums[i]<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> dp[i][count/<span class="hljs-number">2</span>] == count/<span class="hljs-number">2</span> &#123;<br>ans = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><p>优化插个眼</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h3><p>题目链接 ：<a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=23260&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">数组中的逆序对</a></p><p>使用到了归并排序的思想 （然而平时不怎么用，忘的差不多了。。 回顾一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param nums int整型vector</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; sourceArr, <span class="hljs-type">int</span> tempArr[], <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> midIndex,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-type">int</span> endIndex)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = startIndex, j = midIndex + <span class="hljs-number">1</span>, k = startIndex;<br>        <span class="hljs-keyword">while</span> (i != midIndex + <span class="hljs-number">1</span> &amp;&amp; j != endIndex + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (sourceArr[i] &gt; sourceArr[j]) &#123;<br>                tempArr[k++] = sourceArr[j++];<br>                count+=midIndex-i+<span class="hljs-number">1</span>;<br>                count %= <span class="hljs-number">1000000007</span>;<br>            &#125; <span class="hljs-keyword">else</span><br>                tempArr[k++] = sourceArr[i++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i != midIndex + <span class="hljs-number">1</span>)<br>            tempArr[k++] = sourceArr[i++];<br>        <span class="hljs-keyword">while</span> (j != endIndex + <span class="hljs-number">1</span>)<br>            tempArr[k++] = sourceArr[j++];<br>        <span class="hljs-keyword">for</span> (i = startIndex; i &lt;= endIndex; i++)<br>            sourceArr[i] = tempArr[i];<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; sourceArr, <span class="hljs-type">int</span> tempArr[], <span class="hljs-type">int</span> startIndex,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">int</span> endIndex)</span> </span>&#123;<br>        <span class="hljs-type">int</span> midIndex;<br>        <span class="hljs-keyword">if</span> (startIndex &lt; endIndex) &#123;<br>            midIndex = startIndex + (endIndex - startIndex) / <span class="hljs-number">2</span>; <br>            <span class="hljs-built_in">MergeSort</span>(sourceArr, tempArr, startIndex, midIndex);<br>            <span class="hljs-built_in">MergeSort</span>(sourceArr, tempArr, midIndex + <span class="hljs-number">1</span>, endIndex);<br>            <span class="hljs-built_in">Merge</span>(sourceArr, tempArr, startIndex, midIndex, endIndex);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> b[nums.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">MergeSort</span>(nums, b, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/two-sum/solutions/434597/liang-shu-zhi-he-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked">两数之和</a></p><p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N)O(N) 降低到 O(1)O(1)O(1)。</p><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>      <span class="hljs-keyword">var</span> m  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>        <span class="hljs-keyword">for</span> i,v := <span class="hljs-keyword">range</span> nums&#123;<br>           index ,ok:= m[target-v];<br>           <span class="hljs-keyword">if</span> !ok &#123;<br>             m[v] = i;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;index,i&#125;<br>           &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">字母异位词分组</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(strs []<span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">var</span> m  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">var</span> str [][]<span class="hljs-type">string</span><br>   <br>    <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> strs&#123;<br>        chars := []<span class="hljs-type">byte</span>(v)<br>        sort.Slice(chars,<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>&#123;<br>             <span class="hljs-keyword">return</span> chars[i] &lt; chars[j]<br>        &#125;)<br>         sortedStr := <span class="hljs-type">string</span>(chars)<br>        m[sortedStr] = <span class="hljs-built_in">append</span>(m[sortedStr],v)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> m&#123;<br>        str=<span class="hljs-built_in">append</span>(str,v)<br>    &#125; <br>         <br>    <span class="hljs-keyword">return</span> str<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h3><p> 题目链接 <a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></p><p>我的解法 O(nlogn + n)   </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>     <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>     <span class="hljs-built_in">len</span> := <span class="hljs-number">0</span><br>     sort.Ints(nums)<br>    <span class="hljs-keyword">for</span> _ ,v := <span class="hljs-keyword">range</span> nums&#123;<br>        _,ok := m[v<span class="hljs-number">-1</span>]<br>        <span class="hljs-keyword">if</span> !ok &#123;<br>            m[v]=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>&lt;m[v])&#123;<br>                <span class="hljs-built_in">len</span>= m[v]<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            m[v]=m[v<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span><br>             <span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>&lt;m[v])&#123;<br>                <span class="hljs-built_in">len</span>= m[v]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span><br>&#125;<br></code></pre></td></tr></table></figure><p>O(n)或者说O(2n)解法  </p><p>这边是直接复制题解的，其实两种方法大差不差，都是根据m[i-1]来判断长度，这个就是将排序换成了初始化map，然后每次会重新统计总数</p><p>但是这种解法确实会比我的更加节省内存，以及确实更快</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        m[v] = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">var</span> maxCount <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> tmpCount <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> num := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">if</span> m[num<span class="hljs-number">-1</span>] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        tmpCount = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> m[num] &#123;<br>            num++<br>            tmpCount++<br>        &#125;<br>        <span class="hljs-keyword">if</span> tmpCount &gt; maxCount &#123;<br>            maxCount = tmpCount<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxCount<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><p>题目链接 <a href="https://leetcode.cn/problems/move-zeroes/">移动零</a></p><p>个人解法，时间复杂度和空间复杂度都高了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>     length := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span>  i:=<span class="hljs-number">0</span>;i&lt;length; &#123;<br>        <span class="hljs-keyword">if</span> nums[i]==<span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> i==length &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            <span class="hljs-keyword">for</span>  j := i;j&lt;length<span class="hljs-number">-1</span>;j++&#123;<br>                temp :=  nums[j]<br>                nums[j]=nums[j+<span class="hljs-number">1</span>]<br>                nums[j+<span class="hljs-number">1</span>]=temp<br>            &#125;<br>            length--<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i++<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>更快更简单的解法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>     length := <span class="hljs-built_in">len</span>(nums)<br>     left:=<span class="hljs-number">0</span><br>     right :=<span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> left&lt;length&amp;&amp;right&lt;length &#123;<br>        <span class="hljs-keyword">if</span> nums[right] != <span class="hljs-number">0</span> &#123;<br>            nums[left], nums[right] = nums[right], nums[left]   <span class="hljs-comment">//这样写会更加节省时间</span><br>            left++<br>        &#125;<br>        right++<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/3sum/">三数之和</a></p><p>突然发现灵神讲的确实挺不错的，看他的讲三数之和的视频没到一半就懂了 ，很透彻，有引导</p><p>强烈推荐  <a href="https://www.bilibili.com/video/BV1bP411c7oJ/?vd_source=9b4c75905899e9c060de474426e69d22">灵神视频</a></p><p>灵神视频里提到一个点：<strong>如果数组是有序的就可以使用相向双指针了</strong> ， 感觉还是挺有用的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Ints(nums) <span class="hljs-comment">//排好序后就可以使用相向双指针了</span><br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> ans [][]<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>; i++ &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>k := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>j := i + <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> j &lt; k &#123;<br><span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="hljs-number">0</span> &#123;<br>ans = <span class="hljs-built_in">append</span>(ans, []<span class="hljs-type">int</span>&#123;nums[i], nums[j], nums[k]&#125;)<br>j++<br><span class="hljs-keyword">for</span> j&lt;k&amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>j++<br>&#125;<br>k--<br><span class="hljs-keyword">for</span> k&gt;j&amp;&amp; nums[k] == nums[k+<span class="hljs-number">1</span>] &#123;<br>k--<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[k] &lt; <span class="hljs-number">0</span> &#123;<br>j++<br><span class="hljs-keyword">for</span> j&lt;k&amp;&amp;nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>j++<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[k] &gt; <span class="hljs-number">0</span> &#123;<br>k--<br><span class="hljs-keyword">for</span>  k&gt;j&amp;&amp;nums[k] == nums[k+<span class="hljs-number">1</span>] &#123;<br>k--<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></p><p>通过移动左右双指针来找两边的max高度，因为小于max高度就说明该高度是可能可以接水的</p><p>由因为木桶效应，能不能接水关键取决于最短的那条边，所以我们通过对pre_max和suf_max进行后，对小的那边进行运算，max减去height就是可以接的雨水</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left :=<span class="hljs-number">0</span> <br>    right := <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span><br>    pre_max := <span class="hljs-number">0</span><br>    suf_max := <span class="hljs-number">0</span><br>    ans :=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left&lt;=right&#123;<br>      pre_max = max(pre_max,height[left])<br>      suf_max = max(suf_max,height[right])<br>      <span class="hljs-keyword">if</span> pre_max &lt; suf_max&#123;<br>        ans +=pre_max - height[left]<br>        left++<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        ans+=suf_max-height[right]<br>        right--<br>      &#125;<br>     <br>    &#125;<br><br>  <span class="hljs-keyword">return</span> ans<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">if</span> a&lt;b&#123;<br>    <span class="hljs-keyword">return</span> b<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> a<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h3><p>题目连接 ：<a href="https://leetcode.cn/problems/set-matrix-zeroes/">矩阵置零</a></p><p>这题要想实现常数级的空间复杂度，需要复用matrix的空间，用第一行和第一列进行标记该行或该列是否有值为0的数</p><p>在标记完成后，再通过一轮遍历完成赋值0，最后再对第一行和第一列进行处理，避免发生覆盖</p><p>这边要注意的一个点就是在赋值的时候记得把<code>matrix[0][0]</code>给跳过了，不然如果这个地方的值为0，将会发生覆盖现象，因为这个点会先处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @Author: lrc</span><br><span class="hljs-comment"> * @Date: 2023/9/25-14:29</span><br><span class="hljs-comment"> * @Desc:</span><br><span class="hljs-comment"> **/</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> &#123;<br>flag_h := <span class="hljs-number">0</span><br>flag_l := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]); i++ &#123;<br><span class="hljs-keyword">if</span> flag_h == <span class="hljs-number">0</span> &amp;&amp; matrix[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span> &#123;<br>flag_h = <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br><span class="hljs-keyword">if</span> flag_l == <span class="hljs-number">0</span> &amp;&amp; matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &#123;<br>flag_l = <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> matrix &#123;<br><span class="hljs-keyword">for</span> j, va := <span class="hljs-keyword">range</span> v &#123;<br><span class="hljs-keyword">if</span> va == <span class="hljs-number">0</span> &#123;<br>matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// matrix[0][0]有影响</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> matrix &#123;<br><span class="hljs-keyword">for</span> j, _ := <span class="hljs-keyword">range</span> v &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &#123;<br>matrix[i][j] = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">if</span> matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span> &#123;<br>matrix[i][j] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]); i++ &#123;<br><span class="hljs-keyword">if</span> flag_h == <span class="hljs-number">1</span> &#123;<br>matrix[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br><span class="hljs-keyword">if</span> flag_l == <span class="hljs-number">1</span> &#123;<br>matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h3><p>题目链接：<a href="https://leetcode.cn/problems/rotate-image/">旋转图像</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span>  &#123;<br>    n:= <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> matrix &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> matrix &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>; j++ &#123;<br>        matrix[i][j], matrix[i][n-j] = matrix[i][n-j], matrix[i][j]<br>    &#125;<br>&#125;<br><br>&#125;   <br></code></pre></td></tr></table></figure><p>看到了一个题解我觉得写的思路非常好,这边记录一下</p><p>解题思路<br>顺时针旋转90：先沿对角线反转矩阵，再沿竖中轴线反转矩阵；<br>顺时针旋转180：先沿横中轴线反转矩阵，再沿竖中轴线反转矩阵；<br>顺时针旋转270：先沿对角线反转矩阵，再沿横中轴线反转矩阵；<br>代码<br>给出各种方式的反转的实现，解具体题目时将他们组合就好了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go">idx, halfLen := <span class="hljs-built_in">len</span>(matrix)<span class="hljs-number">-1</span>, <span class="hljs-built_in">len</span>(matrix) / <span class="hljs-number">2</span> <span class="hljs-comment">// 记录最后一个元素的下标和边长的一半</span><br><br><span class="hljs-comment">// 按对角线反转矩阵</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> matrix &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 按竖中轴线反转矩阵</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> matrix &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; halfLen; j++ &#123;<br>        matrix[i][j], matrix[i][idx-j] = matrix[i][idx-j], matrix[i][j]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 按横中轴线反转矩阵</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; helfLen; i++ &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> matrix[i] &#123;<br>        matrix[idx-i][j], matrix[i][j] = matrix[i][j], matrix[idx-i][j]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/product-of-array-except-self/">除自身以外数组的乘积</a></p><p>时间复杂度和空间复杂度都太差了，插个眼待优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  []<span class="hljs-type">int</span> &#123;<br>    L := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))<br>     R := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))<br>     ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))<br><br>    L[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i,_ := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        L[i] = L[i<span class="hljs-number">-1</span>]*nums[i]<br>    &#125;<br>    R[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>] = nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;<br>        R[i] = R[i+<span class="hljs-number">1</span>]*nums[i]<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>  &#123;<br>            ans[i] = R[i+<span class="hljs-number">1</span>]<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ans[i]= L[i<span class="hljs-number">-1</span>]*R[i+<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    ans[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]=L[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>]<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><p>优化后的代码</p><p>可以不开辟除了返回的数组外的其他数组，可以在算右侧后缀积的时候顺便把答案算出来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  []<span class="hljs-type">int</span> &#123;<br>    L := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))<br><br><br>    L[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>;i++ &#123;<br>        L[i] = L[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>]<br>    &#125;<br>    r := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;<br>        L[i] = L[i]*r<br>        r*=nums[i]<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> L<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/first-missing-positive/">缺失的第一个正数</a></p><p>直接用排序然后来做空间复杂度会更好一点，但时间复杂度不知道，反正不是O(n)</p><p>要不用排序的话得用置换的方法，如果对应下标的存的值不是对应nums，那么就将存的值换到对应下标下</p><p>同时用len（n）进行约束 （如果对应的数值超出了len（n），对应下标超出了nums的范围，直接不交换即可）</p><p>只有nums[i]不满足条件的时候才进行++，不然无法正确归位各数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n:= <span class="hljs-built_in">len</span>(nums)<br>    i:= <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> i&lt;<span class="hljs-built_in">len</span>(nums)  &#123;<br>        <span class="hljs-keyword">if</span> nums[i] != i+<span class="hljs-number">1</span>&amp;&amp;nums[i]&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]&lt;n &#123;<br>            <span class="hljs-keyword">if</span> nums[nums[i]<span class="hljs-number">-1</span>] != nums[i] &#123;<br>             nums[i], nums[nums[i]<span class="hljs-number">-1</span>] = nums[nums[i]<span class="hljs-number">-1</span>],nums[i]<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>i++<br>&#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i++<br>          &#125;<br>    &#125; <br><br>    <span class="hljs-keyword">for</span> j,v :=<span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span>  j+<span class="hljs-number">1</span> != v &#123;<br>            <span class="hljs-keyword">return</span> j+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> n+<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/">反转链表 II</a></p><p>最初的代码，思路基本正确，但没考虑到left 等于1的情况，此时没有节点指向left &#x3D; 1 的节点，如果通过变量来记录的话，最后将记录变量的next指向新节点的时候会报错，因为他是空的</p><p>解决方法就是在最前面加一个哨兵节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>  <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> head.Next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> head<br>&#125;<br>  <span class="hljs-keyword">var</span> dummy *ListNode = head <br><span class="hljs-keyword">var</span> pre, cur, l, r *ListNode = dummy, head, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>count := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> count != left &#123;<br>pre = cur<br>cur = cur.Next<br>count++<br>&#125;<br>l = pre<br>r = cur<br><span class="hljs-keyword">for</span> count != right+<span class="hljs-number">1</span> &#123;<br>nxt := cur.Next<br>cur.Next = pre<br>pre = cur<br>cur = nxt<br>count++<br><br>&#125;<br>l.Next = pre<br>r.Next = cur<br><span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure><p>解决问题后的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> head.Next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> head<br>&#125;<br>dummy := &amp;ListNode&#123;Next: head&#125;<br>p0 := dummy<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; left<span class="hljs-number">-1</span>; i++ &#123;<br>p0 = p0.Next<br>&#125;<br><span class="hljs-keyword">var</span> pre, cur *ListNode = <span class="hljs-literal">nil</span>, head<br>count := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> count != left &#123;<br>pre = cur<br>cur = cur.Next<br>count++<br>&#125;<br><br><span class="hljs-keyword">for</span> count != right+<span class="hljs-number">1</span> &#123;<br>nxt := cur.Next<br>cur.Next = pre<br>pre = cur<br>cur = nxt<br>count++<br><br>&#125;<br><br>p0.Next.Next = cur<br>p0.Next = pre<br><span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N <strong>个结点</strong></h3><p>题目链接： <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></p><p>最优做法使用双指针，左指针距离右指针n个距离</p><p>注意使用哨兵节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> dummy *ListNode = &amp;ListNode&#123;Val:<span class="hljs-number">0</span>,Next:<span class="hljs-literal">nil</span>&#125;<br>    dummy.Next = head<br>    <span class="hljs-keyword">var</span> left,right *ListNode =dummy, head<br>    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>;i&lt;n;i++ &#123;<br>        right= right.Next<br>    &#125;<br>    <span class="hljs-keyword">for</span> right != <span class="hljs-literal">nil</span>&#123;<br>        right = right.Next<br>        left = left.Next<br>    &#125;<br>    left.Next = left.Next.Next<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>tmp1 := head<br>tmp2 := head<br><span class="hljs-keyword">var</span> l *ListNode = head<br>dummy := &amp;ListNode&#123;Val: <span class="hljs-number">0</span>, Next: head&#125;<br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> l != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">var</span> pre, cur, tmp3 *ListNode = <span class="hljs-literal">nil</span>, tmp1, tmp1<br><span class="hljs-keyword">for</span> count != k &amp;&amp; l != <span class="hljs-literal">nil</span> &#123;<br>count++<br>l = l.Next<br>&#125;<br><span class="hljs-keyword">if</span> count != k &#123;<br><span class="hljs-keyword">if</span> tmp1 == head &#123;<br><span class="hljs-keyword">return</span> dummy.Next<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tmp2.Next = tmp1<br><span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> cur != l &amp;&amp; count != <span class="hljs-number">1</span> &#123;<br>nxt := cur.Next<br>tmp1 = nxt <span class="hljs-comment">//</span><br>cur.Next = pre<br>pre = cur<br>cur = nxt<br>&#125;<br><span class="hljs-keyword">if</span> dummy.Next == head &amp;&amp; count != <span class="hljs-number">1</span> &#123;<br>dummy.Next = pre<br>tmp2 = head<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> count != <span class="hljs-number">1</span> &#123;<br>tmp2.Next = pre<br>tmp2 = tmp3<br>&#125;<br>&#125;<br><br>count = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">随机链表的复制</a></p><p>这题可以用哈希表或者迭代的方式来做</p><p>但是哈希表加两次遍历是最简单且时间复杂度低的，空间复杂度中等</p><p>使用迭代空间复杂度最低，但是时间复杂度高，得遍历三次</p><p>哈希表加回溯，时间复杂度高，空间复杂度也高，代码也不易理解，下下策</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyRandomList</span><span class="hljs-params">(head *Node)</span></span> *Node &#123;<br>    hash := <span class="hljs-keyword">map</span>[*Node]*Node&#123;&#125;<br>    <span class="hljs-keyword">for</span> it := head; it != <span class="hljs-literal">nil</span>; it = it.Next &#123;<br>        hash[it] = &amp;Node&#123;it.Val, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125; <br>    &#125;<br>    <span class="hljs-keyword">for</span> it := head; it != <span class="hljs-literal">nil</span>; it = it.Next &#123;<br>        itNew := hash[it]<br>        itNew.Next, itNew.Random = hash[it.Next], hash[it.Random] <br>    &#125;<br>    <span class="hljs-keyword">return</span> hash[head]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a></p><p>双百做法 ： 递归</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(left *TreeNode,right *TreeNode)</span></span><span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> (left ==<span class="hljs-literal">nil</span>&amp;&amp;right!=<span class="hljs-literal">nil</span>)||(left != <span class="hljs-literal">nil</span> &amp;&amp;right==<span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span>&amp;&amp;right==<span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <br>    &#125;<br><br>    <span class="hljs-keyword">if</span> left.Val == right.Val&#123;<br>        ok:=dfs(left.Left,right.Right)<br>        ok2:=dfs(left.Right,right.Left)<br>        <span class="hljs-keyword">return</span> ok&amp;&amp;ok2<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(root.Left,root.Right)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这题很简单，但是因为要用迭代来做所以查个眼，回来把迭代做法补上</p><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></p><p>解法一 ： 使用两个队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> (ans [][]<span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br>q := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">1</span>)<br>q2 := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">0</span>)<br>q[<span class="hljs-number">0</span>] = root<br>top := <span class="hljs-number">0</span><br>top2 := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> top != <span class="hljs-built_in">len</span>(q) || top2 != <span class="hljs-built_in">len</span>(q2) &#123;<br>m2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> top != <span class="hljs-built_in">len</span>(q) &#123;<br>m2 = <span class="hljs-built_in">append</span>(m2, q[top].Val)<br><span class="hljs-keyword">if</span> q[top].Left != <span class="hljs-literal">nil</span> &#123;<br>q2 = <span class="hljs-built_in">append</span>(q2, q[top].Left)<br>&#125;<br><span class="hljs-keyword">if</span> q[top].Right != <span class="hljs-literal">nil</span> &#123;<br>q2 = <span class="hljs-built_in">append</span>(q2, q[top].Right)<br>&#125;<br><br>top++<br><span class="hljs-keyword">if</span> top == <span class="hljs-built_in">len</span>(q) &#123;<br>ans = <span class="hljs-built_in">append</span>(ans, m2)<br>q = q[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>top = <span class="hljs-number">0</span><br>m := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> top2 != <span class="hljs-built_in">len</span>(q2) &#123;<br><br>m = <span class="hljs-built_in">append</span>(m, q2[top2].Val)<br><span class="hljs-keyword">if</span> q2[top2].Left != <span class="hljs-literal">nil</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, q2[top2].Left)<br>&#125;<br><span class="hljs-keyword">if</span> q2[top2].Right != <span class="hljs-literal">nil</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, q2[top2].Right)<br>&#125;<br><br>top2++<br><span class="hljs-keyword">if</span> top2 == <span class="hljs-built_in">len</span>(q2) &#123;<br>ans = <span class="hljs-built_in">append</span>(ans, m)<br>q2 = q2[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>top2 = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解法二优化 ： 使用一个队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> (ans [][]<span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br>q := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">1</span>)<br>q[<span class="hljs-number">0</span>] = root<br>top := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) != <span class="hljs-number">0</span> &#123;<br>n := <span class="hljs-built_in">len</span>(q)<br>m2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> top != n &#123;<br>m2 = <span class="hljs-built_in">append</span>(m2, q[top].Val)<br><span class="hljs-keyword">if</span> q[top].Left != <span class="hljs-literal">nil</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, q[top].Left)<br>&#125;<br><span class="hljs-keyword">if</span> q[top].Right != <span class="hljs-literal">nil</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, q[top].Right)<br>&#125;<br>top++<br><br><span class="hljs-keyword">if</span> top == n &#123;<br>ans = <span class="hljs-built_in">append</span>(ans, m2)<br>q = q[n:]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>top = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>两种方法各有优势，第一种方法使用两个队列，对于内存的消耗来说是小于第二种方法的，第二种方法就是速度会比第一种方法的快</p><h3 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a>二叉搜索树中第K小的元素</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第K小的元素</a></p><p>之前自己想的太复杂了，发现一篇题解的代码非常简洁高效，就直接用他的代码了</p><p>（水平还不够，鉴定为刷题刷少了0.0）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(root *TreeNode, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *TreeNode)</span></span><br>    f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *TreeNode)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span>&#123;<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    f(n.Left)<br>    arr = <span class="hljs-built_in">append</span>(arr,n.Val)<br>    f(n.Right)<br>    &#125;<br>    f(root)<br>    <span class="hljs-keyword">return</span> arr[k<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></p><p>时间复杂度太差了，待优化</p><p>还是我太垃圾了，官方题解的最后一种做法直接可以达到双百QAQ</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>l := dfs(root.Left)<br>    <span class="hljs-keyword">var</span> r *TreeNode<br><span class="hljs-keyword">if</span> l == <span class="hljs-literal">nil</span> &#123;<br>r = dfs(root.Right)<br><span class="hljs-keyword">if</span> r == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> root<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>tmp := root.Right<br>root.Right = root.Left<br>l.Right = tmp<br>root.Left = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> l.Right == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> l<br>&#125;<br><span class="hljs-keyword">return</span> dfs(l.Right)<br>&#125;<br><br><span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> r != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> r<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> dfs(root.Right)<br>        &#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> root ==<span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    dfs(root)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III"></a>路径总和 III</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/path-sum-iii/">路径总和 III</a></p><p>这题剑指offer上有，但是当时是用的暴力做法做的，今天在leetcode上二刷，换了种更好的思路，利用前缀和来完成这一题，可以得到最优的时间复杂度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span> <br>    ans  := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *TreeNode,num <span class="hljs-type">int</span>)</span></span><br>   dfs =   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *TreeNode,num <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    ans += m[num + root.Val - targetSum]<br>    m[num + root.Val] +=<span class="hljs-number">1</span> <br>    dfs(root.Left,num + root.Val)<br>    dfs(root.Right,num + root.Val)<br>    m[num+root.Val]--<br>    <span class="hljs-keyword">return</span> <br>&#125;<br>    dfs(root,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>题目链接：<a href="https://leetcode.cn/problems/subsets/">子集</a></p><p>灵神讲解视频：<a href="https://www.bilibili.com/video/BV1mG4y1A7Gu/?vd_source=9b4c75905899e9c060de474426e69d22">回溯算法套路①子集型回溯【基础算法精讲 14】_哔哩哔哩_bilibili</a></p><p>子集型回溯，对每一个元素都进行判断选或者不选，递归到最后</p><p>坑点：记得copy，不要直接把tmp append进去了&gt;_&lt;</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> (ans [][]<span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> count == <span class="hljs-built_in">len</span>(nums) &#123;<br>a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>a = <span class="hljs-built_in">append</span>(a, tmp...)<br>ans = <span class="hljs-built_in">append</span>(ans, a)<br><span class="hljs-keyword">return</span><br>&#125;<br>dfs(count + <span class="hljs-number">1</span>)<br>tmp = <span class="hljs-built_in">append</span>(tmp, nums[count])<br>dfs(count + <span class="hljs-number">1</span>)<br>tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span><br>&#125;<br>dfs(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p>题目链接： <a href="https://leetcode.cn/problems/combination-sum/">组合总和</a></p><p>首先拿到题目可以认为这是一道组合型回溯</p><p>但是题目要求每个数都可以无限次使用 - - - &gt; 那么我们对每个数就不是采取选或者不选这种策略了</p><p>不是说每个数可无限选吗，那么我每次递归都对所有的数进行判断，无论之前选没选过</p><p>这样可以得出正确结果，<strong>但是有重复</strong></p><p>这边翻了下leetcode题解，发现有个大佬的思路非常巧妙简洁&gt;_&lt;</p><p>思路是每次递归的时候传一个head参数进去，做为下一个数的起点</p><p>这样就能很好的避免出现右边出现之前出现过的数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> (ans [][]<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">//那其实就是每次都计算所有条件</span><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> tmp []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">( head <span class="hljs-type">int</span>)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> count == target&#123;<br>           ans = <span class="hljs-built_in">append</span>(ans,<span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>),tmp...))<br>           <span class="hljs-keyword">return</span>  <br>        &#125;<br>        <span class="hljs-keyword">for</span> i:=head;i&lt;<span class="hljs-built_in">len</span>(candidates);i++&#123;<br>            <span class="hljs-keyword">if</span>  candidates[i]+count&lt;=target&#123;<br>                count += candidates[i]<br>                tmp =<span class="hljs-built_in">append</span>(tmp,candidates[i])<br>                dfs(i)<br>                tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>                count-= candidates[i]<br>            &#125;<br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span>  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/palindrome-partitioning/">分割回文串</a></p><p>这题也是可以用选或者不选来做，但是在实现的时候有变，不只是单纯的不选就直接dfs(i+1),选了的话就记录状态</p><p>这里使用了一个for循环来实现基于前一个分割处往后所有的字符串的可能性</p><p>并进行判断，如果字符串是回文的，那么就以该字符串的结尾+1作为dfs的参数（下一个字符串的起点）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ishuiwen</span><span class="hljs-params">(a <span class="hljs-type">string</span>)</span></span><span class="hljs-type">bool</span>&#123;<br>    <span class="hljs-keyword">if</span> a == <span class="hljs-string">&quot;&quot;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    head := <span class="hljs-number">0</span><br>    near := <span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> head &lt; near &#123;<br>        <span class="hljs-keyword">if</span> a[head] == a[near]&#123;<br>            head ++ <br>            near --<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (ans [][]<span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">var</span> tmp []<span class="hljs-type">string</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span> , <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>  count == <span class="hljs-built_in">len</span>(s) &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans ,<span class="hljs-built_in">append</span>([]<span class="hljs-type">string</span>(<span class="hljs-literal">nil</span>),tmp...))<br>            <span class="hljs-keyword">return</span> <br>        &#125;<br>        <span class="hljs-keyword">for</span> j := count;j&lt;<span class="hljs-built_in">len</span>(s);j++ &#123;<br>            <span class="hljs-keyword">if</span> ishuiwen(s[count:j+<span class="hljs-number">1</span>]) &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp,s[count:j+<span class="hljs-number">1</span>])<br>                dfs(j+<span class="hljs-number">1</span>)<br>                tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ans <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/course-schedule/">课程表</a></p><p>图论的题有向图还是有点难度的，这里记录一下刷到的一题有向图的算法题目</p><p>注意，无向图如果几个点相互之间都连起来了，那就真的是环，但有向图得看方向，不一定就是环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-type">int</span>, prerequisites [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">var</span> nums [][]<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br>nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>))<br>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> prerequisites &#123;<br>nums[v[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(nums[v[<span class="hljs-number">1</span>]], v[<span class="hljs-number">0</span>])<br>&#125;<br><span class="hljs-comment">//检查是否有有向环</span><br><span class="hljs-keyword">var</span> visited []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, numCourses)<br><span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span><br>dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> visited[i] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> visited[i] == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>visited[i] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums[i] &#123;<br><span class="hljs-keyword">if</span> !dfs(v) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>visited[i] = <span class="hljs-number">-1</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br><span class="hljs-keyword">if</span> !dfs(i) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081实验记录</title>
    <link href="/2023/09/02/MIT6-S081%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/02/MIT6-S081%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>吸取cs144的教训，一定要写完一个lab就把blog给写了，不然时间久了，要么不记得了，要么就会觉得当时卡了很久的问题，其实很简单，不想写上去</p><p>装环境这块相比cs144来说更麻烦一点，需要自己下载编译，但是按照官方的安装说明来其实也还好</p><p><a href="https://pdos.csail.mit.edu/6.S081/2020/tools.html">实验环境安装</a></p><p>因为才重新开始写blog不久，确实有很多地方做的不太好，目前来说的几篇blog感觉不能让读者非常轻松的阅读，只适合自己阅读，这点后面慢慢改吧</p><p>（9.4：因为lab1和lab2没有用git做版本控制导致库里没有这两实验的相关code，只能在blog里记录了）</p><h2 id="lab1-Xv6-and-Unix-utilities"><a href="#lab1-Xv6-and-Unix-utilities" class="headerlink" title="lab1 Xv6 and Unix utilities"></a>lab1 Xv6 and Unix utilities</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><p>This lab will familiarize you with xv6 and its system calls.</p><h3 id="sleep-easy"><a href="#sleep-easy" class="headerlink" title="sleep (easy)"></a>sleep (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h3><p>练手题，非常简单  主要是熟悉一下怎么输入输出</p><p>因为我开始并不熟悉整个实验的环境和测试流程，所以sleep我就拿大佬的代码来快速上手了，代码也很简单，主要是熟悉一下实验平台</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// sleep.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span> <span class="hljs-comment">// 必须以这个顺序 include，由于三个头文件有依赖关系</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: sleep &lt;ticks&gt;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pingpong-easy"><a href="#pingpong-easy" class="headerlink" title="pingpong (easy)"></a>pingpong (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h3><p>这里涉及到两个关键的点，fork（）和pipe（），如果能理解到这两系统调用的作用是什么，那这题也非常简单</p><p>todo： pipe()的概念</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span> <span class="hljs-comment">// 必须以这个顺序 include，由于三个头文件有依赖关系</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-type">int</span> pi[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> pi2[<span class="hljs-number">2</span>];<br>    pipe(pi);<br>    pipe(pi2);<br>    <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-type">char</span> buf;<br>        read(pi[<span class="hljs-number">0</span>],&amp;buf,<span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>,getpid());<br>        write(pi2[<span class="hljs-number">1</span>],&amp;buf,<span class="hljs-keyword">sizeof</span>(buf));<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        write(pi[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;?&quot;</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">char</span> buf;<br>        read(pi2[<span class="hljs-number">0</span>],&amp;buf,<span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>,getpid());<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="primes-moderate-hard"><a href="#primes-moderate-hard" class="headerlink" title="primes (moderate)&#x2F;(hard)"></a>primes (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)&#x2F;(<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h3><p>这题如果说是难题，那么难就难在理解埃氏筛这个算法和怎么实现，由于我之前刷算法的时候刷到过素数筛，所以了解过相关概念，这题对于我来说难度不大，就是处理细节得花挺多时间</p><p>相关资料：<a href="https://swtch.com/~rsc/thread/">埃氏筛</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span> <span class="hljs-comment">// 必须以这个顺序 include，由于三个头文件有依赖关系</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> pip[])</span>&#123;<br>    <span class="hljs-type">int</span> pi[<span class="hljs-number">2</span>];<br>    pipe(pi);<br>    <span class="hljs-keyword">if</span> (num==<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br><br>    <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        close(pi[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//关写进程</span><br>        close(pip[<span class="hljs-number">0</span>]);<br>        read(pi[<span class="hljs-number">0</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, tmp);<br>        dfs(tmp,pi);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        close(pi[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//关读进程</span><br>        <span class="hljs-keyword">while</span>(read(pip[<span class="hljs-number">0</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp))&amp;&amp;tmp!=<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span> (tmp%num!=<span class="hljs-number">0</span>)&#123;<br>                write(pi[<span class="hljs-number">1</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp));<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> end = <span class="hljs-number">-1</span>;      <span class="hljs-comment">//忘记补写了，一直在这里超时</span><br>        write(pi[<span class="hljs-number">1</span>],&amp;end,<span class="hljs-keyword">sizeof</span>(end));<br>        wait(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-type">int</span> pi[<span class="hljs-number">2</span>];<br>    pipe(pi);<br>    <span class="hljs-type">int</span> num =<span class="hljs-number">2</span> ;<br>    <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        close(pi[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//关写进程</span><br>        read(pi[<span class="hljs-number">0</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp));<br>        dfs(tmp,pi);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-number">3</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, num);<br>        close(pi[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">while</span>(tmp&lt;=<span class="hljs-number">35</span>)&#123;<br>            <span class="hljs-keyword">if</span>(tmp%num!=<span class="hljs-number">0</span>)&#123;<br>                write(pi[<span class="hljs-number">1</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp));<br>            &#125;<br>            tmp++;<br>        &#125;<br>        <span class="hljs-type">int</span> end = <span class="hljs-number">-1</span>;<br>        write(pi[<span class="hljs-number">1</span>],&amp;end,<span class="hljs-keyword">sizeof</span>(end));<br>    &#125;<br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这边的一个坑点就是管道 要注意关闭不需要用到的文件描述符，否则跑到 n &#x3D; 13 的时候就会爆掉，出现读到全是 0 的情况。</p><blockquote><p>这里的理由是，fork 会将父进程的所有文件描述符都复制到子进程里，而 xv6 每个进程能打开的文件描述符总数只有 16 个 （见 <code>defs.h</code> 中的 <code>NOFILE</code> 和 <code>proc.h</code> 中的 <code>struct file *ofile[NOFILE]; // Open files</code>）。</p><p>由于一个管道会同时打开一个输入文件和一个输出文件，所以<strong>一个管道就占用了 2 个文件描述符</strong>，并且复制的<strong>子进程还会复制父进程的描述符</strong>，于是跑到第六七层后，就会由于最末端的子进程出现 16 个文件描述符都被占满的情况，导致新管道创建失败。</p></blockquote><p>关闭不必要的管道即可，如文中代码所示</p><h3 id="find-moderate"><a href="#find-moderate" class="headerlink" title="find (moderate)"></a>find (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p></blockquote><p>hint让我们去看ls的源码，其实大部分代码都可以复用ls的代码，所以难度不大</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// find.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *target)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    <span class="hljs-keyword">if</span> ((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (st.type)<br>    &#123;<br>    <span class="hljs-keyword">case</span> T_FILE:<br>       <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(path + <span class="hljs-built_in">strlen</span>(path) - <span class="hljs-built_in">strlen</span>(target), target) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, path);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> T_DIR:<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">strcpy</span>(buf, path);<br>        p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>        *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            memmove(p, de.name, DIRSIZ);<br>            p[DIRSIZ] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf + <span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">2</span>, <span class="hljs-string">&quot;/.&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(buf + <span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">3</span>, <span class="hljs-string">&quot;/..&quot;</span>) != <span class="hljs-number">0</span>)<br>            &#123;<br>                find(buf, target); <span class="hljs-comment">// 递归查找</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    close(fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> target[<span class="hljs-number">512</span>];<br>    target[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;/&#x27;</span>; <span class="hljs-comment">// 为查找的文件名添加 / 在开头</span><br>    <span class="hljs-built_in">strcpy</span>(target + <span class="hljs-number">1</span>, argv[<span class="hljs-number">2</span>]);<br>    find(argv[<span class="hljs-number">1</span>], target);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="xargs-moderate"><a href="#xargs-moderate" class="headerlink" title="xargs (moderate)"></a>xargs (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p></blockquote><p>这题对于我来说一个是理解到位xargs的作用是什么，一个是c的语法和特性，比如在题解中使用了的大量的指针等等</p><p>xargs：将标准输入转换成命令行输入（让echo等命令可以接收到），然后还有其他的作用，比如说格式化输出等等 <a href="https://www.runoob.com/linux/linux-comm-xargs.html">Linux xargs 命令 | 菜鸟教程 (runoob.com)</a></p><p>之前一直没花太多时间在c语言上，可能对于我来说还是不太熟悉c的特性和操作系统的相关概念，写这题还是花了挺长时间的，最后这题还是参考了大佬的博客才吃透把这题过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// xargs.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(<span class="hljs-type">char</span> *program, <span class="hljs-type">char</span> **args)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">// child exec</span><br>        exec(program, args);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// parent return</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 读取所有的xargs的参数</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">2048</span>]; <span class="hljs-comment">// 缓冲read里读出来的字符拼接成字符串参数</span><br>    <span class="hljs-type">char</span> **argans;<br>    <span class="hljs-type">char</span> *argv2[<span class="hljs-number">128</span>]; <span class="hljs-comment">// 不能直接使用++移动指针</span><br>    argans = argv2;<br>    <span class="hljs-type">char</span> *start = buf;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++)<br>    &#123;<br>        *argans = argv[i];<br>        argans++;<br>    &#125;<br><br>    <span class="hljs-comment">// 读入参数</span><br>    <span class="hljs-type">char</span> *p = buf;<br>    <span class="hljs-type">char</span> **pa = argans; <span class="hljs-comment">// argans作为头部指针，重置到数组开头的时候用</span><br>    <span class="hljs-keyword">while</span> (read(<span class="hljs-number">0</span>, p, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (*p == <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-comment">// 说明是参数</span><br>        &#123;<br>            *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            *(pa++) = start;<br>            start = p + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (*p == <span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-comment">// 开始执行指令</span><br>        &#123;<br>            *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            *(pa++) = start;<br>            start = p + <span class="hljs-number">1</span>;<br>            *pa = <span class="hljs-number">0</span>;<br>            run(argv[<span class="hljs-number">1</span>], argv2);<br>            pa = argans; <span class="hljs-comment">// 重置</span><br>        &#125;<br>        p++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pa != argans)<br>    &#123; <span class="hljs-comment">// 如果最后一行不是空行</span><br>        <span class="hljs-comment">// 收尾最后一个参数</span><br>        *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        *(pa++) = start;<br>        <span class="hljs-comment">// 收尾最后一行</span><br>        *pa = <span class="hljs-number">0</span>; <span class="hljs-comment">// 参数列表末尾用 null 标识列表结束</span><br>        <span class="hljs-comment">// 执行最后一行指令</span><br>        run(argv[<span class="hljs-number">1</span>], argv2);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (wait(<span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>)<br>    &#123;<br>    &#125;; <span class="hljs-comment">// 循环等待所有子进程完成，每一次 wait(0) 等待一个</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230903095735393.png"></p><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>记录一下自己在做实验过程中的疑惑</p><p>trapframe : 发生trap时，用于保存当前进程如寄存器等状态</p></blockquote><p>lab2和lab1都是挺简单的，而且lab2的任务量和难度都比lab1小，留意lab给的提示就行</p><p>因为lab2的源码也丢失了，这里也没办法放代码了</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230903140502352.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/20230917104450.png"></p><p>务必注意指导书提示：</p><blockquote><p>Some hints:</p><ul><li>Add <code>$U/_trace</code> to UPROGS in Makefile</li><li>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</li><li>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</li><li>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</li><li>Modify the <code>syscall()</code> function in <code>kernel/syscall.c</code> to print the trace output. You will need to add an array of syscall names to index into.</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230903151705364.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/20230917104433.png"></p><h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><blockquote><p>Define a function called <code>vmprint()</code>. It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process’s page table. You receive full credit for this assignment if you pass the <code>pte printout</code> test of <code>make grade</code>.</p></blockquote><p>第一行打印传入vm的参数，我们把传进来的pagetable用%p打印一下就好了</p><blockquote><p>The root of the tree is a 4096-byte page-table page that contains 512 PTEs, which contain the physical addresses for page-table pages in the next level of the tree.Each of those pages contains 512 PTEs for the final level in the tree.</p></blockquote><p>接着遍历他的512个PTE，根据标志位判断是否有child，如果有的话就继续递归，这边可以通过depth参数来进行打印 .. 的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable,uint64 depth)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (depth&gt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(depth==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. ..&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>        <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>        <span class="hljs-keyword">if</span>((pte &amp; PTE_V) )&#123;<br>            <span class="hljs-keyword">if</span> (depth==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (depth==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. .. ..&quot;</span>);<br>            &#125;<br>            uint64 child = PTE2PA(pte);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: pte %p pa %p\n&quot;</span>,i,pagetable[i],child);<br>            <span class="hljs-keyword">if</span>( (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>)&#123;<br>                dfs((<span class="hljs-type">pagetable_t</span>)child,depth+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> ptb)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, ptb);<br>    dfs(ptb,<span class="hljs-number">0</span>);<br>&#125;s<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230904172005306.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230904172910125.png"></p><h3 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h3><blockquote><p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. Modify <code>struct proc</code> to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if <code>usertests</code> runs correctly.</p></blockquote><p>这题注意他给的hint，看着一步一步来，还是比较好做的，主要是题意好理解</p><blockquote><p>A PTE can only refer to a physical address that is aligned on a 4096-byte boundary (is a multiple of 4096), so freerange uses PGROUNDUP to ensure that it frees only aligned physical addresses. </p></blockquote><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230905163657350.png"></p><h3 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin/copyinstr</code></h3><blockquote><p>Replace the body of <code>copyin</code> in <code>kernel/vm.c</code> with a call to <code>copyin_new</code> (defined in <code>kernel/vmcopyin.c</code>); do the same for <code>copyinstr</code> and <code>copyinstr_new</code>. Add mappings for user addresses to each process’s kernel page table so that <code>copyin_new</code> and <code>copyinstr_new</code> work. You pass this assignment if <code>usertests</code> runs correctly and all the <code>make grade</code> tests pass.</p></blockquote><p>卡了有段时间，一开始题意理解到就去做，费了很大的精力，最后还是不得不回滚到一开始的版本（所以下次一定把他的题目意思是什么搞懂再去做，不然很容易理解错题意，浪费精力。。虽然但是花的时间也是去了解xv6的设计，也可以说不算浪费？）</p><blockquote><p> However, this scheme does limit the maximum size of a user process to be less than the kernel’s lowest virtual address. After the kernel has booted, that address is <code>0xC000000</code> in xv6, the address of the PLIC registers; see <code>kvminit()</code> in <code>kernel/vm.c</code>, <code>kernel/memlayout.h</code>, and Figure 3-4 in the text. You’ll need to modify xv6 to prevent user processes from growing larger than the PLIC address.</p></blockquote><p>copyin在用户进程使用，va !&#x3D; pa，copyin_new在kernel中使用，va &#x3D; pa。 理解到这个就非常简单了</p><p>详见下面，我们需要使用的是0到PLIC下面的地址</p><p>所以我们映射的时候不需要映射CLINT</p><p>接着根据hint提到的和内核页表相关的地方进行修改</p><p><img src="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p3.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230905204525549.png"></p><h2 id="lab4-Traps"><a href="#lab4-Traps" class="headerlink" title="lab4 Traps"></a>lab4 Traps</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><ul><li>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</li></ul><p>​     <strong>A:</strong>   a0-a7; a2;</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230906112130650.png"></p><ul><li>Where is the call to function f in the assembly code for main? Where is the call to g? <strong>(Hint: the compiler may inline functions.)</strong></li></ul><p><strong>A:</strong> 被内联到了main函数中</p><ul><li>At what address is the function <code>printf</code> located?</li></ul><p> <strong>A:</strong> 0x630</p><ul><li>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</li></ul><p><strong>A:</strong> 0x38</p><ul><li><blockquote><p>Run the following code.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">unsigned <span class="hljs-keyword">int</span> i = <span class="hljs-number">0x00646c72</span>;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, &amp;i);<br>     <br></code></pre></td></tr></table></figure><p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p></blockquote></li></ul><p>很简单，懒得复制代码跑了，</p><ul><li>In the following code, what is going to be printed after ‘y&#x3D;’? (note: the answer is not a specific value.) Why does this happen?</li></ul><p><strong>A:</strong>  随机的，取决于a2寄存器里的值</p><h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><blockquote><p>Implement a <code>backtrace()</code> function in <code>kernel/printf.c</code>. Insert a call to this function in <code>sys_sleep</code>, and then run bttest, which calls <code>sys_sleep</code>. Your output should be as follows:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">backtrace:</span><br><span class="hljs-number">0x0000000080002cda</span><br><span class="hljs-number">0x0000000080002bb6</span><br><span class="hljs-number">0x0000000080002898</span><br>  <br></code></pre></td></tr></table></figure><p>After <code>bttest</code> exit qemu. In your terminal: the addresses may be slightly different but if you run <code>addr2line -e kernel/kernel</code> (or <code>riscv64-unknown-elf-addr2line -e kernel/kernel</code>) and cut-and-paste the above addresses as follows:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">$ addr2line -e kernel/kernel<br><span class="hljs-number">0x0000000080002de2</span><br><span class="hljs-number">0x0000000080002f4a</span><br><span class="hljs-number">0x0000000080002bfc</span><br>Ctrl-D<br>  <br></code></pre></td></tr></table></figure><p>You should see something like this:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kernel</span>/sysproc.c:<span class="hljs-number">74</span><br><span class="hljs-attribute">kernel</span>/syscall.c:<span class="hljs-number">224</span><br><span class="hljs-attribute">kernel</span>/trap.c:<span class="hljs-number">85</span><br></code></pre></td></tr></table></figure></blockquote><p>这题注意一下</p><blockquote><ul><li>These <a href="https://pdos.csail.mit.edu/6.828/2020/lec/l-riscv-slides.pdf">lecture notes</a> have a picture of the layout of stack frames. Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.</li></ul></blockquote><p>这个就好了，easy题，没什么难度</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230906164256057.png"></p><h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><blockquote><p>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you’ll be implementing a primitive form of user-level interrupt&#x2F;fault handlers; you could use something similar to handle page faults in the application, for example. Your solution is correct if it passes alarmtest and usertests.</p></blockquote><p>这边调用传入的alarm函数是直接用程序计数器指向函数进行运行，然后通过sigreturn恢复</p><p>但是一开始尝试只恢复epc不行，还是会报错</p><p>原因是在函数调用的过程中也会对寄存器进行修改</p><p>所以得把整个都保存下来</p><p>因为c语言的基础确实差，最后用的笨方法，直接存储30多个寄存器的值，一开始也想着用一个struct trapframe *trapframe 这样的结构体指针的，发现直接赋值行不通，然后尝试初始化指针分配内存后还是报错不知道为什么，然后就直接把30多个寄存器都放到p里用于保存。</p><blockquote><p>后面了解到好像还得实现结构体的free才行，但我后面没去没尝试过</p></blockquote><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230907221659128.png"></p><h2 id="lab5-xv6-lazy-page-allocation"><a href="#lab5-xv6-lazy-page-allocation" class="headerlink" title="lab5 xv6 lazy page allocation"></a>lab5 xv6 lazy page allocation</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>One of the many neat tricks an O&#x2F;S can play with page table hardware is lazy allocation of user-space heap memory. Xv6 applications ask the kernel for heap memory using the sbrk() system call. In the kernel we’ve given you, sbrk() allocates physical memory and maps it into the process’s virtual address space. It can take a long time for a kernel to allocate and map memory for a large request. Consider, for example, that a gigabyte consists of 262,144 4096-byte pages; that’s a huge number of allocations even if each is individually cheap. In addition, some programs allocate more memory than they actually use (e.g., to implement sparse arrays), or allocate memory well in advance of use. To allow sbrk() to complete more quickly in these cases, sophisticated kernels allocate user memory lazily. That is, sbrk() doesn’t allocate physical memory, but just remembers which user addresses are allocated and marks those addresses as invalid in the user page table. When the process first tries to use any given page of lazily-allocated memory, the CPU generates a page fault, which the kernel handles by allocating physical memory, zeroing it, and mapping it. You’ll add this lazy allocation feature to xv6 in this lab.</p></blockquote><p>这次的lab比较简单，大概用时3-4小时做完了，没有hard题</p><h3 id="Eliminate-allocation-from-sbrk-easy"><a href="#Eliminate-allocation-from-sbrk-easy" class="headerlink" title="Eliminate allocation from sbrk() (easy)"></a>Eliminate allocation from sbrk() (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h3><blockquote><p>Your first task is to delete page allocation from the sbrk(n) system call implementation, which is the function sys_sbrk() in sysproc.c. The sbrk(n) system call grows the process’s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process’s size (myproc()-&gt;sz) by n and return the old size. It should not allocate memory – so you should delete the call to growproc() (but you still need to increase the process’s size!).</p></blockquote><p>纯概念，故跳过</p><p>因为这次lab的几个题都是有联系的，这题也是为了后面几题做铺垫</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">if</span> (n&lt;<span class="hljs-number">0</span>)&#123;<br>        uvmdealloc(myproc()-&gt;pagetable,myproc()-&gt;sz,myproc()-&gt;sz+n);<br>    &#125;<br>  myproc()-&gt;sz=myproc()-&gt;sz+n;<br><br><span class="hljs-comment">//  if(growproc(n) &lt; 0)</span><br><span class="hljs-comment">//    return -1;</span><br></code></pre></td></tr></table></figure><h3 id="Lazy-allocation-moderate"><a href="#Lazy-allocation-moderate" class="headerlink" title="Lazy allocation (moderate)"></a>Lazy allocation (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Modify the code in trap.c to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. You should add your code just before the <code>printf</code> call that produced the “usertrap(): …” message. Modify whatever other xv6 kernel code you need to in order to get <code>echo hi</code> to work.</p></blockquote><p>这题跟着hint走就行，为下一题做铺垫</p><blockquote><ul><li>You can check whether a fault is a page fault by seeing if r_scause() is 13 or 15 in usertrap().</li><li><code>r_stval()</code> returns the RISC-V <code>stval</code> register, which contains the virtual address that caused the page fault.</li><li>Steal code from uvmalloc() in vm.c, which is what sbrk() calls (via growproc()). You’ll need to call kalloc() and mappages().</li><li>Use PGROUNDDOWN(va) to round the faulting virtual address down to a page boundary.</li><li>uvmunmap() will panic; modify it to not panic if some pages aren’t mapped.</li><li>If the kernel crashes, look up sepc in kernel&#x2F;kernel.asm</li><li>Use your <code>vmprint</code> function from pgtbl lab to print the content of a page table.</li><li>If you see the error “incomplete type proc”, include “spinlock.h” then “proc.h”.</li></ul></blockquote><h3 id="Lazytests-and-Usertests-moderate"><a href="#Lazytests-and-Usertests-moderate" class="headerlink" title="Lazytests and Usertests (moderate)"></a>Lazytests and Usertests (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>We’ve supplied you with <code>lazytests</code>, an xv6 user program that tests some specific situations that may stress your lazy memory allocator. Modify your kernel code so that all of both <code>lazytests</code> and <code>usertests</code> pass.</p></blockquote><p>题目中提到的hint都要实现，我写到后面发现漏了read这几个系统调用也得修改，然后就是最后一个stack，我做了判断，但是没有else把kill设置为1杀掉进程，导致usertest过不去，卡在stack那个测试点不动，因为我一直认为我是if如果没进去那就会被杀掉，开始就没往这边想，后面回头一看才发现不得行。浪费我1个多小时的时间</p><blockquote><ul><li>Handle negative sbrk() arguments.</li><li>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</li><li>Handle the parent-to-child memory copy in fork() correctly.</li><li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</li><li>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</li><li>Handle faults on the invalid page below the user stack.</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span><br>usertests starting<br>test execout: OK<br>test copyin: OK<br>test copyout: OK<br>test copyinstr1: OK<br>test copyinstr2: OK<br>test copyinstr3: OK<br>test rwsbrk: OK<br>test truncate1: OK<br>test truncate2: OK<br>test truncate3: OK<br>test reparent2: OK<br>test pgbug: OK<br>test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3235<br>            sepc=0x0000000000005580 stval=0x0000000000005580<br>usertrap(): unexpected scause 0x000000000000000c pid=3236<br>            sepc=0x0000000000005580 stval=0x0000000000005580<br>OK<br>test badarg: OK<br>test reparent: OK<br>test twochildren: OK<br>test forkfork: OK<br>test forkforkfork: OK<br>test argptest: OK<br>test createdelete: OK<br>test linkunlink: OK<br>test linktest: OK<br>test unlinkread: OK<br>test concreate: OK<br>test subdir: OK<br>test fourfiles: OK<br>test sharedfd: OK<br>test exectest: OK<br>test bigargtest: OK<br>test bigwrite: OK<br>test bsstest: OK<br>test sbrkbasic: OK<br>test sbrkmuch: OK<br>test kernmem: OK<br>test sbrkfail: OK<br>test sbrkarg: OK<br>test validatetest: OK<br>test stacktest: OK<br>test opentest: OK<br>test writetest: OK<br>test writebig: OK<br>test createtest: OK<br>test openiput: OK<br>test exitiput: OK<br>test iput: OK<br>test mem: OK<br>test pipe1: OK<br>test preempt: kill... wait... OK<br>test exitwait: OK<br>test rmdot: OK<br>test fourteen: OK<br>test bigfile: OK<br>test dirfile: OK<br>test iref: OK<br>test forktest: OK<br>test bigdir: OK<br>ALL TESTS PASSED<br></code></pre></td></tr></table></figure><h2 id="lab6-Copy-on-Write-Fork-for-xv6"><a href="#lab6-Copy-on-Write-Fork-for-xv6" class="headerlink" title="lab6 Copy-on-Write Fork for xv6"></a>lab6 Copy-on-Write Fork for xv6</h2><blockquote><p>Virtual memory provides a level of indirection: the kernel can intercept memory references by marking PTEs invalid or read-only, leading to page faults, and can change what addresses mean by modifying PTEs. There is a saying in computer systems that any systems problem can be solved with a level of indirection. The lazy allocation lab provided one example. This lab explores another example: copy-on write fork.</p></blockquote><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><p>哎，啥也不多说了，题目做起来快，但是debug花的时间太多了（我太菜了QAQ）</p><p>第一个遇到的bug，也是我花了最多时间，并且目前还没get到为什么不行的地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">COW_alloc</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> ptl,uint64 va)</span>&#123;<br>    va = PGROUNDDOWN(va);<br>    <span class="hljs-type">pte_t</span> * pte;<br>    <span class="hljs-keyword">if</span>((pte=walk(ptl,va,<span class="hljs-number">0</span>))==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;judge_page_fault walk err\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    uint64 pa =   PA2PTE(*pte);<br>    <span class="hljs-comment">//重设flag</span><br>    *pte=*pte | PTE_W;<br>    *pte=*pte &amp; ~PTE_COW;<br>    <span class="hljs-type">int</span> flag =  PTE_FLAGS(*pte);<br><br>    <span class="hljs-comment">//分配内存</span><br>    uint64  mem = (uint64) kalloc();<br>    <span class="hljs-keyword">if</span>(mem==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;COW_alloc kalloc failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    memmove((<span class="hljs-type">char</span>*)mem,(<span class="hljs-type">char</span>* )pa,PGSIZE);<br>    <span class="hljs-comment">//解除映射关系</span><br>    uvmunmap(ptl,va,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//重新映射</span><br>    <span class="hljs-keyword">if</span>(mappages(ptl,va,PGSIZE,(uint64)mem,flag)&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;COW_alloc mappages failed\n&quot;</span>);<br>        kfree((<span class="hljs-type">void</span>*)mem);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cow</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va)</span> &#123;<br>    <span class="hljs-keyword">if</span> (va &gt;= MAXVA) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 找到va对应的pte</span><br>    <span class="hljs-type">pte_t</span>* pte = walk(pagetable, va, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pte == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*pte &amp; PTE_COW) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*pte &amp; PTE_U) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 物理地址</span><br>    uint64 pa = PTE2PA(*pte);<br>    uint64 ka = (uint64) kalloc();<br>    <span class="hljs-keyword">if</span> (ka == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 复制pa到ka</span><br>        memmove((<span class="hljs-type">char</span>*)ka, (<span class="hljs-type">char</span>*)pa, PGSIZE);<br>        uint64 flags = PTE_FLAGS(*pte);<br>        *pte = PA2PTE(ka) | flags | PTE_W;<br>        *pte &amp;= (~PTE_COW);<br>        <span class="hljs-comment">// 更新计数</span><br>        kfree((<span class="hljs-type">void</span> *)pa);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两段代码只有下面的可以跑通，上面的不行，但我自己看起来感觉没什么太大区别，上面的memmove通过不了，这是我最疑惑的地方，先插个眼，后面回过头来研究下</p><p>第二个就是锁，他的测试有几个是会上压力并发测试的，我在这里吃了个亏，读取的时候直接return了（QAQ）,所有的对COW引用数组的操作全要加锁，不然过不了usertests</p><p>最后是va大于MAXVA返回的位置，记得要放到walk前，不然最后会爆释放的页数对不上的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (va &gt;= MAXVA) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>差一个page对不上，改这里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span><br>&#123;<br>  <span class="hljs-type">char</span> *p;<br>  p = (<span class="hljs-type">char</span>*)PGROUNDUP((uint64)pa_start);<br>  <span class="hljs-keyword">for</span>(; p + PGSIZE &lt;= (<span class="hljs-type">char</span>*)pa_end; p += PGSIZE)&#123;<br>      COW_COUNT[((uint64)p)/<span class="hljs-number">4096</span>] = <span class="hljs-number">1</span>;    <br>      kfree(p);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230911111329196.png"></p><h2 id="lab7-Multithreading"><a href="#lab7-Multithreading" class="headerlink" title="lab7 Multithreading"></a>lab7 Multithreading</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>This lab will familiarize you with multithreading. You will implement switching between threads in a user-level threads package, use multiple threads to speed up a program, and implement a barrier.</p></blockquote><p>线程相关的两节课看的我有点心累，也许是这两天状态没有调整好，还是说课程本来就比较抽象？（应该是自己的原因吧，确实感觉这两天很累）</p><h3 id="Uthread-switching-between-threads-moderate"><a href="#Uthread-switching-between-threads-moderate" class="headerlink" title="Uthread: switching between threads (moderate)"></a>Uthread: switching between threads (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Your job is to come up with a plan to create threads and save&#x2F;restore registers to switch between threads, and implement that plan. When you’re done, <code>make grade</code> should say that your solution passes the <code>uthread</code> test.</p></blockquote><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230912212557518.png"></p><h3 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h3><blockquote><p>Why are there missing keys with 2 threads, but not with 1 thread? Identify a sequence of events with 2 threads that can lead to a key being missing. Submit your sequence with a short explanation in answers-thread.txt</p><p>To avoid this sequence of events, insert lock and unlock statements in <code>put</code> and <code>get</code> in <code>notxv6/ph.c</code> so that the number of keys missing is always 0 with two threads. The relevant pthread calls are:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pthread_mutex_t <span class="hljs-keyword">lock</span>;            // <span class="hljs-keyword">declare</span> a <span class="hljs-keyword">lock</span><br>pthread_mutex_init(&amp;<span class="hljs-keyword">lock</span>, <span class="hljs-keyword">NULL</span>); // initialize the <span class="hljs-keyword">lock</span><br>pthread_mutex_lock(&amp;<span class="hljs-keyword">lock</span>);       // acquire <span class="hljs-keyword">lock</span><br>pthread_mutex_lock(&amp;<span class="hljs-keyword">lock</span>);       // <span class="hljs-keyword">release</span> <span class="hljs-keyword">lock</span><br></code></pre></td></tr></table></figure><p>You’re done when <code>make grade</code> says that your code passes the <code>ph_safe</code> test, which requires zero missing keys with two threads. It’s OK at this point to fail the <code>ph_fast</code> test.</p></blockquote><p>这里是并发不安全的，所以我们先测试在这里加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">put_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *xa)</span><br>&#123;<br>  <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) (<span class="hljs-type">long</span>) xa; <span class="hljs-comment">// thread number</span><br>  <span class="hljs-type">int</span> b = NKEYS/nthread;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b; i++) &#123;<br>pthread_mutex_lock(&amp;lock);     <span class="hljs-comment">//here</span><br>    put(keys[b*n + i], n);<br>pthread_mutex_lock(&amp;lock);  <span class="hljs-comment">//here</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是可以通过安全测试的，但是速度上慢得多，原因是我们加锁粒度太大了，我们一次把整个哈希表都锁住了</p><p>所以我们需要去降低锁的粒度，锁住每一个桶，而不是整个表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span><br>&#123;<br>  <span class="hljs-type">int</span> i = key % NBUCKET;<br>    pthread_mutex_lock(&amp;lock[i]);<br>  <span class="hljs-comment">// is the key already present?</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (e = table[i]; e != <span class="hljs-number">0</span>; e = e-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;key == key)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(e)&#123;<br>    <span class="hljs-comment">// update the existing key.</span><br>    e-&gt;value = value;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// the new is new.</span><br>    insert(key, value, &amp;table[i], table[i]);<br>  &#125;<br>    pthread_mutex_unlock(&amp;lock[i]);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> entry*<br><span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span><br>&#123;<br>  <span class="hljs-type">int</span> i = key % NBUCKET;<br>    pthread_mutex_lock(&amp;lock[i]);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (e = table[i]; e != <span class="hljs-number">0</span>; e = e-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;key == key) <span class="hljs-keyword">break</span>;<br>  &#125;<br>    pthread_mutex_unlock(&amp;lock[i]);<br>  <span class="hljs-keyword">return</span> e;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">put_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *xa)</span><br>&#123;<br>  <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) (<span class="hljs-type">long</span>) xa; <span class="hljs-comment">// thread number</span><br>  <span class="hljs-type">int</span> b = NKEYS/nthread;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b; i++) &#123;<br><br>    put(keys[b*n + i], n);<br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-type">pthread_t</span> *tha;<br>  <span class="hljs-type">void</span> *value;<br>  <span class="hljs-type">double</span> t1, t0;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;NBUCKET;i++) &#123;<br>        pthread_mutex_init(&amp;lock[i],<span class="hljs-literal">NULL</span>);<br>    &#125;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s nthreads\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br>  nthread = atoi(argv[<span class="hljs-number">1</span>]);<br>  tha = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">pthread_t</span>) * nthread);<br>  srandom(<span class="hljs-number">0</span>);<br>  assert(NKEYS % nthread == <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NKEYS; i++) &#123;<br>    keys[i] = random();<br>  &#125;<br><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// first the puts</span><br>  <span class="hljs-comment">//</span><br>  t0 = now();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    assert(pthread_create(&amp;tha[i], <span class="hljs-literal">NULL</span>, put_thread, (<span class="hljs-type">void</span> *) (<span class="hljs-type">long</span>) i) == <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    assert(pthread_join(tha[i], &amp;value) == <span class="hljs-number">0</span>);<br>  &#125;<br>  t1 = now();<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d puts, %.3f seconds, %.0f puts/second\n&quot;</span>,<br>         NKEYS, t1 - t0, NKEYS / (t1 - t0));<br><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// now the gets</span><br>  <span class="hljs-comment">//</span><br>  t0 = now();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    assert(pthread_create(&amp;tha[i], <span class="hljs-literal">NULL</span>, get_thread, (<span class="hljs-type">void</span> *) (<span class="hljs-type">long</span>) i) == <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    assert(pthread_join(tha[i], &amp;value) == <span class="hljs-number">0</span>);<br>  &#125;<br>  t1 = now();<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d gets, %.3f seconds, %.0f gets/second\n&quot;</span>,<br>         NKEYS*nthread, t1 - t0, (NKEYS*nthread) / (t1 - t0));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Barrier-moderate"><a href="#Barrier-moderate" class="headerlink" title="Barrier(moderate)"></a>Barrier(moderate)</h3><blockquote><p>Your goal is to achieve the desired barrier behavior. In addition to the lock primitives that you have seen in the <code>ph</code> assignment, you will need the following new pthread primitives; look <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_wait.html">here</a> and <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_broadcast.html">here</a> for details.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">pthread<span class="hljs-constructor">_cond_wait(&amp;<span class="hljs-params">cond</span>, &amp;<span class="hljs-params">mutex</span>)</span>;  <span class="hljs-comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span><br>pthread<span class="hljs-constructor">_cond_broadcast(&amp;<span class="hljs-params">cond</span>)</span>;     <span class="hljs-comment">// wake up every thread sleeping on cond</span><br></code></pre></td></tr></table></figure><p>Make sure your solution passes <code>make grade</code>‘s <code>barrier</code> test.</p></blockquote><p>跟着他的提示来就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">barrier</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">// YOUR CODE HERE</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Block until all threads have called barrier() and</span><br>  <span class="hljs-comment">// then increment bstate.round.</span><br>  <span class="hljs-comment">//</span><br>    pthread_mutex_lock(&amp;bstate.barrier_mutex);<br>    bstate.nthread++;<br>    <span class="hljs-keyword">if</span>(bstate.nthread&lt;nthread)&#123;<br>        pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        bstate.nthread=<span class="hljs-number">0</span>;<br>        bstate.round++;<br>        pthread_cond_broadcast(&amp;bstate.barrier_cond);<br>    &#125;<br>    pthread_mutex_unlock(&amp;bstate.barrier_mutex);<br><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>怎么说呢，这次的实验还是挺简单的，全程3个小时多</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/20230917103802.png"></p><h2 id="Lab8-locks"><a href="#Lab8-locks" class="headerlink" title="Lab8: locks"></a>Lab8: locks</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>In this lab you’ll gain experience in re-designing code to increase parallelism. A common symptom of poor parallelism on multi-core machines is high lock contention. Improving parallelism often involves changing both data structures and locking strategies in order to reduce contention. You’ll do this for the xv6 memory allocator and block cache.</p></blockquote><h3 id="Memory-allocator-moderate"><a href="#Memory-allocator-moderate" class="headerlink" title="Memory allocator (moderate)"></a>Memory allocator (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Your job is to implement per-CPU freelists, and stealing when a CPU’s free list is empty. You must give all of your locks names that start with “kmem”. That is, you should call <code>initlock</code> for each of your locks, and pass a name that starts with “kmem”. Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run <code>usertests sbrkmuch</code>. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ. Make sure all tests in <code>usertests</code> pass. <code>make grade</code> should say that the kalloctests pass.</p></blockquote><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/20230917104314.png"></p><h3 id="Buffer-cache-hard"><a href="#Buffer-cache-hard" class="headerlink" title="Buffer cache (hard)"></a>Buffer cache (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h3><blockquote><p>Modify the block cache so that the number of <code>acquire</code> loop iterations for all locks in the bcache is close to zero when running <code>bcachetest</code>. Ideally the sum of the counts for all locks involved in the block cache should be zero, but it’s OK if the sum is less than 500. Modify <code>bget</code> and <code>brelse</code> so that concurrent lookups and releases for different blocks that are in the bcache are unlikely to conflict on locks (e.g., don’t all have to wait for <code>bcache.lock</code>). You must maintain the invariant that at most one copy of each block is cached. When you are done, your output should be similar to that shown below (though not identical). Make sure usertests still passes. <code>make grade</code> should pass all tests when you are done.</p></blockquote><p>锁竞争优化一般有几个思路：</p><ul><li>只在必须共享的时候共享（对应为将资源从 CPU 共享拆分为每个 CPU 独立）</li><li>必须共享时，尽量减少在关键区中停留的时间（对应“大锁化小锁”，降低锁的粒度）</li></ul><p>感觉挺有用的</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230913225009710.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span><br>usertests starting<br>test manywrites: OK<br>test execout: OK<br>test copyin: OK<br>test copyout: OK<br>test copyinstr1: OK<br>test copyinstr2: OK<br>test copyinstr3: OK<br>test rwsbrk: OK<br>test truncate1: OK<br>test truncate2: OK<br>test truncate3: OK<br>test reparent2: OK<br>test pgbug: OK<br>test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3243<br>            sepc=0x00000000000056a4 stval=0x00000000000056a4<br>usertrap(): unexpected scause 0x000000000000000c pid=3244<br>            sepc=0x00000000000056a4 stval=0x00000000000056a4<br>OK<br>test badarg: OK<br>test reparent: OK<br>test twochildren: OK<br>test forkfork: OK<br>test forkforkfork: OK<br>test argptest: OK<br>test createdelete: OK<br>test linkunlink: OK<br>test linktest: OK<br>test unlinkread: OK<br>test concreate: OK<br>test subdir: OK<br>test fourfiles: OK<br>test sharedfd: OK<br>test dirtest: OK<br>test exectest: OK<br>test bigargtest: OK<br>test bigwrite: OK<br>test bsstest: OK<br>test sbrkbasic: OK<br>test sbrkmuch: OK<br>test kernmem: usertrap(): unexpected scause 0x000000000000000d pid=6224<br>            sepc=0x000000000000215c stval=0x0000000080000000<br>usertrap(): unexpected scause 0x000000000000000d pid=6225<br>            sepc=0x000000000000215c stval=0x000000008000c350<br>usertrap(): unexpected scause 0x000000000000000d pid=6226<br>            sepc=0x000000000000215c stval=0x00000000800186a0<br>usertrap(): unexpected scause 0x000000000000000d pid=6227<br>            sepc=0x000000000000215c stval=0x00000000800249f0<br>usertrap(): unexpected scause 0x000000000000000d pid=6228<br>            sepc=0x000000000000215c stval=0x0000000080030d40<br>usertrap(): unexpected scause 0x000000000000000d pid=6229<br>            sepc=0x000000000000215c stval=0x000000008003d090<br>usertrap(): unexpected scause 0x000000000000000d pid=6230<br>            sepc=0x000000000000215c stval=0x00000000800493e0<br>usertrap(): unexpected scause 0x000000000000000d pid=6231<br>            sepc=0x000000000000215c stval=0x0000000080055730<br>usertrap(): unexpected scause 0x000000000000000d pid=6232<br>            sepc=0x000000000000215c stval=0x0000000080061a80<br>usertrap(): unexpected scause 0x000000000000000d pid=6233<br>            sepc=0x000000000000215c stval=0x000000008006ddd0<br>usertrap(): unexpected scause 0x000000000000000d pid=6234<br>            sepc=0x000000000000215c stval=0x000000008007a120<br>usertrap(): unexpected scause 0x000000000000000d pid=6235<br>            sepc=0x000000000000215c stval=0x0000000080086470<br>usertrap(): unexpected scause 0x000000000000000d pid=6236<br>            sepc=0x000000000000215c stval=0x00000000800927c0<br>usertrap(): unexpected scause 0x000000000000000d pid=6237<br>            sepc=0x000000000000215c stval=0x000000008009eb10<br>usertrap(): unexpected scause 0x000000000000000d pid=6238<br>            sepc=0x000000000000215c stval=0x00000000800aae60<br>usertrap(): unexpected scause 0x000000000000000d pid=6239<br>            sepc=0x000000000000215c stval=0x00000000800b71b0<br>usertrap(): unexpected scause 0x000000000000000d pid=6240<br>            sepc=0x000000000000215c stval=0x00000000800c3500<br>usertrap(): unexpected scause 0x000000000000000d pid=6241<br>            sepc=0x000000000000215c stval=0x00000000800cf850<br>usertrap(): unexpected scause 0x000000000000000d pid=6242<br>            sepc=0x000000000000215c stval=0x00000000800dbba0<br>usertrap(): unexpected scause 0x000000000000000d pid=6243<br>            sepc=0x000000000000215c stval=0x00000000800e7ef0<br>usertrap(): unexpected scause 0x000000000000000d pid=6244<br>            sepc=0x000000000000215c stval=0x00000000800f4240<br>usertrap(): unexpected scause 0x000000000000000d pid=6245<br>            sepc=0x000000000000215c stval=0x0000000080100590<br>usertrap(): unexpected scause 0x000000000000000d pid=6246<br>            sepc=0x000000000000215c stval=0x000000008010c8e0<br>usertrap(): unexpected scause 0x000000000000000d pid=6247<br>            sepc=0x000000000000215c stval=0x0000000080118c30<br>usertrap(): unexpected scause 0x000000000000000d pid=6248<br>            sepc=0x000000000000215c stval=0x0000000080124f80<br>usertrap(): unexpected scause 0x000000000000000d pid=6249<br>            sepc=0x000000000000215c stval=0x00000000801312d0<br>usertrap(): unexpected scause 0x000000000000000d pid=6250<br>            sepc=0x000000000000215c stval=0x000000008013d620<br>usertrap(): unexpected scause 0x000000000000000d pid=6251<br>            sepc=0x000000000000215c stval=0x0000000080149970<br>usertrap(): unexpected scause 0x000000000000000d pid=6252<br>            sepc=0x000000000000215c stval=0x0000000080155cc0<br>usertrap(): unexpected scause 0x000000000000000d pid=6253<br>            sepc=0x000000000000215c stval=0x0000000080162010<br>usertrap(): unexpected scause 0x000000000000000d pid=6254<br>            sepc=0x000000000000215c stval=0x000000008016e360<br>usertrap(): unexpected scause 0x000000000000000d pid=6255<br>            sepc=0x000000000000215c stval=0x000000008017a6b0<br>usertrap(): unexpected scause 0x000000000000000d pid=6256<br>            sepc=0x000000000000215c stval=0x0000000080186a00<br>usertrap(): unexpected scause 0x000000000000000d pid=6257<br>            sepc=0x000000000000215c stval=0x0000000080192d50<br>usertrap(): unexpected scause 0x000000000000000d pid=6258<br>            sepc=0x000000000000215c stval=0x000000008019f0a0<br>usertrap(): unexpected scause 0x000000000000000d pid=6259<br>            sepc=0x000000000000215c stval=0x00000000801ab3f0<br>usertrap(): unexpected scause 0x000000000000000d pid=6260<br>            sepc=0x000000000000215c stval=0x00000000801b7740<br>usertrap(): unexpected scause 0x000000000000000d pid=6261<br>            sepc=0x000000000000215c stval=0x00000000801c3a90<br>usertrap(): unexpected scause 0x000000000000000d pid=6262<br>            sepc=0x000000000000215c stval=0x00000000801cfde0<br>usertrap(): unexpected scause 0x000000000000000d pid=6263<br>            sepc=0x000000000000215c stval=0x00000000801dc130<br>OK<br>test sbrkfail: usertrap(): unexpected scause 0x000000000000000d pid=6275<br>            sepc=0x00000000000041fc stval=0x0000000000012000<br>OK<br>test sbrkarg: OK<br>test validatetest: OK<br>test stacktest: usertrap(): unexpected scause 0x000000000000000d pid=6279<br>            sepc=0x00000000000022cc stval=0x000000000000fb90<br>OK<br>test opentest: OK<br>test writetest: OK<br>test writebig: OK<br>test createtest: OK<br>test openiput: OK<br>test exitiput: OK<br>test iput: OK<br>test mem: OK<br>test pipe1: OK<br>test preempt: kill... wait... OK<br>test exitwait: OK<br>test rmdot: OK<br>test fourteen: OK<br>test bigfile: OK<br>test dirfile: OK<br>test iref: OK<br>test forktest: OK<br>test bigdir: OK<br>ALL TESTS PASSED<br></code></pre></td></tr></table></figure><p>这里有个坑点折腾了很久</p><p>如果你make qemu后不make clean，那么你会发现你在xv6终端里可以通过bcachetest，但是退出后make grade 会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">== Test   bcachetest: test0 == <br>  bcachetest: test0: FAIL <br>    ...<br>         tot= 3280<br>         test0: FAIL<br>         start test1<br>         test1 OK<br>         $ qemu-system-riscv64: terminating on signal 15 from pid 9889 (make)<br>    MISSING &#x27;^test0: OK$&#x27;<br></code></pre></td></tr></table></figure><p>所以make grade的时候记得先make clean QAQ</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230914090136982.png"></p><h2 id="Lab9-file-system"><a href="#Lab9-file-system" class="headerlink" title="Lab9: file system"></a>Lab9: file system</h2><p>（从此题开始持续优化blog的创作流，目前还没有形成一个属于自己的创作体系）</p><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>Before writing code, you should read “Chapter 8: File system” from the <a href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a> and study the corresponding code.</p></blockquote><h3 id="Large-files-moderate"><a href="#Large-files-moderate" class="headerlink" title="Large files (moderate)"></a>Large files (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Modify <code>bmap()</code> so that it implements a doubly-indirect block, in addition to direct blocks and a singly-indirect block. You’ll have to have only 11 direct blocks, rather than 12, to make room for your new doubly-indirect block; you’re not allowed to change the size of an on-disk inode. The first 11 elements of <code>ip-&gt;addrs[]</code> should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block. You are done with this exercise when <code>bigfile</code> writes 65803 blocks and <code>usertests</code> runs successfully:</p></blockquote><p>第一个要你实现二级链接块，我一开始没理解到题目意思，理解了二级链接块的概念后，这题就很快了</p><p>他是每一个bn对应一个块</p><p>也就是说如果是直接块，那么久可以直接读取 0–10块</p><p>如果是间接块，一级间接块在11块</p><p>二级间接块在12块</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230915074742194.png"></p><p>对于1级间接块，代码中已经给出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//如果大于等于11，说明是一级间接块</span><br>   bn -= NDIRECT;<br>   <span class="hljs-keyword">if</span> (bn &lt; NINDIRECT) &#123;<br>       <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>       <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>           ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>       bp = bread(ip-&gt;dev, addr);   <span class="hljs-comment">//文件载入</span><br>       a = (uint *) bp-&gt;data;<br>       <span class="hljs-keyword">if</span> ((addr = a[bn]) == <span class="hljs-number">0</span>) &#123;<br>           a[bn] = addr = balloc(ip-&gt;dev);<br>           log_write(bp);<br>       &#125;<br>       brelse(bp);<br>       <span class="hljs-keyword">return</span> addr;<br>   &#125;<br></code></pre></td></tr></table></figure><p>二级间接块 ，之前看到一个csdn讲二级链接块概念的blog，里面有章图很形象，但没找到，这边就手动绘制一下（有点丑，见谅QAQ）</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230915075928178.png"></p><p>由图可知，我们需要先从块缓存中载入一级索引表，用bn&#x2F;NINDIRECT找到所在的二级索引表的index，最后载入对应的二级索引表，根据bn%NINDIRECT,可以确定实际块的位置，总之理解到了的话就是复制粘贴一级索引块的处理方式，让他多载入几次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">bmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint bn)</span> &#123;<br>    uint addr, *a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>    <span class="hljs-keyword">if</span> (bn &lt; NDIRECT) &#123;  <span class="hljs-comment">// 如果bn是小于11的， 处理直接块</span><br>        <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>            ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>        <span class="hljs-keyword">return</span> addr;<br>    &#125;<br>    <span class="hljs-comment">//如果大于等于11，说明是一级间接块</span><br>    bn -= NDIRECT;<br>    <span class="hljs-keyword">if</span> (bn &lt; NINDIRECT) &#123;<br>        <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>        <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>            ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>        bp = bread(ip-&gt;dev, addr);   <span class="hljs-comment">//文件载入</span><br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">if</span> ((addr = a[bn]) == <span class="hljs-number">0</span>) &#123;<br>            a[bn] = addr = balloc(ip-&gt;dev);<br>            log_write(bp);<br>        &#125;<br>        brelse(bp);<br>        <span class="hljs-keyword">return</span> addr;<br>    &#125;<br>    bn -= NINDIRECT;     <span class="hljs-comment">//剪前11块，和一级间接地址的256块减掉，就是2级间接块的地址</span><br><br>    <span class="hljs-keyword">if</span> (bn &lt; NINDIRECT * NINDIRECT) &#123;<br>        <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>        <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>)<br>            ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>] = addr = balloc(ip-&gt;dev);<br>        bp = bread(ip-&gt;dev, addr);   <span class="hljs-comment">//文件载入   256个2级索引表载入</span><br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">if</span> ((addr = a[bn / NINDIRECT]) == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//最终指向的索引块载入</span><br>            a[bn / NINDIRECT] = addr = balloc(ip-&gt;dev);<br>            log_write(bp);<br>        &#125;<br>        brelse(bp);<br>        <span class="hljs-comment">//块中对应的地址载入</span><br>        <span class="hljs-type">int</span> index = bn % NINDIRECT; <span class="hljs-comment">//确定在块中的位置</span><br>        bp = bread(ip-&gt;dev, addr);   <span class="hljs-comment">//文件载入   256个2级索引表载入</span><br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">if</span> ((addr = a[index]) == <span class="hljs-number">0</span>) &#123;<br>            a[index] = addr = balloc(ip-&gt;dev);<br>            log_write(bp);<br>        &#125;<br>        brelse(bp);<br>        <span class="hljs-keyword">return</span> addr;<br>    &#125;<br><br>    panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>理解到位后，释放也是差不多的原理，也可以说是可以复制粘贴吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Truncate inode (discard contents).</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">itrunc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span> &#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span> ,*<span class="hljs-title">bp1</span>;</span><br>    uint *a, *b;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NDIRECT; i++) &#123;  <span class="hljs-comment">// direct blocks</span><br>        <span class="hljs-keyword">if</span> (ip-&gt;addrs[i]) &#123;<br>            bfree(ip-&gt;dev, ip-&gt;addrs[i]);<br>            ip-&gt;addrs[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ip-&gt;addrs[NDIRECT]) &#123;   <span class="hljs-comment">//indirect block</span><br>        bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[j])<br>                bfree(ip-&gt;dev, a[j]);<br>        &#125;<br>        brelse(bp);<br>        bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>        ip-&gt;addrs[NDIRECT] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]) &#123;   <span class="hljs-comment">// second indirect block</span><br>        bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]);<br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++) &#123;<br>            <span class="hljs-keyword">if</span>(a[j])&#123;<br>                bp1 = bread(ip-&gt;dev, a[j]);<br>                b = (uint *) bp1-&gt;data;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; NINDIRECT; ++k) &#123;<br>                    <span class="hljs-keyword">if</span> (b[k])<br>                        bfree(ip-&gt;dev, b[k]);<br>                &#125;<br>                brelse(bp1);<br>                bfree(ip-&gt;dev, a[j]);<br>            &#125;<br>        &#125;<br>        brelse(bp);<br>        bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]);<br>        ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    ip-&gt;size = <span class="hljs-number">0</span>;<br>    iupdate(ip);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230914211707841.png"></p><h3 id="Symbolic-links-moderate"><a href="#Symbolic-links-moderate" class="headerlink" title="Symbolic links (moderate)"></a>Symbolic links (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>You will implement the <code>symlink(char *target, char *path)</code> system call, which creates a new symbolic link at path that refers to file named by target. For further information, see the man page symlink. To test, add symlinktest to the Makefile and run it. Your solution is complete when the tests produce the following output (including usertests succeeding).</p></blockquote><p>这题比较简单，当时也比较晚了快11点图书馆闭馆了，我就直接看大佬的博客了，理解到了概念就很简单</p><p>理解可以参考这篇文章 <a href="https://blog.csdn.net/Csw_PHPer/article/details/106684375">https://blog.csdn.net/Csw_PHPer/article/details/106684375</a></p><p>个人感觉把软链接讲的很清楚了</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230914225252339.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230915103108823.png"></p><h2 id="Lab10-mmap-hard"><a href="#Lab10-mmap-hard" class="headerlink" title="Lab10: mmap (hard)"></a>Lab10: mmap (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h2><blockquote><p>You should implement enough <code>mmap</code> and <code>munmap</code> functionality to make the <code>mmaptest</code> test program work. If <code>mmaptest</code> doesn’t use a <code>mmap</code> feature, you don’t need to implement that feature.</p></blockquote><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><p>9.17  mit6.s081就算是正式完结了，network要看很多手册，而且我看了下其他做完了的博客也并不是很难，这里就先不做了</p><p>然后mmap还是有难度的，花了我大概10个小时左右的时间吧（虽然在前一天花了一晚上调bug，太菜了QAQ)</p><p>先是sys_mmap的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">sys_mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr, sz, offset;<br>    <span class="hljs-type">int</span> prot, flags, fd; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>    uint64 end  =  TRAPFRAME;<br>    <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;sz) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;prot) &lt; <span class="hljs-number">0</span><br>       || argint(<span class="hljs-number">3</span>, &amp;flags) &lt; <span class="hljs-number">0</span> || argfd(<span class="hljs-number">4</span>, &amp;fd, &amp;f) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">5</span>, &amp;offset) &lt; <span class="hljs-number">0</span> || sz == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span>(!f-&gt;writable &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; (flags == MAP_SHARED))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; VMASIZE; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">0</span>)<br>        &#123;<br>            j=i;<br>            p-&gt;vmas[i].valid = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// important!</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            end = PGROUNDDOWN(p-&gt;vmas[i].vastart);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span>* <span class="hljs-title">v</span> =</span> &amp;p-&gt;vmas[j];<br>    sz = PGROUNDUP(sz);     <span class="hljs-comment">//注意对齐</span><br><br><br>    v-&gt;vastart = end - sz;<br>    v-&gt;sz = sz;<br>    v-&gt;prot = prot;<br>    v-&gt;flags = flags;<br>    v-&gt;f = f;<br>    v-&gt;offset = offset;<br><br>    filedup(v-&gt;f);<br><br>    <span class="hljs-keyword">return</span> v-&gt;vastart;<br>&#125;<br></code></pre></td></tr></table></figure><p>前一天晚上调了很久就是因为有些细节没处理好</p><p>这里一定要  end &#x3D; PGROUNDDOWN(p-&gt;vmas[i].vastart)，因为test中所有的mmap的addr都是从0开始的，一定要记得更新end，不然test mmap two files 会过不去</p><p>加了更新end的分支后一定要记得加break，不然第二个就过不去了（全部vma都被设置成了1在第一个测试点中）</p><p>最后不要忘了sz &#x3D; PGROUNDUP(sz); 内存对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">0</span>)<br>      &#123;<br>          j=i;<br>          p-&gt;vmas[i].valid = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// important!</span><br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          end = PGROUNDDOWN(p-&gt;vmas[i].vastart);<br>      &#125;<br></code></pre></td></tr></table></figure><p>因为是lazy allocation，所以要在usertrap中进行修改处理page fault，这个和之前做过的实验差不多，这里就不多讲了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);<br><br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),</span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.</span><br>  w_stvec((uint64)kernelvec);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <br>  <span class="hljs-comment">// save user program counter.</span><br>  p-&gt;trapframe-&gt;epc = r_sepc();<br>  <br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br><br>    <span class="hljs-keyword">if</span>(p-&gt;killed)<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// sepc points to the ecall instruction,</span><br>    <span class="hljs-comment">// but we want to return to the next instruction.</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,</span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.</span><br>    intr_on();<br><br>    syscall();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span>  (r_scause()==<span class="hljs-number">13</span>||r_scause()==<span class="hljs-number">15</span>)&#123;<br>          uint64 va = r_stval();<br>          <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span>* <span class="hljs-title">v</span> =</span> <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; VMASIZE; ++i) &#123;<br>              <span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; va &gt;= p-&gt;vmas[i].vastart &amp;&amp; va &lt; p-&gt;vmas[i].vastart + p-&gt;vmas[i].sz) &#123;<br>                 v=&amp;p-&gt;vmas[i];<br>              &#125;<br>          &#125;<br><br>          <span class="hljs-keyword">if</span>(v==<span class="hljs-number">0</span>)&#123;<br>              p-&gt;killed=<span class="hljs-number">1</span>;<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>              <span class="hljs-type">void</span> *pa = kalloc();<br>              <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>) &#123;<br>                  panic(<span class="hljs-string">&quot;vmalazytouch: kalloc&quot;</span>);<br>              &#125;<br>              <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">0</span>, PGSIZE);<br>              begin_op();<br>              ilock(v-&gt;f-&gt;ip);<br>              readi(v-&gt;f-&gt;ip, <span class="hljs-number">0</span>, (uint64)pa, v-&gt;offset + PGROUNDDOWN(va - v-&gt;vastart), PGSIZE);<br>              iunlock(v-&gt;f-&gt;ip);<br>              end_op();<br><br>              <span class="hljs-type">int</span> perm = PTE_U;<br>              <span class="hljs-keyword">if</span>(v-&gt;prot &amp; PROT_READ)<br>                  perm |= PTE_R;<br>              <span class="hljs-keyword">if</span>(v-&gt;prot &amp; PROT_WRITE)<br>                  perm |= PTE_W;<br>              <span class="hljs-keyword">if</span>(v-&gt;prot &amp; PROT_EXEC)<br>                  perm |= PTE_X;<br><br>              <span class="hljs-keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, (uint64)pa, perm) &lt; <span class="hljs-number">0</span>) &#123;<br>                  panic(<span class="hljs-string">&quot;vmalazytouch: mappages&quot;</span>);<br>              &#125;<br><br>          &#125;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>          p-&gt;killed = <span class="hljs-number">1</span>;<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(p-&gt;killed)<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    yield();<br><br>  usertrapret();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是munmap ，这里为了方便，就直接使用页为单位来进行解除映射（可以直接使用uvmmap，偷个懒），如果sz为0了记得取消引用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">sys_munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr, sz;<br><br>    <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;sz) &lt; <span class="hljs-number">0</span> || sz == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span>* <span class="hljs-title">v</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; VMASIZE; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; addr &gt;= p-&gt;vmas[i].vastart &amp;&amp; addr &lt; p-&gt;vmas[i].vastart + p-&gt;vmas[i].sz) &#123;<br>            v=&amp;p-&gt;vmas[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(v == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(v-&gt;flags &amp; MAP_SHARED)&#123;<br>        filewrite(v-&gt;f, addr, sz);<br>    &#125;<br><br>    uvmunmap(p-&gt;pagetable, addr, PGROUNDUP(sz) / PGSIZE, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(addr == v-&gt;vastart)&#123;<br>       v-&gt;vastart += PGROUNDUP(sz);<br>    &#125;<br>    v-&gt;sz -= sz;<br>    <span class="hljs-keyword">if</span>(v-&gt;sz == <span class="hljs-number">0</span>)<br>    &#123;<br>        fileclose(v-&gt;f);<br>        <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)v, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(v));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>到此就已经可以通过mmap_test了</p><p>最后对fork和exit进行简单修改即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  np-&gt;parent = p;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; VMASIZE; i++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">v</span> =</span> &amp;p-&gt;vmas[i];<br>        <span class="hljs-keyword">if</span>(v-&gt;valid) &#123;<br>            np-&gt;vmas[i] = *v;<br>            filedup(v-&gt;f);<br>        &#125;<br>    &#125;<br><br><br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  np-&gt;state = RUNNABLE;<br><br>  release(&amp;np-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span>(p == initproc)<br>    panic(<span class="hljs-string">&quot;init exiting&quot;</span>);<br><br>  <span class="hljs-comment">// Close all open files.</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>; fd &lt; NOFILE; fd++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[fd])&#123;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span> =</span> p-&gt;ofile[fd];<br>      fileclose(f);<br>      p-&gt;ofile[fd] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; VMASIZE; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">1</span>)<br>        &#123;<br>            uint64 sz = p-&gt;vmas[i].sz;<br>            fileclose(p-&gt;vmas[i].f);<br>            <span class="hljs-comment">// 取消映射</span><br>            uvmunmap(p-&gt;pagetable, p-&gt;vmas[i].vastart, PGROUNDUP(sz) / PGSIZE, <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 清空vma</span><br>            <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)&amp;p-&gt;vmas[i], <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;vmas[i]));<br><br>        &#125;<br>    &#125;<br><br><br> ......<br>&#125;<br></code></pre></td></tr></table></figure><p>在make grade的时候可能会遇到env: python3\r: No such file or directory 的问题</p><p>vim打开 lab-mmap脚本,输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">:set ff=unix<br>:wq!<br></code></pre></td></tr></table></figure><p>即可解决问题   <a href="https://code84.com/79.html">env: python3\r</a></p><p>通过测试如下图</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230917083149756.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230917085710821.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大概花了两个星期吧做完lab0-lab10 ，个人感觉印象深刻是lab3，lab8，和lab10吧，lab8最后一个实验我是看着大佬的博客来写的，确实水平还不够</p><p>在这个实验的后半部分开始慢慢优化我的blog写作，还是希望自己的blog能够有能帮助大家的东西，慢慢来吧</p><p>个人感觉还是很有收获的，但是感觉对于学习os来说还远远不够，比如说作为教学os的xv6一个进程只有一个线程等等，很多地方都简化了</p><p>但作为一门导论课来说还是非常有含金量的，整顿一下明天开二周目了</p><p>有机会我想开一个读论文的坑了，后面有时间再说吧 </p><p>到这里就完结了，下个坑再见， bye ~</p>]]></content>
    
    
    <categories>
      
      <category>Lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs144-lab0~lab7</title>
    <link href="/2023/08/12/cs144-lab0-lab7/"/>
    <url>/2023/08/12/cs144-lab0-lab7/</url>
    
    <content type="html"><![CDATA[<p>lab0-lab5 code：<a href="https://github.com/MadFrey/minnow">MadFrey&#x2F;minnow (github.com)</a></p><p>lab6和lab7自行测试</p><p>历时大概两个星期，八月中旬到八月底，期间还有段时间没花在这上面</p><p>整体感觉下来lab1和lab3难度较高，其他的根据pdf的描述再加上自己去了解一下原理，都不难写</p><h2 id="lab-0"><a href="#lab-0" class="headerlink" title="lab 0"></a>lab 0</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@hecs-271160 ~]# telnet cs144.keithw.org http<br>Trying 104.196.238.229...<br>Connected to cs144.keithw.org.<br>Escape character is &#x27;^]&#x27;.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">telnet&gt; </span><span class="language-bash"></span><br><span class="language-bash">GET /hello HTTP/1.1</span><br>Host: cs144.keithw.org<br><br>HTTP/1.1 200 OK<br>Date: Sat, 12 Aug 2023 15:07:45 GMT<br>Server: Apache<br>Last-Modified: Thu, 13 Dec 2018 15:45:29 GMT<br>ETag: &quot;e-57ce93446cb64&quot;<br>Accept-Ranges: bytes<br>Content-Length: 14<br>Content-Type: text/plain<br><br>Hello, CS144!<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hecs-271160 ~]# telnet cs144.keithw.org http<br>Trying 104.196.238.229...<br>Connected to cs144.keithw.org.<br>Escape character is &#x27;^]&#x27;.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">telnet&gt; </span><span class="language-bash"></span><br><span class="language-bash">GET /lab0/MadFrey HTTP/1.1</span>    <br>Host: cs144.keithw.org<br><br>HTTP/1.1 200 OK<br>Date: Sat, 12 Aug 2023 15:13:12 GMT<br>Server: Apache<br>X-You-Said-Your-SunetID-Was: MadFrey<br>X-Your-Code-Is: 794944<br>Content-length: 111<br>Vary: Accept-Encoding<br>Content-Type: text/plain<br><br>Hello! You told us that your SUNet ID was &quot;MadFrey&quot;. Please see the HTTP headers (above) for your secret code.<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hecs-271160 etc]# telnet localhost 9090<br>Trying ::1...<br>telnet: connect to address ::1: Connection refused<br>Trying 127.0.0.1...<br>Connected to localhost.<br>Escape character is &#x27;^]&#x27;.<br>11111<br>3243435<br>MadFrey <br>^CConnection closed by foreign host.<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hecs-271160 netcat-0.7.1]# netcat -u 127.0.0.1 8004<br>^C[root@hecs-271160 netcat-0.7.1]# netcat -v -l -p 9090<br>Connection from 127.0.0.1:34572<br>11111<br>3243435<br>MadFrey<br>Exiting.<br>[root@hecs-271160 netcat-0.7.1]# <br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">( <span class="hljs-type">const</span> string&amp; host, <span class="hljs-type">const</span> string&amp; path )</span></span><br><span class="hljs-function"></span>&#123;<br>  TCPSocket socket;<br>  socket.<span class="hljs-built_in">connect</span>( <span class="hljs-built_in">Address</span>( host, <span class="hljs-string">&quot;http&quot;</span> ) );<br>  socket.<span class="hljs-built_in">write</span>( <span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\nHost: &quot;</span> + host + <span class="hljs-string">&quot;\r\nConnection: close\r\n\r\n&quot;</span> );<br><br>  <span class="hljs-keyword">while</span> ( !socket.<span class="hljs-built_in">eof</span>() ) &#123;<br>    std::string buffers;<br>    socket.<span class="hljs-built_in">read</span>( buffers );<br>    cout &lt;&lt; buffers;<br>  &#125;<br>  socket.<span class="hljs-built_in">close</span>();<br>  cerr &lt;&lt; <span class="hljs-string">&quot;Function called: get_URL(&quot;</span> &lt;&lt; host &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>  cerr &lt;&lt; <span class="hljs-string">&quot;Warning: get_URL() has not been implemented yet.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230901135240852.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230817174534608.png" alt="img"></p><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p>自己先用优先队列写了一遍，发现代码过于复杂，并且时间复杂度太高了，测试点超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;reassembler.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reassembler::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> closed_ &amp;&amp; <span class="hljs-built_in">bytes_pending</span>() == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reassembler::insert</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> first_index, string data, <span class="hljs-type">bool</span> is_last_substring, Writer&amp; output )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// Your code here.</span><br>  <span class="hljs-keyword">if</span> ( is_last_substring ) &#123;<br>    closed_ = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// important!</span><br>  <span class="hljs-keyword">if</span> ( first_index &gt;= unassembled_index + output.<span class="hljs-built_in">available_capacity</span>() || <span class="hljs-comment">/* Out of bound */</span><br>       first_index + data.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> &lt; unassembled_index ||            <span class="hljs-comment">/* Data have been transferred */</span><br>       data.<span class="hljs-built_in">empty</span>() || output.<span class="hljs-built_in">available_capacity</span>() == <span class="hljs-number">0</span> ) &#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">is_closed</span>() ) &#123;<br>      output.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ( first_index &lt; unassembled_index ) &#123;<br>    <span class="hljs-comment">// overlap</span><br>    <span class="hljs-keyword">if</span> ( first_index + data.<span class="hljs-built_in">size</span>() &gt; unassembled_index ) &#123;<br>      <span class="hljs-comment">// overlap</span><br>      <span class="hljs-type">size_t</span> overlap = unassembled_index - first_index;<br>      <span class="hljs-type">size_t</span> new_data_size = data.<span class="hljs-built_in">size</span>() - overlap;<br>      string new_data = data.<span class="hljs-built_in">substr</span>( overlap, new_data_size );<br>      output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>( new_data );<br>      unassembled_index += new_data_size;<br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( first_index == unassembled_index ) &#123;<br>    <span class="hljs-comment">// no overlap, 要进行cap比较</span><br>    <span class="hljs-type">uint64_t</span> cap = output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-keyword">if</span> ( data.<span class="hljs-built_in">size</span>() &gt; cap ) &#123;<br>      <span class="hljs-comment">// cap不够</span><br>      <span class="hljs-type">size_t</span> new_data_size = cap;<br>      string new_data = data.<span class="hljs-built_in">substr</span>( <span class="hljs-number">0</span>, new_data_size );<br>      output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>( new_data );<br>      unassembled_index += new_data_size;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// cap够</span><br>      output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>( data );<br>      unassembled_index += data.<span class="hljs-built_in">size</span>();<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 使用priority queue来存储碎片</span><br>    <span class="hljs-keyword">if</span> ( q.<span class="hljs-built_in">empty</span>() ) &#123;<br>      q.<span class="hljs-built_in">push</span>( <span class="hljs-built_in">make_pair</span>( first_index, data ) );<br>      unassembled_bytes_ += data.<span class="hljs-built_in">size</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        &#125;<br><br>    <span class="hljs-keyword">while</span> ( !q.<span class="hljs-built_in">empty</span>() ) &#123;<br>      <span class="hljs-type">uint64_t</span> new_index = q.<span class="hljs-built_in">top</span>().first;<br>      std::string new_data = q.<span class="hljs-built_in">top</span>().second;<br>      q.<span class="hljs-built_in">pop</span>();<br>      unassembled_bytes_ -= new_data.<span class="hljs-built_in">size</span>();<br>      <span class="hljs-keyword">if</span> ( q.<span class="hljs-built_in">empty</span>() ) &#123;<br>        q.<span class="hljs-built_in">push</span>( <span class="hljs-built_in">make_pair</span>( new_index, new_data ) );<br>        unassembled_bytes_ += new_data.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">uint64_t</span> new_index2 = q.<span class="hljs-built_in">top</span>().first;<br>        std::string new_data2 = q.<span class="hljs-built_in">top</span>().second;<br>        <span class="hljs-keyword">if</span> ( new_index &lt;= new_index2 ) &#123;<br>          <span class="hljs-type">size_t</span> overlap = new_index + new_data.<span class="hljs-built_in">size</span>() - new_index2;<br>          <span class="hljs-keyword">if</span> ( overlap &gt;= new_data.<span class="hljs-built_in">size</span>() ) &#123;<br>            q.<span class="hljs-built_in">pop</span>();<br>            unassembled_bytes_ -= new_data2.<span class="hljs-built_in">size</span>();<br>            q.<span class="hljs-built_in">push</span>( <span class="hljs-built_in">make_pair</span>( new_index, new_data ) );<br>            unassembled_bytes_ += new_data.<span class="hljs-built_in">size</span>();<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// overlap</span><br>            std::string substr = new_data.<span class="hljs-built_in">substr</span>( <span class="hljs-number">0</span>, new_index2 - new_index )<br>                                 + new_data2.<span class="hljs-built_in">substr</span>( overlap, new_data2.<span class="hljs-built_in">size</span>() - overlap );<br>            q.<span class="hljs-built_in">pop</span>();<br>            unassembled_bytes_ -= new_data2.<span class="hljs-built_in">size</span>();<br>            q.<span class="hljs-built_in">push</span>( <span class="hljs-built_in">make_pair</span>( first_index, substr ) );<br>            unassembled_bytes_ += substr.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 循环</span><br>  <span class="hljs-keyword">while</span> ( !q.<span class="hljs-built_in">empty</span>() ) &#123;<br>    <span class="hljs-type">uint64_t</span> new_index = q.<span class="hljs-built_in">top</span>().first;<br>    std::string new_data = q.<span class="hljs-built_in">top</span>().second;<br>    <span class="hljs-type">uint64_t</span> cap = output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-keyword">if</span> ( new_index &lt;= unassembled_index ) &#123;<br>      <span class="hljs-comment">// overlap</span><br>      <span class="hljs-keyword">if</span> ( new_index + new_data.<span class="hljs-built_in">size</span>() &gt; unassembled_index ) &#123;<br>        <span class="hljs-comment">// overlap</span><br>        <span class="hljs-type">size_t</span> overlap = unassembled_index - new_index;<br>        <span class="hljs-type">size_t</span> new_data_size = <span class="hljs-built_in">min</span>( new_data.<span class="hljs-built_in">size</span>() - overlap, cap );<br>        string new_data_2 = new_data.<span class="hljs-built_in">substr</span>( overlap, new_data_size );<br>        output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>( new_data_2 );<br>        unassembled_index += new_data_size;<br>        unassembled_bytes_ -= data.<span class="hljs-built_in">size</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// no overlap</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        unassembled_bytes_ -= new_data.<span class="hljs-built_in">size</span>();<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( new_index &gt; unassembled_index ) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">is_closed</span>() ) &#123; <span class="hljs-comment">// important!</span><br>    output.<span class="hljs-built_in">close</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reassembler::bytes_pending</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// Your code here.</span><br>  <span class="hljs-keyword">return</span> unassembled_bytes_;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>改用map后第14个测试点超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;reassembler.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reassembler::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> closed_ &amp;&amp; <span class="hljs-built_in">bytes_pending</span>() == <span class="hljs-number">0</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reassembler::insert</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> first_index, string data, <span class="hljs-type">bool</span> is_last_substring, Writer &amp;output)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (is_last_substring) &#123;<br>        closed_ = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Remember index_ points to where the current byte located at.</span><br>    <span class="hljs-comment">// 1. Unacceptable index: first_index overwhelms the capability range.</span><br>    <span class="hljs-comment">// 2. All overlapped: The end index of the substring is smaller than current index_.</span><br>    <span class="hljs-comment">// 3. data is empty.</span><br>    <span class="hljs-comment">// 4. No available space.</span><br>    <span class="hljs-keyword">if</span> (first_index &gt;= unassembled_index_ + output.<span class="hljs-built_in">available_capacity</span>() || <span class="hljs-comment">/* Out of bound */</span><br>        first_index + data.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> &lt; unassembled_index_ ||            <span class="hljs-comment">/* Data have been transferred */</span><br>        data.<span class="hljs-built_in">empty</span>() || output.<span class="hljs-built_in">available_capacity</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_closed</span>()) &#123;<br>            output.<span class="hljs-built_in">close</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> cap = output.<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-comment">// new_index actually distinguish where the current data start, the start index</span><br>    <span class="hljs-type">uint64_t</span> new_index = first_index;<br><br>    <span class="hljs-comment">// Data needs to fit the capability limitation</span><br>    <span class="hljs-keyword">if</span> (first_index &lt;= unassembled_index_) &#123;<br>        new_index = unassembled_index_;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> overlapped_length = unassembled_index_ - first_index;<br>        data = data.<span class="hljs-built_in">substr</span>(overlapped_length, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>() - overlapped_length, cap));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>(), cap));<br>        <span class="hljs-keyword">if</span> (first_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt; unassembled_index_ + cap - <span class="hljs-number">1</span>) &#123;<br>            data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, unassembled_index_ + cap - first_index);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Get the rear substring and merge the overlapped part</span><br>    <span class="hljs-keyword">auto</span> rear_iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(new_index);<br>    <span class="hljs-keyword">while</span> (rear_iter != unassembled_substrings_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[rear_index, rear_data] = *rear_iter;<br>        <span class="hljs-keyword">if</span> (new_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; rear_index) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-comment">// No overlap conflict</span><br>        <span class="hljs-type">uint64_t</span> rear_overlapped_length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (new_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; rear_index + rear_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            rear_overlapped_length = new_index + data.<span class="hljs-built_in">size</span>() - rear_index;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rear_overlapped_length = rear_data.<span class="hljs-built_in">size</span>();<br>        &#125;<br>        <span class="hljs-comment">// Prepare for next rear early, because the data may be erased afterwards.</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> next_rear = rear_index + rear_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (rear_overlapped_length == rear_data.<span class="hljs-built_in">size</span>()) &#123;<br>            unassembled_bytes_ -= rear_data.<span class="hljs-built_in">size</span>();<br>            unassembled_substrings_.<span class="hljs-built_in">erase</span>(rear_index);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// We don&#x27;t combine current data and rear data.</span><br>            <span class="hljs-comment">// Erase the overlapped part in current data is more efficient.</span><br>            data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">end</span>() - <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(rear_overlapped_length), data.<span class="hljs-built_in">end</span>());<br>        &#125;<br>        rear_iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(next_rear);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (first_index &gt; unassembled_index_) &#123;<br>        <span class="hljs-keyword">auto</span> front_iter = unassembled_substrings_.<span class="hljs-built_in">upper_bound</span>(new_index);<br>        <span class="hljs-keyword">if</span> (front_iter != unassembled_substrings_.<span class="hljs-built_in">begin</span>()) &#123;<br>            front_iter--;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[front_index, front_data] = *front_iter;<br>            <span class="hljs-keyword">if</span> (front_index + front_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt;= first_index) &#123;<br>                <span class="hljs-type">uint64_t</span> overlapped_length = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (front_index + front_data.<span class="hljs-built_in">size</span>() &lt;= first_index + data.<span class="hljs-built_in">size</span>()) &#123;<br>                    overlapped_length = front_index + front_data.<span class="hljs-built_in">size</span>() - first_index;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    overlapped_length = data.<span class="hljs-built_in">size</span>();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (overlapped_length == front_data.<span class="hljs-built_in">size</span>()) &#123;<br>                    unassembled_bytes_ -= front_data.<span class="hljs-built_in">size</span>();<br>                    unassembled_substrings_.<span class="hljs-built_in">erase</span>(front_index);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">begin</span>() + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(overlapped_length));<br>                    <span class="hljs-comment">// Don&#x27;t forget to update the inserted location</span><br>                    new_index = first_index + overlapped_length;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If the processed data is empty, no need to insert it.</span><br>    <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        unassembled_bytes_ += data.<span class="hljs-built_in">size</span>();<br>        unassembled_substrings_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_index, std::<span class="hljs-built_in">move</span>(data)));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = unassembled_substrings_.<span class="hljs-built_in">begin</span>(); iter != unassembled_substrings_.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">/* nop */</span>) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[sub_index, sub_data] = *iter;<br>        <span class="hljs-keyword">if</span> (sub_index == unassembled_index_) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> prev_bytes_pushed = output.<span class="hljs-built_in">bytes_pushed</span>();<br>            output.<span class="hljs-built_in">push</span>(sub_data);<br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> bytes_pushed = output.<span class="hljs-built_in">bytes_pushed</span>();<br>            <span class="hljs-keyword">if</span> (bytes_pushed != prev_bytes_pushed + sub_data.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-comment">// Cannot push all data, we need to reserve the un-pushed part.</span><br>                <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> pushed_length = bytes_pushed - prev_bytes_pushed;<br>                unassembled_index_ += pushed_length;<br>                unassembled_bytes_ -= pushed_length;<br>                unassembled_substrings_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(unassembled_index_, sub_data.<span class="hljs-built_in">substr</span>(pushed_length)));<br>                <span class="hljs-comment">// Don&#x27;t forget to remove the previous incompletely transferred data</span><br>                unassembled_substrings_.<span class="hljs-built_in">erase</span>(sub_index);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            unassembled_index_ += sub_data.<span class="hljs-built_in">size</span>();<br>            unassembled_bytes_ -= sub_data.<span class="hljs-built_in">size</span>();<br>            unassembled_substrings_.<span class="hljs-built_in">erase</span>(sub_index);<br>            iter = unassembled_substrings_.<span class="hljs-built_in">find</span>(unassembled_index_);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// No need to do more. Data has been discontinuous.</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_closed</span>()) &#123;<br>        output.<span class="hljs-built_in">close</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reassembler::bytes_pending</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> unassembled_bytes_; &#125;<br></code></pre></td></tr></table></figure><p>最后还是直接参考了大佬的代码，因为花在lab1上的时间太久了</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230819181925740.png"></p><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230819181854325.png"></p><h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230827203700808.png"></p><h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><p>实现ARP，这节实验开始难度骤降</p><p>参考博客：<a href="https://www.cnblogs.com/chenshengkai/p/13936532.html">ARP报文结构</a>      <a href="https://akaedu.github.io/book/ch36s03.html">ARP</a></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230830223804712.png"></p><h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><p>这节要求实现基于最长前缀匹配规则的路由器转发功能，基本没有难度 </p><p>没有复杂度要求，就直接用vector了，方便一点</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230901111001853.png"></p>]]></content>
    
    
    <categories>
      
      <category>lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重新建站后的第一篇博客</title>
    <link href="/2023/07/29/%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%99%E5%90%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/07/29/%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%99%E5%90%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>​这已经是第二次搭建博客了，距离上一次搭建自己的博客已经有一年多了。之前在大一的时候用的typecho在自己服务器上搭的，主要也是记录的一些算法相关的东西。由于各种因素影响，最后还是放弃了之前的博客，选择重新搭建。</p><p>​这次搭博客，主要还是想要记录一下个人觉得比较有意思的事，发表发表观点，其次是技术方面会写一些有技术深度和广度的博客，做CSDN,掘金搬运工就太没意思了。（这也是放弃之前的博客的原因之一吧）然后写写大学阶段的年度总结吧。总之，写博客是我对于自己所学内容的一种内容输出，也是这次想要重新搭建博客的主要原因。</p><p>​只能说写博客确实挺费时间的，想要坚持一直下去确实有一定难度，但时间挤一挤还是会有的。嗯，大概就这些吧。</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
