<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MIT6.S081实验记录</title>
    <link href="/2023/09/02/MIT6-S081%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/02/MIT6-S081%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>吸取cs144的教训，一定要写完一个lab就把blog给写了，不然时间久了，要么不记得了，要么就会觉得当时卡了很久的问题，其实很简单，不想写上去</p><p>装环境这块相比cs144来说更麻烦一点，需要自己下载编译，但是按照官方的安装说明来其实也还好</p><p><a href="https://pdos.csail.mit.edu/6.S081/2020/tools.html">实验环境安装</a></p><p>因为才重新开始写blog不久，确实有很多地方做的不太好，目前来说的几篇blog感觉不能让读者非常轻松的阅读，只适合自己阅读，这点后面慢慢改吧</p><p>（9.4：因为lab1和lab2没有用git做版本控制导致库里没有这两实验的相关code，只能在blog里记录了）</p><h2 id="lab1-Xv6-and-Unix-utilities"><a href="#lab1-Xv6-and-Unix-utilities" class="headerlink" title="lab1 Xv6 and Unix utilities"></a>lab1 Xv6 and Unix utilities</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><p>This lab will familiarize you with xv6 and its system calls.</p><h3 id="sleep-easy"><a href="#sleep-easy" class="headerlink" title="sleep (easy)"></a>sleep (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h3><p>练手题，非常简单  主要是熟悉一下怎么输入输出</p><p>因为我开始并不熟悉整个实验的环境和测试流程，所以sleep我就拿大佬的代码来快速上手了，代码也很简单，主要是熟悉一下实验平台</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// sleep.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span> <span class="hljs-comment">// 必须以这个顺序 include，由于三个头文件有依赖关系</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: sleep &lt;ticks&gt;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pingpong-easy"><a href="#pingpong-easy" class="headerlink" title="pingpong (easy)"></a>pingpong (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h3><p>这里涉及到两个关键的点，fork（）和pipe（），如果能理解到这两系统调用的作用是什么，那这题也非常简单</p><p>todo： pipe()的概念</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span> <span class="hljs-comment">// 必须以这个顺序 include，由于三个头文件有依赖关系</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-type">int</span> pi[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> pi2[<span class="hljs-number">2</span>];<br>    pipe(pi);<br>    pipe(pi2);<br>    <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-type">char</span> buf;<br>        read(pi[<span class="hljs-number">0</span>],&amp;buf,<span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>,getpid());<br>        write(pi2[<span class="hljs-number">1</span>],&amp;buf,<span class="hljs-keyword">sizeof</span>(buf));<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        write(pi[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;?&quot;</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">char</span> buf;<br>        read(pi2[<span class="hljs-number">0</span>],&amp;buf,<span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>,getpid());<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="primes-moderate-hard"><a href="#primes-moderate-hard" class="headerlink" title="primes (moderate)&#x2F;(hard)"></a>primes (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)&#x2F;(<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h3><p>这题如果说是难题，那么难就难在理解埃氏筛这个算法和怎么实现，由于我之前刷算法的时候刷到过素数筛，所以了解过相关概念，这题对于我来说难度不大，就是处理细节得花挺多时间</p><p>相关资料：<a href="https://swtch.com/~rsc/thread/">埃氏筛</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span> <span class="hljs-comment">// 必须以这个顺序 include，由于三个头文件有依赖关系</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> pip[])</span>&#123;<br>    <span class="hljs-type">int</span> pi[<span class="hljs-number">2</span>];<br>    pipe(pi);<br>    <span class="hljs-keyword">if</span> (num==<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br><br>    <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        close(pi[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//关写进程</span><br>        close(pip[<span class="hljs-number">0</span>]);<br>        read(pi[<span class="hljs-number">0</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, tmp);<br>        dfs(tmp,pi);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        close(pi[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//关读进程</span><br>        <span class="hljs-keyword">while</span>(read(pip[<span class="hljs-number">0</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp))&amp;&amp;tmp!=<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span> (tmp%num!=<span class="hljs-number">0</span>)&#123;<br>                write(pi[<span class="hljs-number">1</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp));<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> end = <span class="hljs-number">-1</span>;      <span class="hljs-comment">//忘记补写了，一直在这里超时</span><br>        write(pi[<span class="hljs-number">1</span>],&amp;end,<span class="hljs-keyword">sizeof</span>(end));<br>        wait(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-type">int</span> pi[<span class="hljs-number">2</span>];<br>    pipe(pi);<br>    <span class="hljs-type">int</span> num =<span class="hljs-number">2</span> ;<br>    <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        close(pi[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//关写进程</span><br>        read(pi[<span class="hljs-number">0</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp));<br>        dfs(tmp,pi);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-number">3</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, num);<br>        close(pi[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">while</span>(tmp&lt;=<span class="hljs-number">35</span>)&#123;<br>            <span class="hljs-keyword">if</span>(tmp%num!=<span class="hljs-number">0</span>)&#123;<br>                write(pi[<span class="hljs-number">1</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp));<br>            &#125;<br>            tmp++;<br>        &#125;<br>        <span class="hljs-type">int</span> end = <span class="hljs-number">-1</span>;<br>        write(pi[<span class="hljs-number">1</span>],&amp;end,<span class="hljs-keyword">sizeof</span>(end));<br>    &#125;<br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这边的一个坑点就是管道 要注意关闭不需要用到的文件描述符，否则跑到 n &#x3D; 13 的时候就会爆掉，出现读到全是 0 的情况。</p><blockquote><p>这里的理由是，fork 会将父进程的所有文件描述符都复制到子进程里，而 xv6 每个进程能打开的文件描述符总数只有 16 个 （见 <code>defs.h</code> 中的 <code>NOFILE</code> 和 <code>proc.h</code> 中的 <code>struct file *ofile[NOFILE]; // Open files</code>）。</p><p>由于一个管道会同时打开一个输入文件和一个输出文件，所以<strong>一个管道就占用了 2 个文件描述符</strong>，并且复制的<strong>子进程还会复制父进程的描述符</strong>，于是跑到第六七层后，就会由于最末端的子进程出现 16 个文件描述符都被占满的情况，导致新管道创建失败。</p></blockquote><p>关闭不必要的管道即可，如文中代码所示</p><h3 id="find-moderate"><a href="#find-moderate" class="headerlink" title="find (moderate)"></a>find (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p></blockquote><p>hint让我们去看ls的源码，其实大部分代码都可以复用ls的代码，所以难度不大</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// find.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *target)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    <span class="hljs-keyword">if</span> ((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (st.type)<br>    &#123;<br>    <span class="hljs-keyword">case</span> T_FILE:<br>       <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(path + <span class="hljs-built_in">strlen</span>(path) - <span class="hljs-built_in">strlen</span>(target), target) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, path);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> T_DIR:<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">strcpy</span>(buf, path);<br>        p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>        *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            memmove(p, de.name, DIRSIZ);<br>            p[DIRSIZ] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf + <span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">2</span>, <span class="hljs-string">&quot;/.&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(buf + <span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">3</span>, <span class="hljs-string">&quot;/..&quot;</span>) != <span class="hljs-number">0</span>)<br>            &#123;<br>                find(buf, target); <span class="hljs-comment">// 递归查找</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    close(fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> target[<span class="hljs-number">512</span>];<br>    target[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;/&#x27;</span>; <span class="hljs-comment">// 为查找的文件名添加 / 在开头</span><br>    <span class="hljs-built_in">strcpy</span>(target + <span class="hljs-number">1</span>, argv[<span class="hljs-number">2</span>]);<br>    find(argv[<span class="hljs-number">1</span>], target);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="xargs-moderate"><a href="#xargs-moderate" class="headerlink" title="xargs (moderate)"></a>xargs (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p></blockquote><p>这题对于我来说一个是理解到位xargs的作用是什么，一个是c的语法和特性，比如在题解中使用了的大量的指针等等</p><p>xargs：将标准输入转换成命令行输入（让echo等命令可以接收到），然后还有其他的作用，比如说格式化输出等等 <a href="https://www.runoob.com/linux/linux-comm-xargs.html">Linux xargs 命令 | 菜鸟教程 (runoob.com)</a></p><p>之前一直没花太多时间在c语言上，可能对于我来说还是不太熟悉c的特性和操作系统的相关概念，写这题还是花了挺长时间的，最后这题还是参考了大佬的博客才吃透把这题过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// xargs.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(<span class="hljs-type">char</span> *program, <span class="hljs-type">char</span> **args)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">// child exec</span><br>        exec(program, args);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// parent return</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 读取所有的xargs的参数</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">2048</span>]; <span class="hljs-comment">// 缓冲read里读出来的字符拼接成字符串参数</span><br>    <span class="hljs-type">char</span> **argans;<br>    <span class="hljs-type">char</span> *argv2[<span class="hljs-number">128</span>]; <span class="hljs-comment">// 不能直接使用++移动指针</span><br>    argans = argv2;<br>    <span class="hljs-type">char</span> *start = buf;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++)<br>    &#123;<br>        *argans = argv[i];<br>        argans++;<br>    &#125;<br><br>    <span class="hljs-comment">// 读入参数</span><br>    <span class="hljs-type">char</span> *p = buf;<br>    <span class="hljs-type">char</span> **pa = argans; <span class="hljs-comment">// argans作为头部指针，重置到数组开头的时候用</span><br>    <span class="hljs-keyword">while</span> (read(<span class="hljs-number">0</span>, p, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (*p == <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-comment">// 说明是参数</span><br>        &#123;<br>            *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            *(pa++) = start;<br>            start = p + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (*p == <span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-comment">// 开始执行指令</span><br>        &#123;<br>            *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            *(pa++) = start;<br>            start = p + <span class="hljs-number">1</span>;<br>            *pa = <span class="hljs-number">0</span>;<br>            run(argv[<span class="hljs-number">1</span>], argv2);<br>            pa = argans; <span class="hljs-comment">// 重置</span><br>        &#125;<br>        p++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pa != argans)<br>    &#123; <span class="hljs-comment">// 如果最后一行不是空行</span><br>        <span class="hljs-comment">// 收尾最后一个参数</span><br>        *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        *(pa++) = start;<br>        <span class="hljs-comment">// 收尾最后一行</span><br>        *pa = <span class="hljs-number">0</span>; <span class="hljs-comment">// 参数列表末尾用 null 标识列表结束</span><br>        <span class="hljs-comment">// 执行最后一行指令</span><br>        run(argv[<span class="hljs-number">1</span>], argv2);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (wait(<span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>)<br>    &#123;<br>    &#125;; <span class="hljs-comment">// 循环等待所有子进程完成，每一次 wait(0) 等待一个</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230903095735393.png" alt="image-20230903095735393"></p><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>记录一下自己在做实验过程中的疑惑</p><p>trapframe : 发生trap时，用于保存当前进程如寄存器等状态</p></blockquote><p>lab2和lab1都是挺简单的，而且lab2的任务量和难度都比lab1小，留意lab给的提示就行</p><p>因为lab2的源码也丢失了，这里也没办法放代码了</p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230903140502352.png" alt="image-20230903140502352"></p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230903141908664.png" alt="image-20230903141908664"></p><p>务必注意指导书提示：</p><blockquote><p>Some hints:</p><ul><li>Add <code>$U/_trace</code> to UPROGS in Makefile</li><li>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</li><li>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</li><li>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</li><li>Modify the <code>syscall()</code> function in <code>kernel/syscall.c</code> to print the trace output. You will need to add an array of syscall names to index into.</li></ul></blockquote><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230903151705364.png" alt="image-20230903151705364"></p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230903161041574.png" alt="image-20230903161041574"></p><h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><blockquote><p>Define a function called <code>vmprint()</code>. It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process’s page table. You receive full credit for this assignment if you pass the <code>pte printout</code> test of <code>make grade</code>.</p></blockquote><p>第一行打印传入vm的参数，我们把传进来的pagetable用%p打印一下就好了</p><blockquote><p>The root of the tree is a 4096-byte page-table page that contains 512 PTEs, which contain the physical addresses for page-table pages in the next level of the tree.Each of those pages contains 512 PTEs for the final level in the tree.</p></blockquote><p>接着遍历他的512个PTE，根据标志位判断是否有child，如果有的话就继续递归，这边可以通过depth参数来进行打印 .. 的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable,uint64 depth)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (depth&gt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(depth==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. ..&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>        <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>        <span class="hljs-keyword">if</span>((pte &amp; PTE_V) )&#123;<br>            <span class="hljs-keyword">if</span> (depth==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (depth==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. .. ..&quot;</span>);<br>            &#125;<br>            uint64 child = PTE2PA(pte);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: pte %p pa %p\n&quot;</span>,i,pagetable[i],child);<br>            <span class="hljs-keyword">if</span>( (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>)&#123;<br>                dfs((<span class="hljs-type">pagetable_t</span>)child,depth+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> ptb)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, ptb);<br>    dfs(ptb,<span class="hljs-number">0</span>);<br>&#125;s<br></code></pre></td></tr></table></figure><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230904172005306.png" alt="image-20230904172005306"></p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230904172910125.png" alt="image-20230904172910125"></p><h3 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h3><blockquote><p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. Modify <code>struct proc</code> to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if <code>usertests</code> runs correctly.</p></blockquote><p>这题注意他给的hint，看着一步一步来，还是比较好做的，主要是题意好理解</p><blockquote><p>A PTE can only refer to a physical address that is aligned on a 4096-byte boundary (is a multiple of 4096), so freerange uses PGROUNDUP to ensure that it frees only aligned physical addresses. </p></blockquote><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230905163657350.png" alt="image-20230905163657350"></p><h3 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin/copyinstr</code></h3><blockquote><p>Replace the body of <code>copyin</code> in <code>kernel/vm.c</code> with a call to <code>copyin_new</code> (defined in <code>kernel/vmcopyin.c</code>); do the same for <code>copyinstr</code> and <code>copyinstr_new</code>. Add mappings for user addresses to each process’s kernel page table so that <code>copyin_new</code> and <code>copyinstr_new</code> work. You pass this assignment if <code>usertests</code> runs correctly and all the <code>make grade</code> tests pass.</p></blockquote><p>卡了有段时间，一开始题意理解到就去做，费了很大的精力，最后还是不得不回滚到一开始的版本（所以下次一定把他的题目意思是什么搞懂再去做，不然很容易理解错题意，浪费精力。。虽然但是花的时间也是去了解xv6的设计，也可以说不算浪费？）</p><blockquote><p> However, this scheme does limit the maximum size of a user process to be less than the kernel’s lowest virtual address. After the kernel has booted, that address is <code>0xC000000</code> in xv6, the address of the PLIC registers; see <code>kvminit()</code> in <code>kernel/vm.c</code>, <code>kernel/memlayout.h</code>, and Figure 3-4 in the text. You’ll need to modify xv6 to prevent user processes from growing larger than the PLIC address.</p></blockquote><p>copyin在用户进程使用，va !&#x3D; pa，copyin_new在kernel中使用，va &#x3D; pa。 理解到这个就非常简单了</p><p>详见下面，我们需要使用的是0到PLIC下面的地址</p><p>所以我们映射的时候不需要映射CLINT</p><p>接着根据hint提到的和内核页表相关的地方进行修改</p><p><img src="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p3.png" alt="img"></p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230905204525549.png" alt="image-20230905204525549"></p><h2 id="lab4-Traps"><a href="#lab4-Traps" class="headerlink" title="lab4 Traps"></a>lab4 Traps</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><ul><li>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</li></ul><p>​     <strong>A:</strong>   a0-a7; a2;</p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230906112130650.png" alt="image-20230906112130650"></p><ul><li>Where is the call to function f in the assembly code for main? Where is the call to g? <strong>(Hint: the compiler may inline functions.)</strong></li></ul><p><strong>A:</strong> 被内联到了main函数中</p><ul><li>At what address is the function <code>printf</code> located?</li></ul><p> <strong>A:</strong> 0x630</p><ul><li>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</li></ul><p><strong>A:</strong> 0x38</p><ul><li><blockquote><p>Run the following code.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">unsigned <span class="hljs-keyword">int</span> i = <span class="hljs-number">0x00646c72</span>;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, &amp;i);<br>     <br></code></pre></td></tr></table></figure><p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p></blockquote></li></ul><p>很简单，懒得复制代码跑了，</p><ul><li>In the following code, what is going to be printed after ‘y&#x3D;’? (note: the answer is not a specific value.) Why does this happen?</li></ul><p><strong>A:</strong>  随机的，取决于a2寄存器里的值</p><h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><blockquote><p>Implement a <code>backtrace()</code> function in <code>kernel/printf.c</code>. Insert a call to this function in <code>sys_sleep</code>, and then run bttest, which calls <code>sys_sleep</code>. Your output should be as follows:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">backtrace:</span><br><span class="hljs-number">0x0000000080002cda</span><br><span class="hljs-number">0x0000000080002bb6</span><br><span class="hljs-number">0x0000000080002898</span><br>  <br></code></pre></td></tr></table></figure><p>After <code>bttest</code> exit qemu. In your terminal: the addresses may be slightly different but if you run <code>addr2line -e kernel/kernel</code> (or <code>riscv64-unknown-elf-addr2line -e kernel/kernel</code>) and cut-and-paste the above addresses as follows:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">$ addr2line -e kernel/kernel<br><span class="hljs-number">0x0000000080002de2</span><br><span class="hljs-number">0x0000000080002f4a</span><br><span class="hljs-number">0x0000000080002bfc</span><br>Ctrl-D<br>  <br></code></pre></td></tr></table></figure><p>You should see something like this:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kernel</span>/sysproc.c:<span class="hljs-number">74</span><br><span class="hljs-attribute">kernel</span>/syscall.c:<span class="hljs-number">224</span><br><span class="hljs-attribute">kernel</span>/trap.c:<span class="hljs-number">85</span><br></code></pre></td></tr></table></figure></blockquote><p>这题注意一下</p><blockquote><ul><li>These <a href="https://pdos.csail.mit.edu/6.828/2020/lec/l-riscv-slides.pdf">lecture notes</a> have a picture of the layout of stack frames. Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.</li></ul></blockquote><p>这个就好了，easy题，没什么难度</p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230906164256057.png" alt="image-20230906164256057"></p><h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><blockquote><p>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you’ll be implementing a primitive form of user-level interrupt&#x2F;fault handlers; you could use something similar to handle page faults in the application, for example. Your solution is correct if it passes alarmtest and usertests.</p></blockquote><p>这边调用传入的alarm函数是直接用程序计数器指向函数进行运行，然后通过sigreturn恢复</p><p>但是一开始尝试只恢复epc不行，还是会报错</p><p>原因是在函数调用的过程中也会对寄存器进行修改</p><p>所以得把整个都保存下来</p><p>因为c语言的基础确实差，最后用的笨方法，直接存储30多个寄存器的值，一开始也想着用一个struct trapframe *trapframe 这样的结构体指针的，发现直接赋值行不通，然后尝试初始化指针分配内存后还是报错不知道为什么，然后就直接把30多个寄存器都放到p里用于保存。</p><blockquote><p>后面了解到好像还得实现结构体的free才行，但我后面没去没尝试过</p></blockquote><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230907221659128.png" alt="image-20230907221659128"></p><h2 id="lab5-xv6-lazy-page-allocation"><a href="#lab5-xv6-lazy-page-allocation" class="headerlink" title="lab5 xv6 lazy page allocation"></a>lab5 xv6 lazy page allocation</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>One of the many neat tricks an O&#x2F;S can play with page table hardware is lazy allocation of user-space heap memory. Xv6 applications ask the kernel for heap memory using the sbrk() system call. In the kernel we’ve given you, sbrk() allocates physical memory and maps it into the process’s virtual address space. It can take a long time for a kernel to allocate and map memory for a large request. Consider, for example, that a gigabyte consists of 262,144 4096-byte pages; that’s a huge number of allocations even if each is individually cheap. In addition, some programs allocate more memory than they actually use (e.g., to implement sparse arrays), or allocate memory well in advance of use. To allow sbrk() to complete more quickly in these cases, sophisticated kernels allocate user memory lazily. That is, sbrk() doesn’t allocate physical memory, but just remembers which user addresses are allocated and marks those addresses as invalid in the user page table. When the process first tries to use any given page of lazily-allocated memory, the CPU generates a page fault, which the kernel handles by allocating physical memory, zeroing it, and mapping it. You’ll add this lazy allocation feature to xv6 in this lab.</p></blockquote><p>这次的lab比较简单，大概用时3-4小时做完了，没有hard题</p><h3 id="Eliminate-allocation-from-sbrk-easy"><a href="#Eliminate-allocation-from-sbrk-easy" class="headerlink" title="Eliminate allocation from sbrk() (easy)"></a>Eliminate allocation from sbrk() (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h3><blockquote><p>Your first task is to delete page allocation from the sbrk(n) system call implementation, which is the function sys_sbrk() in sysproc.c. The sbrk(n) system call grows the process’s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process’s size (myproc()-&gt;sz) by n and return the old size. It should not allocate memory – so you should delete the call to growproc() (but you still need to increase the process’s size!).</p></blockquote><p>纯概念，故跳过</p><p>因为这次lab的几个题都是有联系的，这题也是为了后面几题做铺垫</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">if</span> (n&lt;<span class="hljs-number">0</span>)&#123;<br>        uvmdealloc(myproc()-&gt;pagetable,myproc()-&gt;sz,myproc()-&gt;sz+n);<br>    &#125;<br>  myproc()-&gt;sz=myproc()-&gt;sz+n;<br><br><span class="hljs-comment">//  if(growproc(n) &lt; 0)</span><br><span class="hljs-comment">//    return -1;</span><br></code></pre></td></tr></table></figure><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230909121001731.png" alt="image-20230909121001731"></p><h3 id="Lazy-allocation-moderate"><a href="#Lazy-allocation-moderate" class="headerlink" title="Lazy allocation (moderate)"></a>Lazy allocation (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Modify the code in trap.c to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. You should add your code just before the <code>printf</code> call that produced the “usertrap(): …” message. Modify whatever other xv6 kernel code you need to in order to get <code>echo hi</code> to work.</p></blockquote><p>这题跟着hint走就行，为下一题做铺垫</p><blockquote><ul><li>You can check whether a fault is a page fault by seeing if r_scause() is 13 or 15 in usertrap().</li><li><code>r_stval()</code> returns the RISC-V <code>stval</code> register, which contains the virtual address that caused the page fault.</li><li>Steal code from uvmalloc() in vm.c, which is what sbrk() calls (via growproc()). You’ll need to call kalloc() and mappages().</li><li>Use PGROUNDDOWN(va) to round the faulting virtual address down to a page boundary.</li><li>uvmunmap() will panic; modify it to not panic if some pages aren’t mapped.</li><li>If the kernel crashes, look up sepc in kernel&#x2F;kernel.asm</li><li>Use your <code>vmprint</code> function from pgtbl lab to print the content of a page table.</li><li>If you see the error “incomplete type proc”, include “spinlock.h” then “proc.h”.</li></ul></blockquote><h3 id="Lazytests-and-Usertests-moderate"><a href="#Lazytests-and-Usertests-moderate" class="headerlink" title="Lazytests and Usertests (moderate)"></a>Lazytests and Usertests (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>We’ve supplied you with <code>lazytests</code>, an xv6 user program that tests some specific situations that may stress your lazy memory allocator. Modify your kernel code so that all of both <code>lazytests</code> and <code>usertests</code> pass.</p></blockquote><p>题目中提到的hint都要实现，我写到后面发现漏了read这几个系统调用也得修改，然后就是最后一个stack，我做了判断，但是没有else把kill设置为1杀掉进程，导致usertest过不去，卡在stack那个测试点不动，因为我一直认为我是if如果没进去那就会被杀掉，开始就没往这边想，后面回头一看才发现不得行。浪费我1个多小时的时间</p><blockquote><ul><li>Handle negative sbrk() arguments.</li><li>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</li><li>Handle the parent-to-child memory copy in fork() correctly.</li><li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</li><li>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</li><li>Handle faults on the invalid page below the user stack.</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span><br>usertests starting<br>test execout: OK<br>test copyin: OK<br>test copyout: OK<br>test copyinstr1: OK<br>test copyinstr2: OK<br>test copyinstr3: OK<br>test rwsbrk: OK<br>test truncate1: OK<br>test truncate2: OK<br>test truncate3: OK<br>test reparent2: OK<br>test pgbug: OK<br>test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3235<br>            sepc=0x0000000000005580 stval=0x0000000000005580<br>usertrap(): unexpected scause 0x000000000000000c pid=3236<br>            sepc=0x0000000000005580 stval=0x0000000000005580<br>OK<br>test badarg: OK<br>test reparent: OK<br>test twochildren: OK<br>test forkfork: OK<br>test forkforkfork: OK<br>test argptest: OK<br>test createdelete: OK<br>test linkunlink: OK<br>test linktest: OK<br>test unlinkread: OK<br>test concreate: OK<br>test subdir: OK<br>test fourfiles: OK<br>test sharedfd: OK<br>test exectest: OK<br>test bigargtest: OK<br>test bigwrite: OK<br>test bsstest: OK<br>test sbrkbasic: OK<br>test sbrkmuch: OK<br>test kernmem: OK<br>test sbrkfail: OK<br>test sbrkarg: OK<br>test validatetest: OK<br>test stacktest: OK<br>test opentest: OK<br>test writetest: OK<br>test writebig: OK<br>test createtest: OK<br>test openiput: OK<br>test exitiput: OK<br>test iput: OK<br>test mem: OK<br>test pipe1: OK<br>test preempt: kill... wait... OK<br>test exitwait: OK<br>test rmdot: OK<br>test fourteen: OK<br>test bigfile: OK<br>test dirfile: OK<br>test iref: OK<br>test forktest: OK<br>test bigdir: OK<br>ALL TESTS PASSED<br></code></pre></td></tr></table></figure><h2 id="lab6-Copy-on-Write-Fork-for-xv6"><a href="#lab6-Copy-on-Write-Fork-for-xv6" class="headerlink" title="lab6 Copy-on-Write Fork for xv6"></a>lab6 Copy-on-Write Fork for xv6</h2><blockquote><p>Virtual memory provides a level of indirection: the kernel can intercept memory references by marking PTEs invalid or read-only, leading to page faults, and can change what addresses mean by modifying PTEs. There is a saying in computer systems that any systems problem can be solved with a level of indirection. The lazy allocation lab provided one example. This lab explores another example: copy-on write fork.</p></blockquote><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><p>哎，啥也不多说了，题目做起来快，但是debug花的时间太多了（我太菜了QAQ）</p><p>第一个遇到的bug，也是我花了最多时间，并且目前还没get到为什么不行的地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">COW_alloc</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> ptl,uint64 va)</span>&#123;<br>    va = PGROUNDDOWN(va);<br>    <span class="hljs-type">pte_t</span> * pte;<br>    <span class="hljs-keyword">if</span>((pte=walk(ptl,va,<span class="hljs-number">0</span>))==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;judge_page_fault walk err\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    uint64 pa =   PA2PTE(*pte);<br>    <span class="hljs-comment">//重设flag</span><br>    *pte=*pte | PTE_W;<br>    *pte=*pte &amp; ~PTE_COW;<br>    <span class="hljs-type">int</span> flag =  PTE_FLAGS(*pte);<br><br>    <span class="hljs-comment">//分配内存</span><br>    uint64  mem = (uint64) kalloc();<br>    <span class="hljs-keyword">if</span>(mem==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;COW_alloc kalloc failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    memmove((<span class="hljs-type">char</span>*)mem,(<span class="hljs-type">char</span>* )pa,PGSIZE);<br>    <span class="hljs-comment">//解除映射关系</span><br>    uvmunmap(ptl,va,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//重新映射</span><br>    <span class="hljs-keyword">if</span>(mappages(ptl,va,PGSIZE,(uint64)mem,flag)&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;COW_alloc mappages failed\n&quot;</span>);<br>        kfree((<span class="hljs-type">void</span>*)mem);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cow</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va)</span> &#123;<br>    <span class="hljs-keyword">if</span> (va &gt;= MAXVA) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 找到va对应的pte</span><br>    <span class="hljs-type">pte_t</span>* pte = walk(pagetable, va, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pte == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*pte &amp; PTE_COW) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*pte &amp; PTE_U) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 物理地址</span><br>    uint64 pa = PTE2PA(*pte);<br>    uint64 ka = (uint64) kalloc();<br>    <span class="hljs-keyword">if</span> (ka == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 复制pa到ka</span><br>        memmove((<span class="hljs-type">char</span>*)ka, (<span class="hljs-type">char</span>*)pa, PGSIZE);<br>        uint64 flags = PTE_FLAGS(*pte);<br>        *pte = PA2PTE(ka) | flags | PTE_W;<br>        *pte &amp;= (~PTE_COW);<br>        <span class="hljs-comment">// 更新计数</span><br>        kfree((<span class="hljs-type">void</span> *)pa);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两段代码只有下面的可以跑通，上面的不行，但我自己看起来感觉没什么太大区别，上面的memmove通过不了，这是我最疑惑的地方，先插个眼，后面回过头来研究下</p><p>第二个就是锁，他的测试有几个是会上压力并发测试的，我在这里吃了个亏，读取的时候直接return了（QAQ）,所有的对COW引用数组的操作全要加锁，不然过不了usertests</p><p>最后是va大于MAXVA返回的位置，记得要放到walk前，不然最后会爆释放的页数对不上的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (va &gt;= MAXVA) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>差一个page对不上，改这里。插个眼</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span><br>&#123;<br>  <span class="hljs-type">char</span> *p;<br>  p = (<span class="hljs-type">char</span>*)PGROUNDUP((uint64)pa_start);<br>  <span class="hljs-keyword">for</span>(; p + PGSIZE &lt;= (<span class="hljs-type">char</span>*)pa_end; p += PGSIZE)&#123;<br>      COW_COUNT[((uint64)p)/<span class="hljs-number">4096</span>] = <span class="hljs-number">1</span>;    <br>      kfree(p);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230911112538576.png" alt="image-20230911112538576"></p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230911111236992.png" alt="image-20230911111236992"></p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230911111329196.png" alt="image-20230911111329196"></p><h2 id="lab7-Multithreading"><a href="#lab7-Multithreading" class="headerlink" title="lab7 Multithreading"></a>lab7 Multithreading</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>This lab will familiarize you with multithreading. You will implement switching between threads in a user-level threads package, use multiple threads to speed up a program, and implement a barrier.</p></blockquote><p>线程相关的两节课看的我有点心累，也许是这两天状态没有调整好，还是说课程本来就比较抽象？（应该是自己的原因吧，确实感觉这两天很累）</p><h3 id="Uthread-switching-between-threads-moderate"><a href="#Uthread-switching-between-threads-moderate" class="headerlink" title="Uthread: switching between threads (moderate)"></a>Uthread: switching between threads (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Your job is to come up with a plan to create threads and save&#x2F;restore registers to switch between threads, and implement that plan. When you’re done, <code>make grade</code> should say that your solution passes the <code>uthread</code> test.</p></blockquote><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230912212557518.png" alt="image-20230912212557518"></p><h3 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h3><blockquote><p>Why are there missing keys with 2 threads, but not with 1 thread? Identify a sequence of events with 2 threads that can lead to a key being missing. Submit your sequence with a short explanation in answers-thread.txt</p><p>To avoid this sequence of events, insert lock and unlock statements in <code>put</code> and <code>get</code> in <code>notxv6/ph.c</code> so that the number of keys missing is always 0 with two threads. The relevant pthread calls are:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pthread_mutex_t <span class="hljs-keyword">lock</span>;            // <span class="hljs-keyword">declare</span> a <span class="hljs-keyword">lock</span><br>pthread_mutex_init(&amp;<span class="hljs-keyword">lock</span>, <span class="hljs-keyword">NULL</span>); // initialize the <span class="hljs-keyword">lock</span><br>pthread_mutex_lock(&amp;<span class="hljs-keyword">lock</span>);       // acquire <span class="hljs-keyword">lock</span><br>pthread_mutex_lock(&amp;<span class="hljs-keyword">lock</span>);       // <span class="hljs-keyword">release</span> <span class="hljs-keyword">lock</span><br></code></pre></td></tr></table></figure><p>You’re done when <code>make grade</code> says that your code passes the <code>ph_safe</code> test, which requires zero missing keys with two threads. It’s OK at this point to fail the <code>ph_fast</code> test.</p></blockquote><p>这里是并发不安全的，所以我们先测试在这里加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">put_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *xa)</span><br>&#123;<br>  <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) (<span class="hljs-type">long</span>) xa; <span class="hljs-comment">// thread number</span><br>  <span class="hljs-type">int</span> b = NKEYS/nthread;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b; i++) &#123;<br>pthread_mutex_lock(&amp;lock);     <span class="hljs-comment">//here</span><br>    put(keys[b*n + i], n);<br>pthread_mutex_lock(&amp;lock);  <span class="hljs-comment">//here</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是可以通过安全测试的，但是速度上慢得多，原因是我们加锁粒度太大了，我们一次把整个哈希表都锁住了</p><p>所以我们需要去降低锁的粒度，锁住每一个桶，而不是整个表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span><br>&#123;<br>  <span class="hljs-type">int</span> i = key % NBUCKET;<br>    pthread_mutex_lock(&amp;lock[i]);<br>  <span class="hljs-comment">// is the key already present?</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (e = table[i]; e != <span class="hljs-number">0</span>; e = e-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;key == key)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(e)&#123;<br>    <span class="hljs-comment">// update the existing key.</span><br>    e-&gt;value = value;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// the new is new.</span><br>    insert(key, value, &amp;table[i], table[i]);<br>  &#125;<br>    pthread_mutex_unlock(&amp;lock[i]);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> entry*<br><span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span><br>&#123;<br>  <span class="hljs-type">int</span> i = key % NBUCKET;<br>    pthread_mutex_lock(&amp;lock[i]);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (e = table[i]; e != <span class="hljs-number">0</span>; e = e-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;key == key) <span class="hljs-keyword">break</span>;<br>  &#125;<br>    pthread_mutex_unlock(&amp;lock[i]);<br>  <span class="hljs-keyword">return</span> e;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">put_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *xa)</span><br>&#123;<br>  <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) (<span class="hljs-type">long</span>) xa; <span class="hljs-comment">// thread number</span><br>  <span class="hljs-type">int</span> b = NKEYS/nthread;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b; i++) &#123;<br><br>    put(keys[b*n + i], n);<br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-type">pthread_t</span> *tha;<br>  <span class="hljs-type">void</span> *value;<br>  <span class="hljs-type">double</span> t1, t0;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;NBUCKET;i++) &#123;<br>        pthread_mutex_init(&amp;lock[i],<span class="hljs-literal">NULL</span>);<br>    &#125;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s nthreads\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br>  nthread = atoi(argv[<span class="hljs-number">1</span>]);<br>  tha = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">pthread_t</span>) * nthread);<br>  srandom(<span class="hljs-number">0</span>);<br>  assert(NKEYS % nthread == <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NKEYS; i++) &#123;<br>    keys[i] = random();<br>  &#125;<br><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// first the puts</span><br>  <span class="hljs-comment">//</span><br>  t0 = now();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    assert(pthread_create(&amp;tha[i], <span class="hljs-literal">NULL</span>, put_thread, (<span class="hljs-type">void</span> *) (<span class="hljs-type">long</span>) i) == <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    assert(pthread_join(tha[i], &amp;value) == <span class="hljs-number">0</span>);<br>  &#125;<br>  t1 = now();<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d puts, %.3f seconds, %.0f puts/second\n&quot;</span>,<br>         NKEYS, t1 - t0, NKEYS / (t1 - t0));<br><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// now the gets</span><br>  <span class="hljs-comment">//</span><br>  t0 = now();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    assert(pthread_create(&amp;tha[i], <span class="hljs-literal">NULL</span>, get_thread, (<span class="hljs-type">void</span> *) (<span class="hljs-type">long</span>) i) == <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    assert(pthread_join(tha[i], &amp;value) == <span class="hljs-number">0</span>);<br>  &#125;<br>  t1 = now();<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d gets, %.3f seconds, %.0f gets/second\n&quot;</span>,<br>         NKEYS*nthread, t1 - t0, (NKEYS*nthread) / (t1 - t0));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Barrier-moderate"><a href="#Barrier-moderate" class="headerlink" title="Barrier(moderate)"></a>Barrier(moderate)</h3><blockquote><p>Your goal is to achieve the desired barrier behavior. In addition to the lock primitives that you have seen in the <code>ph</code> assignment, you will need the following new pthread primitives; look <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_wait.html">here</a> and <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_broadcast.html">here</a> for details.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">pthread<span class="hljs-constructor">_cond_wait(&amp;<span class="hljs-params">cond</span>, &amp;<span class="hljs-params">mutex</span>)</span>;  <span class="hljs-comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span><br>pthread<span class="hljs-constructor">_cond_broadcast(&amp;<span class="hljs-params">cond</span>)</span>;     <span class="hljs-comment">// wake up every thread sleeping on cond</span><br></code></pre></td></tr></table></figure><p>Make sure your solution passes <code>make grade</code>‘s <code>barrier</code> test.</p></blockquote><p>跟着他的提示来就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">barrier</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">// YOUR CODE HERE</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Block until all threads have called barrier() and</span><br>  <span class="hljs-comment">// then increment bstate.round.</span><br>  <span class="hljs-comment">//</span><br>    pthread_mutex_lock(&amp;bstate.barrier_mutex);<br>    bstate.nthread++;<br>    <span class="hljs-keyword">if</span>(bstate.nthread&lt;nthread)&#123;<br>        pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        bstate.nthread=<span class="hljs-number">0</span>;<br>        bstate.round++;<br>        pthread_cond_broadcast(&amp;bstate.barrier_cond);<br>    &#125;<br>    pthread_mutex_unlock(&amp;bstate.barrier_mutex);<br><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>怎么说呢，这次的实验还是挺简单的，全程3个小时多</p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230913082203927.png" alt="image-20230913082203927"></p><h2 id="Lab8-locks"><a href="#Lab8-locks" class="headerlink" title="Lab8: locks"></a>Lab8: locks</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>In this lab you’ll gain experience in re-designing code to increase parallelism. A common symptom of poor parallelism on multi-core machines is high lock contention. Improving parallelism often involves changing both data structures and locking strategies in order to reduce contention. You’ll do this for the xv6 memory allocator and block cache.</p></blockquote><h3 id="Memory-allocator-moderate"><a href="#Memory-allocator-moderate" class="headerlink" title="Memory allocator (moderate)"></a>Memory allocator (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Your job is to implement per-CPU freelists, and stealing when a CPU’s free list is empty. You must give all of your locks names that start with “kmem”. That is, you should call <code>initlock</code> for each of your locks, and pass a name that starts with “kmem”. Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run <code>usertests sbrkmuch</code>. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ. Make sure all tests in <code>usertests</code> pass. <code>make grade</code> should say that the kalloctests pass.</p></blockquote><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230913164618726.png" alt="image-20230913164618726"></p><h3 id="Buffer-cache-hard"><a href="#Buffer-cache-hard" class="headerlink" title="Buffer cache (hard)"></a>Buffer cache (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h3><blockquote><p>Modify the block cache so that the number of <code>acquire</code> loop iterations for all locks in the bcache is close to zero when running <code>bcachetest</code>. Ideally the sum of the counts for all locks involved in the block cache should be zero, but it’s OK if the sum is less than 500. Modify <code>bget</code> and <code>brelse</code> so that concurrent lookups and releases for different blocks that are in the bcache are unlikely to conflict on locks (e.g., don’t all have to wait for <code>bcache.lock</code>). You must maintain the invariant that at most one copy of each block is cached. When you are done, your output should be similar to that shown below (though not identical). Make sure usertests still passes. <code>make grade</code> should pass all tests when you are done.</p></blockquote><p>锁竞争优化一般有几个思路：</p><ul><li>只在必须共享的时候共享（对应为将资源从 CPU 共享拆分为每个 CPU 独立）</li><li>必须共享时，尽量减少在关键区中停留的时间（对应“大锁化小锁”，降低锁的粒度）</li></ul><p>感觉挺有用的</p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230913225009710.png" alt="image-20230913225009710"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span><br>usertests starting<br>test manywrites: OK<br>test execout: OK<br>test copyin: OK<br>test copyout: OK<br>test copyinstr1: OK<br>test copyinstr2: OK<br>test copyinstr3: OK<br>test rwsbrk: OK<br>test truncate1: OK<br>test truncate2: OK<br>test truncate3: OK<br>test reparent2: OK<br>test pgbug: OK<br>test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3243<br>            sepc=0x00000000000056a4 stval=0x00000000000056a4<br>usertrap(): unexpected scause 0x000000000000000c pid=3244<br>            sepc=0x00000000000056a4 stval=0x00000000000056a4<br>OK<br>test badarg: OK<br>test reparent: OK<br>test twochildren: OK<br>test forkfork: OK<br>test forkforkfork: OK<br>test argptest: OK<br>test createdelete: OK<br>test linkunlink: OK<br>test linktest: OK<br>test unlinkread: OK<br>test concreate: OK<br>test subdir: OK<br>test fourfiles: OK<br>test sharedfd: OK<br>test dirtest: OK<br>test exectest: OK<br>test bigargtest: OK<br>test bigwrite: OK<br>test bsstest: OK<br>test sbrkbasic: OK<br>test sbrkmuch: OK<br>test kernmem: usertrap(): unexpected scause 0x000000000000000d pid=6224<br>            sepc=0x000000000000215c stval=0x0000000080000000<br>usertrap(): unexpected scause 0x000000000000000d pid=6225<br>            sepc=0x000000000000215c stval=0x000000008000c350<br>usertrap(): unexpected scause 0x000000000000000d pid=6226<br>            sepc=0x000000000000215c stval=0x00000000800186a0<br>usertrap(): unexpected scause 0x000000000000000d pid=6227<br>            sepc=0x000000000000215c stval=0x00000000800249f0<br>usertrap(): unexpected scause 0x000000000000000d pid=6228<br>            sepc=0x000000000000215c stval=0x0000000080030d40<br>usertrap(): unexpected scause 0x000000000000000d pid=6229<br>            sepc=0x000000000000215c stval=0x000000008003d090<br>usertrap(): unexpected scause 0x000000000000000d pid=6230<br>            sepc=0x000000000000215c stval=0x00000000800493e0<br>usertrap(): unexpected scause 0x000000000000000d pid=6231<br>            sepc=0x000000000000215c stval=0x0000000080055730<br>usertrap(): unexpected scause 0x000000000000000d pid=6232<br>            sepc=0x000000000000215c stval=0x0000000080061a80<br>usertrap(): unexpected scause 0x000000000000000d pid=6233<br>            sepc=0x000000000000215c stval=0x000000008006ddd0<br>usertrap(): unexpected scause 0x000000000000000d pid=6234<br>            sepc=0x000000000000215c stval=0x000000008007a120<br>usertrap(): unexpected scause 0x000000000000000d pid=6235<br>            sepc=0x000000000000215c stval=0x0000000080086470<br>usertrap(): unexpected scause 0x000000000000000d pid=6236<br>            sepc=0x000000000000215c stval=0x00000000800927c0<br>usertrap(): unexpected scause 0x000000000000000d pid=6237<br>            sepc=0x000000000000215c stval=0x000000008009eb10<br>usertrap(): unexpected scause 0x000000000000000d pid=6238<br>            sepc=0x000000000000215c stval=0x00000000800aae60<br>usertrap(): unexpected scause 0x000000000000000d pid=6239<br>            sepc=0x000000000000215c stval=0x00000000800b71b0<br>usertrap(): unexpected scause 0x000000000000000d pid=6240<br>            sepc=0x000000000000215c stval=0x00000000800c3500<br>usertrap(): unexpected scause 0x000000000000000d pid=6241<br>            sepc=0x000000000000215c stval=0x00000000800cf850<br>usertrap(): unexpected scause 0x000000000000000d pid=6242<br>            sepc=0x000000000000215c stval=0x00000000800dbba0<br>usertrap(): unexpected scause 0x000000000000000d pid=6243<br>            sepc=0x000000000000215c stval=0x00000000800e7ef0<br>usertrap(): unexpected scause 0x000000000000000d pid=6244<br>            sepc=0x000000000000215c stval=0x00000000800f4240<br>usertrap(): unexpected scause 0x000000000000000d pid=6245<br>            sepc=0x000000000000215c stval=0x0000000080100590<br>usertrap(): unexpected scause 0x000000000000000d pid=6246<br>            sepc=0x000000000000215c stval=0x000000008010c8e0<br>usertrap(): unexpected scause 0x000000000000000d pid=6247<br>            sepc=0x000000000000215c stval=0x0000000080118c30<br>usertrap(): unexpected scause 0x000000000000000d pid=6248<br>            sepc=0x000000000000215c stval=0x0000000080124f80<br>usertrap(): unexpected scause 0x000000000000000d pid=6249<br>            sepc=0x000000000000215c stval=0x00000000801312d0<br>usertrap(): unexpected scause 0x000000000000000d pid=6250<br>            sepc=0x000000000000215c stval=0x000000008013d620<br>usertrap(): unexpected scause 0x000000000000000d pid=6251<br>            sepc=0x000000000000215c stval=0x0000000080149970<br>usertrap(): unexpected scause 0x000000000000000d pid=6252<br>            sepc=0x000000000000215c stval=0x0000000080155cc0<br>usertrap(): unexpected scause 0x000000000000000d pid=6253<br>            sepc=0x000000000000215c stval=0x0000000080162010<br>usertrap(): unexpected scause 0x000000000000000d pid=6254<br>            sepc=0x000000000000215c stval=0x000000008016e360<br>usertrap(): unexpected scause 0x000000000000000d pid=6255<br>            sepc=0x000000000000215c stval=0x000000008017a6b0<br>usertrap(): unexpected scause 0x000000000000000d pid=6256<br>            sepc=0x000000000000215c stval=0x0000000080186a00<br>usertrap(): unexpected scause 0x000000000000000d pid=6257<br>            sepc=0x000000000000215c stval=0x0000000080192d50<br>usertrap(): unexpected scause 0x000000000000000d pid=6258<br>            sepc=0x000000000000215c stval=0x000000008019f0a0<br>usertrap(): unexpected scause 0x000000000000000d pid=6259<br>            sepc=0x000000000000215c stval=0x00000000801ab3f0<br>usertrap(): unexpected scause 0x000000000000000d pid=6260<br>            sepc=0x000000000000215c stval=0x00000000801b7740<br>usertrap(): unexpected scause 0x000000000000000d pid=6261<br>            sepc=0x000000000000215c stval=0x00000000801c3a90<br>usertrap(): unexpected scause 0x000000000000000d pid=6262<br>            sepc=0x000000000000215c stval=0x00000000801cfde0<br>usertrap(): unexpected scause 0x000000000000000d pid=6263<br>            sepc=0x000000000000215c stval=0x00000000801dc130<br>OK<br>test sbrkfail: usertrap(): unexpected scause 0x000000000000000d pid=6275<br>            sepc=0x00000000000041fc stval=0x0000000000012000<br>OK<br>test sbrkarg: OK<br>test validatetest: OK<br>test stacktest: usertrap(): unexpected scause 0x000000000000000d pid=6279<br>            sepc=0x00000000000022cc stval=0x000000000000fb90<br>OK<br>test opentest: OK<br>test writetest: OK<br>test writebig: OK<br>test createtest: OK<br>test openiput: OK<br>test exitiput: OK<br>test iput: OK<br>test mem: OK<br>test pipe1: OK<br>test preempt: kill... wait... OK<br>test exitwait: OK<br>test rmdot: OK<br>test fourteen: OK<br>test bigfile: OK<br>test dirfile: OK<br>test iref: OK<br>test forktest: OK<br>test bigdir: OK<br>ALL TESTS PASSED<br></code></pre></td></tr></table></figure><p>这里有个坑点折腾了很久</p><p>如果你make qemu后不make clean，那么你会发现你在xv6终端里可以通过bcachetest，但是退出后make grade 会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">== Test   bcachetest: test0 == <br>  bcachetest: test0: FAIL <br>    ...<br>         tot= 3280<br>         test0: FAIL<br>         start test1<br>         test1 OK<br>         $ qemu-system-riscv64: terminating on signal 15 from pid 9889 (make)<br>    MISSING &#x27;^test0: OK$&#x27;<br></code></pre></td></tr></table></figure><p>所以make grade的时候记得先make clean QAQ</p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230914090136982.png" alt="image-20230914090136982"></p><h2 id="Lab9-file-system"><a href="#Lab9-file-system" class="headerlink" title="Lab9: file system"></a>Lab9: file system</h2><p>（从此题开始持续优化blog的创作流，目前还没有形成一个属于自己的创作体系）</p><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>Before writing code, you should read “Chapter 8: File system” from the <a href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a> and study the corresponding code.</p></blockquote><h3 id="Large-files-moderate"><a href="#Large-files-moderate" class="headerlink" title="Large files (moderate)"></a>Large files (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Modify <code>bmap()</code> so that it implements a doubly-indirect block, in addition to direct blocks and a singly-indirect block. You’ll have to have only 11 direct blocks, rather than 12, to make room for your new doubly-indirect block; you’re not allowed to change the size of an on-disk inode. The first 11 elements of <code>ip-&gt;addrs[]</code> should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block. You are done with this exercise when <code>bigfile</code> writes 65803 blocks and <code>usertests</code> runs successfully:</p></blockquote><p>第一个要你实现二级链接块，我一开始没理解到题目意思，理解了二级链接块的概念后，这题就很快了</p><p>他是每一个bn对应一个块</p><p>也就是说如果是直接块，那么久可以直接读取 0–10块</p><p>如果是间接块，一级间接块在11块</p><p>二级间接块在12块</p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230915074742194.png" alt="image-20230915074742194"></p><p>对于1级间接块，代码中已经给出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//如果大于等于11，说明是一级间接块</span><br>   bn -= NDIRECT;<br>   <span class="hljs-keyword">if</span> (bn &lt; NINDIRECT) &#123;<br>       <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>       <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>           ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>       bp = bread(ip-&gt;dev, addr);   <span class="hljs-comment">//文件载入</span><br>       a = (uint *) bp-&gt;data;<br>       <span class="hljs-keyword">if</span> ((addr = a[bn]) == <span class="hljs-number">0</span>) &#123;<br>           a[bn] = addr = balloc(ip-&gt;dev);<br>           log_write(bp);<br>       &#125;<br>       brelse(bp);<br>       <span class="hljs-keyword">return</span> addr;<br>   &#125;<br></code></pre></td></tr></table></figure><p>二级间接块 ，之前看到一个csdn讲二级链接块概念的blog，里面有章图很形象，但没找到，这边就手动绘制一下（有点丑，见谅QAQ）</p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230915075928178.png" alt="img"></p><p>由图可知，我们需要先从块缓存中载入一级索引表，用bn&#x2F;NINDIRECT找到所在的二级索引表的index，最后载入对应的二级索引表，根据bn%NINDIRECT,可以确定实际块的位置，总之理解到了的话就是复制粘贴一级索引块的处理方式，让他多载入几次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">bmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint bn)</span> &#123;<br>    uint addr, *a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>    <span class="hljs-keyword">if</span> (bn &lt; NDIRECT) &#123;  <span class="hljs-comment">// 如果bn是小于11的， 处理直接块</span><br>        <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>            ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>        <span class="hljs-keyword">return</span> addr;<br>    &#125;<br>    <span class="hljs-comment">//如果大于等于11，说明是一级间接块</span><br>    bn -= NDIRECT;<br>    <span class="hljs-keyword">if</span> (bn &lt; NINDIRECT) &#123;<br>        <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>        <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>            ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>        bp = bread(ip-&gt;dev, addr);   <span class="hljs-comment">//文件载入</span><br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">if</span> ((addr = a[bn]) == <span class="hljs-number">0</span>) &#123;<br>            a[bn] = addr = balloc(ip-&gt;dev);<br>            log_write(bp);<br>        &#125;<br>        brelse(bp);<br>        <span class="hljs-keyword">return</span> addr;<br>    &#125;<br>    bn -= NINDIRECT;     <span class="hljs-comment">//剪前11块，和一级间接地址的256块减掉，就是2级间接块的地址</span><br><br>    <span class="hljs-keyword">if</span> (bn &lt; NINDIRECT * NINDIRECT) &#123;<br>        <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>        <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>)<br>            ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>] = addr = balloc(ip-&gt;dev);<br>        bp = bread(ip-&gt;dev, addr);   <span class="hljs-comment">//文件载入   256个2级索引表载入</span><br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">if</span> ((addr = a[bn / NINDIRECT]) == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//最终指向的索引块载入</span><br>            a[bn / NINDIRECT] = addr = balloc(ip-&gt;dev);<br>            log_write(bp);<br>        &#125;<br>        brelse(bp);<br>        <span class="hljs-comment">//块中对应的地址载入</span><br>        <span class="hljs-type">int</span> index = bn % NINDIRECT; <span class="hljs-comment">//确定在块中的位置</span><br>        bp = bread(ip-&gt;dev, addr);   <span class="hljs-comment">//文件载入   256个2级索引表载入</span><br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">if</span> ((addr = a[index]) == <span class="hljs-number">0</span>) &#123;<br>            a[index] = addr = balloc(ip-&gt;dev);<br>            log_write(bp);<br>        &#125;<br>        brelse(bp);<br>        <span class="hljs-keyword">return</span> addr;<br>    &#125;<br><br>    panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>理解到位后，释放也是差不多的原理，也可以说是可以复制粘贴吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Truncate inode (discard contents).</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">itrunc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span> &#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span> ,*<span class="hljs-title">bp1</span>;</span><br>    uint *a, *b;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NDIRECT; i++) &#123;  <span class="hljs-comment">// direct blocks</span><br>        <span class="hljs-keyword">if</span> (ip-&gt;addrs[i]) &#123;<br>            bfree(ip-&gt;dev, ip-&gt;addrs[i]);<br>            ip-&gt;addrs[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ip-&gt;addrs[NDIRECT]) &#123;   <span class="hljs-comment">//indirect block</span><br>        bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[j])<br>                bfree(ip-&gt;dev, a[j]);<br>        &#125;<br>        brelse(bp);<br>        bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>        ip-&gt;addrs[NDIRECT] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]) &#123;   <span class="hljs-comment">// second indirect block</span><br>        bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]);<br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++) &#123;<br>            <span class="hljs-keyword">if</span>(a[j])&#123;<br>                bp1 = bread(ip-&gt;dev, a[j]);<br>                b = (uint *) bp1-&gt;data;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; NINDIRECT; ++k) &#123;<br>                    <span class="hljs-keyword">if</span> (b[k])<br>                        bfree(ip-&gt;dev, b[k]);<br>                &#125;<br>                brelse(bp1);<br>                bfree(ip-&gt;dev, a[j]);<br>            &#125;<br>        &#125;<br>        brelse(bp);<br>        bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]);<br>        ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    ip-&gt;size = <span class="hljs-number">0</span>;<br>    iupdate(ip);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230914211707841.png" alt="image-20230914211707841"></p><h3 id="Symbolic-links-moderate"><a href="#Symbolic-links-moderate" class="headerlink" title="Symbolic links (moderate)"></a>Symbolic links (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>You will implement the <code>symlink(char *target, char *path)</code> system call, which creates a new symbolic link at path that refers to file named by target. For further information, see the man page symlink. To test, add symlinktest to the Makefile and run it. Your solution is complete when the tests produce the following output (including usertests succeeding).</p></blockquote><p>这题比较简单，当时也比较晚了快11点图书馆闭馆了，我就直接看大佬的博客了，理解到了概念就很简单</p><p>理解可以参考这篇文章 <a href="https://blog.csdn.net/Csw_PHPer/article/details/106684375">https://blog.csdn.net/Csw_PHPer/article/details/106684375</a></p><p>个人感觉把软链接讲的很清楚了</p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230914225252339.png" alt="image-20230914225252339"></p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230915103108823.png" alt="image-20230915103108823"></p><h2 id="Lab10-mmap-hard"><a href="#Lab10-mmap-hard" class="headerlink" title="Lab10: mmap (hard)"></a>Lab10: mmap (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h2><blockquote><p>You should implement enough <code>mmap</code> and <code>munmap</code> functionality to make the <code>mmaptest</code> test program work. If <code>mmaptest</code> doesn’t use a <code>mmap</code> feature, you don’t need to implement that feature.</p></blockquote><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><p>9.17  mit6.s081就算是正式完结了，network要看很多手册，而且我看了下其他做完了的博客也并不是很难，这里就先不做了</p><p>然后mmap还是有难度的，花了我大概10个小时左右的时间吧（虽然在前一天花了一晚上调bug，太菜了QAQ)</p><p>先是sys_mmap的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">sys_mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr, sz, offset;<br>    <span class="hljs-type">int</span> prot, flags, fd; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>    uint64 end  =  TRAPFRAME;<br>    <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;sz) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;prot) &lt; <span class="hljs-number">0</span><br>       || argint(<span class="hljs-number">3</span>, &amp;flags) &lt; <span class="hljs-number">0</span> || argfd(<span class="hljs-number">4</span>, &amp;fd, &amp;f) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">5</span>, &amp;offset) &lt; <span class="hljs-number">0</span> || sz == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span>(!f-&gt;writable &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; (flags == MAP_SHARED))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; VMASIZE; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">0</span>)<br>        &#123;<br>            j=i;<br>            p-&gt;vmas[i].valid = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// important!</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            end = PGROUNDDOWN(p-&gt;vmas[i].vastart);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span>* <span class="hljs-title">v</span> =</span> &amp;p-&gt;vmas[j];<br>    sz = PGROUNDUP(sz);     <span class="hljs-comment">//注意对齐</span><br><br><br>    v-&gt;vastart = end - sz;<br>    v-&gt;sz = sz;<br>    v-&gt;prot = prot;<br>    v-&gt;flags = flags;<br>    v-&gt;f = f;<br>    v-&gt;offset = offset;<br><br>    filedup(v-&gt;f);<br><br>    <span class="hljs-keyword">return</span> v-&gt;vastart;<br>&#125;<br></code></pre></td></tr></table></figure><p>前一天晚上调了很久就是因为有些细节没处理好</p><p>这里一定要  end &#x3D; PGROUNDDOWN(p-&gt;vmas[i].vastart)，因为test中所有的mmap的addr都是从0开始的，一定要记得更新end，不然test mmap two files 会过不去</p><p>加了更新end的分支后一定要记得加break，不然第二个就过不去了（全部vma都被设置成了1在第一个测试点中）</p><p>最后不要忘了sz &#x3D; PGROUNDUP(sz); 内存对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">0</span>)<br>      &#123;<br>          j=i;<br>          p-&gt;vmas[i].valid = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// important!</span><br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          end = PGROUNDDOWN(p-&gt;vmas[i].vastart);<br>      &#125;<br></code></pre></td></tr></table></figure><p>因为是lazy allocation，所以要在usertrap中进行修改处理page fault，这个和之前做过的实验差不多，这里就不多讲了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);<br><br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),</span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.</span><br>  w_stvec((uint64)kernelvec);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <br>  <span class="hljs-comment">// save user program counter.</span><br>  p-&gt;trapframe-&gt;epc = r_sepc();<br>  <br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br><br>    <span class="hljs-keyword">if</span>(p-&gt;killed)<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// sepc points to the ecall instruction,</span><br>    <span class="hljs-comment">// but we want to return to the next instruction.</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,</span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.</span><br>    intr_on();<br><br>    syscall();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span>  (r_scause()==<span class="hljs-number">13</span>||r_scause()==<span class="hljs-number">15</span>)&#123;<br>          uint64 va = r_stval();<br>          <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span>* <span class="hljs-title">v</span> =</span> <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; VMASIZE; ++i) &#123;<br>              <span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; va &gt;= p-&gt;vmas[i].vastart &amp;&amp; va &lt; p-&gt;vmas[i].vastart + p-&gt;vmas[i].sz) &#123;<br>                 v=&amp;p-&gt;vmas[i];<br>              &#125;<br>          &#125;<br><br>          <span class="hljs-keyword">if</span>(v==<span class="hljs-number">0</span>)&#123;<br>              p-&gt;killed=<span class="hljs-number">1</span>;<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>              <span class="hljs-type">void</span> *pa = kalloc();<br>              <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>) &#123;<br>                  panic(<span class="hljs-string">&quot;vmalazytouch: kalloc&quot;</span>);<br>              &#125;<br>              <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">0</span>, PGSIZE);<br>              begin_op();<br>              ilock(v-&gt;f-&gt;ip);<br>              readi(v-&gt;f-&gt;ip, <span class="hljs-number">0</span>, (uint64)pa, v-&gt;offset + PGROUNDDOWN(va - v-&gt;vastart), PGSIZE);<br>              iunlock(v-&gt;f-&gt;ip);<br>              end_op();<br><br>              <span class="hljs-type">int</span> perm = PTE_U;<br>              <span class="hljs-keyword">if</span>(v-&gt;prot &amp; PROT_READ)<br>                  perm |= PTE_R;<br>              <span class="hljs-keyword">if</span>(v-&gt;prot &amp; PROT_WRITE)<br>                  perm |= PTE_W;<br>              <span class="hljs-keyword">if</span>(v-&gt;prot &amp; PROT_EXEC)<br>                  perm |= PTE_X;<br><br>              <span class="hljs-keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, (uint64)pa, perm) &lt; <span class="hljs-number">0</span>) &#123;<br>                  panic(<span class="hljs-string">&quot;vmalazytouch: mappages&quot;</span>);<br>              &#125;<br><br>          &#125;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>          p-&gt;killed = <span class="hljs-number">1</span>;<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(p-&gt;killed)<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    yield();<br><br>  usertrapret();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是munmap ，这里为了方便，就直接使用页为单位来进行解除映射（可以直接使用uvmmap，偷个懒），如果sz为0了记得取消引用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">sys_munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr, sz;<br><br>    <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;sz) &lt; <span class="hljs-number">0</span> || sz == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span>* <span class="hljs-title">v</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; VMASIZE; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; addr &gt;= p-&gt;vmas[i].vastart &amp;&amp; addr &lt; p-&gt;vmas[i].vastart + p-&gt;vmas[i].sz) &#123;<br>            v=&amp;p-&gt;vmas[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(v == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(v-&gt;flags &amp; MAP_SHARED)&#123;<br>        filewrite(v-&gt;f, addr, sz);<br>    &#125;<br><br>    uvmunmap(p-&gt;pagetable, addr, PGROUNDUP(sz) / PGSIZE, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(addr == v-&gt;vastart)&#123;<br>       v-&gt;vastart += PGROUNDUP(sz);<br>    &#125;<br>    v-&gt;sz -= sz;<br>    <span class="hljs-keyword">if</span>(v-&gt;sz == <span class="hljs-number">0</span>)<br>    &#123;<br>        fileclose(v-&gt;f);<br>        <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)v, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(v));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>到此就已经可以通过mmap_test了</p><p>最后对fork和exit进行简单修改即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  np-&gt;parent = p;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; VMASIZE; i++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">v</span> =</span> &amp;p-&gt;vmas[i];<br>        <span class="hljs-keyword">if</span>(v-&gt;valid) &#123;<br>            np-&gt;vmas[i] = *v;<br>            filedup(v-&gt;f);<br>        &#125;<br>    &#125;<br><br><br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  np-&gt;state = RUNNABLE;<br><br>  release(&amp;np-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span>(p == initproc)<br>    panic(<span class="hljs-string">&quot;init exiting&quot;</span>);<br><br>  <span class="hljs-comment">// Close all open files.</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>; fd &lt; NOFILE; fd++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[fd])&#123;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span> =</span> p-&gt;ofile[fd];<br>      fileclose(f);<br>      p-&gt;ofile[fd] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; VMASIZE; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">1</span>)<br>        &#123;<br>            uint64 sz = p-&gt;vmas[i].sz;<br>            fileclose(p-&gt;vmas[i].f);<br>            <span class="hljs-comment">// 取消映射</span><br>            uvmunmap(p-&gt;pagetable, p-&gt;vmas[i].vastart, PGROUNDUP(sz) / PGSIZE, <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 清空vma</span><br>            <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)&amp;p-&gt;vmas[i], <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;vmas[i]));<br><br>        &#125;<br>    &#125;<br><br><br> ......<br>&#125;<br></code></pre></td></tr></table></figure><p>在make grade的时候可能会遇到env: python3\r: No such file or directory 的问题</p><p>vim打开 lab-mmap脚本,输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">:set ff=unix<br>:wq!<br></code></pre></td></tr></table></figure><p>即可解决问题   <a href="https://code84.com/79.html">env: python3\r</a></p><p>通过测试如下图</p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230917083149756.png" alt="image-20230917083149756"></p><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-S081实验记录.assets\image-20230917085710821.png" alt="image-20230917085710821"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大概花了两个星期吧做完lab0-lab10 ，个人感觉印象深刻是lab3，lab8，和lab10吧，lab8最后一个实验我是看着大佬的博客来写的，确实水平还不够</p><p>在这个实验的后半部分开始慢慢优化我的blog写作，还是希望自己的blog能够有能帮助大家的东西，慢慢来吧</p><p>个人感觉还是很有收获的，但是感觉对于学习os来说还远远不够，比如说作为教学os的xv6一个进程只有一个线程等等，很多地方都简化了</p><p>但作为一门导论课来说还是非常有含金量的，整顿一下明天开二周目了</p><p>有机会我想开一个读论文的坑了，后面有时间再说吧 </p><p>到这里就完结了，下个坑再见， bye ~</p>]]></content>
    
    
    <categories>
      
      <category>MIT6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.S081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs144-lab0~lab7</title>
    <link href="/2023/08/12/cs144-lab0-lab7/"/>
    <url>/2023/08/12/cs144-lab0-lab7/</url>
    
    <content type="html"><![CDATA[<p>lab0-lab5 code：<a href="https://github.com/MadFrey/minnow">MadFrey&#x2F;minnow (github.com)</a></p><p>lab6和lab7自行测试</p><p>历时大概两个星期，八月中旬到八月底，期间还有段时间没花在这上面</p><p>整体感觉下来lab1和lab3难度较高，其他的根据pdf的描述再加上自己去了解一下原理，都不难写</p><h2 id="lab-0"><a href="#lab-0" class="headerlink" title="lab 0"></a>lab 0</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@hecs-271160 ~]# telnet cs144.keithw.org http<br>Trying 104.196.238.229...<br>Connected to cs144.keithw.org.<br>Escape character is &#x27;^]&#x27;.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">telnet&gt; </span><span class="language-bash"></span><br><span class="language-bash">GET /hello HTTP/1.1</span><br>Host: cs144.keithw.org<br><br>HTTP/1.1 200 OK<br>Date: Sat, 12 Aug 2023 15:07:45 GMT<br>Server: Apache<br>Last-Modified: Thu, 13 Dec 2018 15:45:29 GMT<br>ETag: &quot;e-57ce93446cb64&quot;<br>Accept-Ranges: bytes<br>Content-Length: 14<br>Content-Type: text/plain<br><br>Hello, CS144!<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hecs-271160 ~]# telnet cs144.keithw.org http<br>Trying 104.196.238.229...<br>Connected to cs144.keithw.org.<br>Escape character is &#x27;^]&#x27;.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">telnet&gt; </span><span class="language-bash"></span><br><span class="language-bash">GET /lab0/MadFrey HTTP/1.1</span>    <br>Host: cs144.keithw.org<br><br>HTTP/1.1 200 OK<br>Date: Sat, 12 Aug 2023 15:13:12 GMT<br>Server: Apache<br>X-You-Said-Your-SunetID-Was: MadFrey<br>X-Your-Code-Is: 794944<br>Content-length: 111<br>Vary: Accept-Encoding<br>Content-Type: text/plain<br><br>Hello! You told us that your SUNet ID was &quot;MadFrey&quot;. Please see the HTTP headers (above) for your secret code.<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hecs-271160 etc]# telnet localhost 9090<br>Trying ::1...<br>telnet: connect to address ::1: Connection refused<br>Trying 127.0.0.1...<br>Connected to localhost.<br>Escape character is &#x27;^]&#x27;.<br>11111<br>3243435<br>MadFrey <br>^CConnection closed by foreign host.<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hecs-271160 netcat-0.7.1]# netcat -u 127.0.0.1 8004<br>^C[root@hecs-271160 netcat-0.7.1]# netcat -v -l -p 9090<br>Connection from 127.0.0.1:34572<br>11111<br>3243435<br>MadFrey<br>Exiting.<br>[root@hecs-271160 netcat-0.7.1]# <br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">( <span class="hljs-type">const</span> string&amp; host, <span class="hljs-type">const</span> string&amp; path )</span></span><br><span class="hljs-function"></span>&#123;<br>  TCPSocket socket;<br>  socket.<span class="hljs-built_in">connect</span>( <span class="hljs-built_in">Address</span>( host, <span class="hljs-string">&quot;http&quot;</span> ) );<br>  socket.<span class="hljs-built_in">write</span>( <span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\nHost: &quot;</span> + host + <span class="hljs-string">&quot;\r\nConnection: close\r\n\r\n&quot;</span> );<br><br>  <span class="hljs-keyword">while</span> ( !socket.<span class="hljs-built_in">eof</span>() ) &#123;<br>    std::string buffers;<br>    socket.<span class="hljs-built_in">read</span>( buffers );<br>    cout &lt;&lt; buffers;<br>  &#125;<br>  socket.<span class="hljs-built_in">close</span>();<br>  cerr &lt;&lt; <span class="hljs-string">&quot;Function called: get_URL(&quot;</span> &lt;&lt; host &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>  cerr &lt;&lt; <span class="hljs-string">&quot;Warning: get_URL() has not been implemented yet.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230901135240852.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230817174534608.png" alt="img"></p><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p>自己先用优先队列写了一遍，发现代码过于复杂，并且时间复杂度太高了，测试点超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;reassembler.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reassembler::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> closed_ &amp;&amp; <span class="hljs-built_in">bytes_pending</span>() == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reassembler::insert</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> first_index, string data, <span class="hljs-type">bool</span> is_last_substring, Writer&amp; output )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// Your code here.</span><br>  <span class="hljs-keyword">if</span> ( is_last_substring ) &#123;<br>    closed_ = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// important!</span><br>  <span class="hljs-keyword">if</span> ( first_index &gt;= unassembled_index + output.<span class="hljs-built_in">available_capacity</span>() || <span class="hljs-comment">/* Out of bound */</span><br>       first_index + data.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> &lt; unassembled_index ||            <span class="hljs-comment">/* Data have been transferred */</span><br>       data.<span class="hljs-built_in">empty</span>() || output.<span class="hljs-built_in">available_capacity</span>() == <span class="hljs-number">0</span> ) &#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">is_closed</span>() ) &#123;<br>      output.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ( first_index &lt; unassembled_index ) &#123;<br>    <span class="hljs-comment">// overlap</span><br>    <span class="hljs-keyword">if</span> ( first_index + data.<span class="hljs-built_in">size</span>() &gt; unassembled_index ) &#123;<br>      <span class="hljs-comment">// overlap</span><br>      <span class="hljs-type">size_t</span> overlap = unassembled_index - first_index;<br>      <span class="hljs-type">size_t</span> new_data_size = data.<span class="hljs-built_in">size</span>() - overlap;<br>      string new_data = data.<span class="hljs-built_in">substr</span>( overlap, new_data_size );<br>      output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>( new_data );<br>      unassembled_index += new_data_size;<br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( first_index == unassembled_index ) &#123;<br>    <span class="hljs-comment">// no overlap, 要进行cap比较</span><br>    <span class="hljs-type">uint64_t</span> cap = output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-keyword">if</span> ( data.<span class="hljs-built_in">size</span>() &gt; cap ) &#123;<br>      <span class="hljs-comment">// cap不够</span><br>      <span class="hljs-type">size_t</span> new_data_size = cap;<br>      string new_data = data.<span class="hljs-built_in">substr</span>( <span class="hljs-number">0</span>, new_data_size );<br>      output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>( new_data );<br>      unassembled_index += new_data_size;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// cap够</span><br>      output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>( data );<br>      unassembled_index += data.<span class="hljs-built_in">size</span>();<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 使用priority queue来存储碎片</span><br>    <span class="hljs-keyword">if</span> ( q.<span class="hljs-built_in">empty</span>() ) &#123;<br>      q.<span class="hljs-built_in">push</span>( <span class="hljs-built_in">make_pair</span>( first_index, data ) );<br>      unassembled_bytes_ += data.<span class="hljs-built_in">size</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        &#125;<br><br>    <span class="hljs-keyword">while</span> ( !q.<span class="hljs-built_in">empty</span>() ) &#123;<br>      <span class="hljs-type">uint64_t</span> new_index = q.<span class="hljs-built_in">top</span>().first;<br>      std::string new_data = q.<span class="hljs-built_in">top</span>().second;<br>      q.<span class="hljs-built_in">pop</span>();<br>      unassembled_bytes_ -= new_data.<span class="hljs-built_in">size</span>();<br>      <span class="hljs-keyword">if</span> ( q.<span class="hljs-built_in">empty</span>() ) &#123;<br>        q.<span class="hljs-built_in">push</span>( <span class="hljs-built_in">make_pair</span>( new_index, new_data ) );<br>        unassembled_bytes_ += new_data.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">uint64_t</span> new_index2 = q.<span class="hljs-built_in">top</span>().first;<br>        std::string new_data2 = q.<span class="hljs-built_in">top</span>().second;<br>        <span class="hljs-keyword">if</span> ( new_index &lt;= new_index2 ) &#123;<br>          <span class="hljs-type">size_t</span> overlap = new_index + new_data.<span class="hljs-built_in">size</span>() - new_index2;<br>          <span class="hljs-keyword">if</span> ( overlap &gt;= new_data.<span class="hljs-built_in">size</span>() ) &#123;<br>            q.<span class="hljs-built_in">pop</span>();<br>            unassembled_bytes_ -= new_data2.<span class="hljs-built_in">size</span>();<br>            q.<span class="hljs-built_in">push</span>( <span class="hljs-built_in">make_pair</span>( new_index, new_data ) );<br>            unassembled_bytes_ += new_data.<span class="hljs-built_in">size</span>();<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// overlap</span><br>            std::string substr = new_data.<span class="hljs-built_in">substr</span>( <span class="hljs-number">0</span>, new_index2 - new_index )<br>                                 + new_data2.<span class="hljs-built_in">substr</span>( overlap, new_data2.<span class="hljs-built_in">size</span>() - overlap );<br>            q.<span class="hljs-built_in">pop</span>();<br>            unassembled_bytes_ -= new_data2.<span class="hljs-built_in">size</span>();<br>            q.<span class="hljs-built_in">push</span>( <span class="hljs-built_in">make_pair</span>( first_index, substr ) );<br>            unassembled_bytes_ += substr.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 循环</span><br>  <span class="hljs-keyword">while</span> ( !q.<span class="hljs-built_in">empty</span>() ) &#123;<br>    <span class="hljs-type">uint64_t</span> new_index = q.<span class="hljs-built_in">top</span>().first;<br>    std::string new_data = q.<span class="hljs-built_in">top</span>().second;<br>    <span class="hljs-type">uint64_t</span> cap = output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-keyword">if</span> ( new_index &lt;= unassembled_index ) &#123;<br>      <span class="hljs-comment">// overlap</span><br>      <span class="hljs-keyword">if</span> ( new_index + new_data.<span class="hljs-built_in">size</span>() &gt; unassembled_index ) &#123;<br>        <span class="hljs-comment">// overlap</span><br>        <span class="hljs-type">size_t</span> overlap = unassembled_index - new_index;<br>        <span class="hljs-type">size_t</span> new_data_size = <span class="hljs-built_in">min</span>( new_data.<span class="hljs-built_in">size</span>() - overlap, cap );<br>        string new_data_2 = new_data.<span class="hljs-built_in">substr</span>( overlap, new_data_size );<br>        output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>( new_data_2 );<br>        unassembled_index += new_data_size;<br>        unassembled_bytes_ -= data.<span class="hljs-built_in">size</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// no overlap</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        unassembled_bytes_ -= new_data.<span class="hljs-built_in">size</span>();<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( new_index &gt; unassembled_index ) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">is_closed</span>() ) &#123; <span class="hljs-comment">// important!</span><br>    output.<span class="hljs-built_in">close</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reassembler::bytes_pending</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// Your code here.</span><br>  <span class="hljs-keyword">return</span> unassembled_bytes_;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>改用map后第14个测试点超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;reassembler.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reassembler::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> closed_ &amp;&amp; <span class="hljs-built_in">bytes_pending</span>() == <span class="hljs-number">0</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reassembler::insert</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> first_index, string data, <span class="hljs-type">bool</span> is_last_substring, Writer &amp;output)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (is_last_substring) &#123;<br>        closed_ = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Remember index_ points to where the current byte located at.</span><br>    <span class="hljs-comment">// 1. Unacceptable index: first_index overwhelms the capability range.</span><br>    <span class="hljs-comment">// 2. All overlapped: The end index of the substring is smaller than current index_.</span><br>    <span class="hljs-comment">// 3. data is empty.</span><br>    <span class="hljs-comment">// 4. No available space.</span><br>    <span class="hljs-keyword">if</span> (first_index &gt;= unassembled_index_ + output.<span class="hljs-built_in">available_capacity</span>() || <span class="hljs-comment">/* Out of bound */</span><br>        first_index + data.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> &lt; unassembled_index_ ||            <span class="hljs-comment">/* Data have been transferred */</span><br>        data.<span class="hljs-built_in">empty</span>() || output.<span class="hljs-built_in">available_capacity</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_closed</span>()) &#123;<br>            output.<span class="hljs-built_in">close</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> cap = output.<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-comment">// new_index actually distinguish where the current data start, the start index</span><br>    <span class="hljs-type">uint64_t</span> new_index = first_index;<br><br>    <span class="hljs-comment">// Data needs to fit the capability limitation</span><br>    <span class="hljs-keyword">if</span> (first_index &lt;= unassembled_index_) &#123;<br>        new_index = unassembled_index_;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> overlapped_length = unassembled_index_ - first_index;<br>        data = data.<span class="hljs-built_in">substr</span>(overlapped_length, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>() - overlapped_length, cap));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>(), cap));<br>        <span class="hljs-keyword">if</span> (first_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt; unassembled_index_ + cap - <span class="hljs-number">1</span>) &#123;<br>            data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, unassembled_index_ + cap - first_index);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Get the rear substring and merge the overlapped part</span><br>    <span class="hljs-keyword">auto</span> rear_iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(new_index);<br>    <span class="hljs-keyword">while</span> (rear_iter != unassembled_substrings_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[rear_index, rear_data] = *rear_iter;<br>        <span class="hljs-keyword">if</span> (new_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; rear_index) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-comment">// No overlap conflict</span><br>        <span class="hljs-type">uint64_t</span> rear_overlapped_length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (new_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; rear_index + rear_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            rear_overlapped_length = new_index + data.<span class="hljs-built_in">size</span>() - rear_index;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rear_overlapped_length = rear_data.<span class="hljs-built_in">size</span>();<br>        &#125;<br>        <span class="hljs-comment">// Prepare for next rear early, because the data may be erased afterwards.</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> next_rear = rear_index + rear_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (rear_overlapped_length == rear_data.<span class="hljs-built_in">size</span>()) &#123;<br>            unassembled_bytes_ -= rear_data.<span class="hljs-built_in">size</span>();<br>            unassembled_substrings_.<span class="hljs-built_in">erase</span>(rear_index);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// We don&#x27;t combine current data and rear data.</span><br>            <span class="hljs-comment">// Erase the overlapped part in current data is more efficient.</span><br>            data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">end</span>() - <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(rear_overlapped_length), data.<span class="hljs-built_in">end</span>());<br>        &#125;<br>        rear_iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(next_rear);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (first_index &gt; unassembled_index_) &#123;<br>        <span class="hljs-keyword">auto</span> front_iter = unassembled_substrings_.<span class="hljs-built_in">upper_bound</span>(new_index);<br>        <span class="hljs-keyword">if</span> (front_iter != unassembled_substrings_.<span class="hljs-built_in">begin</span>()) &#123;<br>            front_iter--;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[front_index, front_data] = *front_iter;<br>            <span class="hljs-keyword">if</span> (front_index + front_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt;= first_index) &#123;<br>                <span class="hljs-type">uint64_t</span> overlapped_length = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (front_index + front_data.<span class="hljs-built_in">size</span>() &lt;= first_index + data.<span class="hljs-built_in">size</span>()) &#123;<br>                    overlapped_length = front_index + front_data.<span class="hljs-built_in">size</span>() - first_index;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    overlapped_length = data.<span class="hljs-built_in">size</span>();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (overlapped_length == front_data.<span class="hljs-built_in">size</span>()) &#123;<br>                    unassembled_bytes_ -= front_data.<span class="hljs-built_in">size</span>();<br>                    unassembled_substrings_.<span class="hljs-built_in">erase</span>(front_index);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">begin</span>() + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(overlapped_length));<br>                    <span class="hljs-comment">// Don&#x27;t forget to update the inserted location</span><br>                    new_index = first_index + overlapped_length;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If the processed data is empty, no need to insert it.</span><br>    <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        unassembled_bytes_ += data.<span class="hljs-built_in">size</span>();<br>        unassembled_substrings_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_index, std::<span class="hljs-built_in">move</span>(data)));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = unassembled_substrings_.<span class="hljs-built_in">begin</span>(); iter != unassembled_substrings_.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">/* nop */</span>) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[sub_index, sub_data] = *iter;<br>        <span class="hljs-keyword">if</span> (sub_index == unassembled_index_) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> prev_bytes_pushed = output.<span class="hljs-built_in">bytes_pushed</span>();<br>            output.<span class="hljs-built_in">push</span>(sub_data);<br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> bytes_pushed = output.<span class="hljs-built_in">bytes_pushed</span>();<br>            <span class="hljs-keyword">if</span> (bytes_pushed != prev_bytes_pushed + sub_data.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-comment">// Cannot push all data, we need to reserve the un-pushed part.</span><br>                <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> pushed_length = bytes_pushed - prev_bytes_pushed;<br>                unassembled_index_ += pushed_length;<br>                unassembled_bytes_ -= pushed_length;<br>                unassembled_substrings_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(unassembled_index_, sub_data.<span class="hljs-built_in">substr</span>(pushed_length)));<br>                <span class="hljs-comment">// Don&#x27;t forget to remove the previous incompletely transferred data</span><br>                unassembled_substrings_.<span class="hljs-built_in">erase</span>(sub_index);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            unassembled_index_ += sub_data.<span class="hljs-built_in">size</span>();<br>            unassembled_bytes_ -= sub_data.<span class="hljs-built_in">size</span>();<br>            unassembled_substrings_.<span class="hljs-built_in">erase</span>(sub_index);<br>            iter = unassembled_substrings_.<span class="hljs-built_in">find</span>(unassembled_index_);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// No need to do more. Data has been discontinuous.</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_closed</span>()) &#123;<br>        output.<span class="hljs-built_in">close</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reassembler::bytes_pending</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> unassembled_bytes_; &#125;<br></code></pre></td></tr></table></figure><p>最后还是直接参考了大佬的代码，因为花在lab1上的时间太久了</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230819181925740.png"></p><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230819181854325.png"></p><h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230827203700808.png"></p><h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><p>实现ARP，这节实验开始难度骤降</p><p>参考博客：<a href="https://www.cnblogs.com/chenshengkai/p/13936532.html">ARP报文结构</a>      <a href="https://akaedu.github.io/book/ch36s03.html">ARP</a></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230830223804712.png"></p><h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><p>这节要求实现基于最长前缀匹配规则的路由器转发功能，基本没有难度 </p><p>没有复杂度要求，就直接用vector了，方便一点</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230901111001853.png"></p>]]></content>
    
    
    <categories>
      
      <category>lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重新建站后的第一篇博客</title>
    <link href="/2023/07/29/%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%99%E5%90%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/07/29/%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%99%E5%90%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>​这已经是第二次搭建博客了，距离上一次搭建自己的博客已经有一年多了。之前在大一的时候用的typecho在自己服务器上搭的，主要也是记录的一些算法相关的东西。由于各种因素影响，最后还是放弃了之前的博客，选择重新搭建。</p><p>​这次搭博客，主要还是想要记录一下个人觉得比较有意思的事，发表发表观点，其次是技术方面会写一些有技术深度和广度的博客，做CSDN,掘金搬运工就太没意思了。（这也是放弃之前的博客的原因之一吧）然后写写大学阶段的年度总结吧。总之，写博客是我对于自己所学内容的一种内容输出，也是这次想要重新搭建博客的主要原因。</p><p>​只能说写博客确实挺费时间的，想要坚持一直下去确实有一定难度，但时间挤一挤还是会有的。嗯，大概就这些吧。</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
