<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅入嵌入式开发</title>
    <link href="/2023/12/18/%E6%B5%85%E5%85%A5%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    <url>/2023/12/18/%E6%B5%85%E5%85%A5%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="浅入嵌入式开发"><a href="#浅入嵌入式开发" class="headerlink" title="浅入嵌入式开发"></a>浅入嵌入式开发</h1><p>周天开始做，周一中午搞完，大概花了一天时间搞完了嵌入式大作业，还算 简单，一个是我是在windows下用的wsl进行的开发，做下来感觉效率没有直接在linux系统下开发快，第二个就是qemu，buildroot等工具都是第一次用，解决相关的问题确实花了我不少时间,比如linux我就下了两个版本的源代码，有一个高版本的内核代码编译不起，换低版本的就编译过了，我也不知道是什么原因&gt;_&lt;</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">qemu  <span class="hljs-regexp">//</span>apt直接安装<br>u-boot ： git clone https:<span class="hljs-regexp">//gi</span>tlab.denx.de<span class="hljs-regexp">/u-boot/u</span>-boot.git<br>Buildroot  ： git clone git:<span class="hljs-regexp">//gi</span>t.buildroot.net/buildroot<br><span class="hljs-regexp">//</span>最后我又用busybox做了一个  : http:<span class="hljs-regexp">//</span>www.busybox.net/<br>linux 源码 version ： <span class="hljs-number">4.14</span>.<span class="hljs-number">333</span><br>NFS  <span class="hljs-regexp">//</span>apt直接安装<br></code></pre></td></tr></table></figure><h2 id="u-boot-linux源码编译"><a href="#u-boot-linux源码编译" class="headerlink" title="u-boot &amp; linux源码编译"></a>u-boot &amp; linux源码编译</h2><p>u-boot的制作，还有Linux源代码的编译我都是看的这篇博客（用buildroot制作根文件系统也可以参考，但我没用）：<a href="https://blog.51cto.com/u_15315240/3237851">Linux利器：QEMU！用它模拟开发板能替代真开发板？_51CTO博客_qemu模拟开发板</a></p><h2 id="根文件系统制作"><a href="#根文件系统制作" class="headerlink" title="根文件系统制作"></a>根文件系统制作</h2><p>根文件系统的制作我使用的是busybox</p><p>编译时记得修改ARCH &#x3D; arm，和CROSS_COMPILE</p><p>在Busybox Setting—&gt;Build Opdions–&gt;选择[ ]Build BusyBox as a static binary (no shared libs)使用静态编译，我的默认没有选上</p><p>make  &amp; make install</p><h3 id="制作根文件系统目录"><a href="#制作根文件系统目录" class="headerlink" title="制作根文件系统目录"></a>制作根文件系统目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir rootfs<br>cd rootfs <br>建立目录结构<br>mkdir bin etc dev lib proc tmp root home sys usr sbin var mnt<br>运行库-来自工具链<br>cp -a /usr/arm-linux-gnueabi/lib/* lib<br>配置文件-来自busybox<br>cp -a &lt;busybox_dir&gt;/examples/bootfloppy/etc/* etc<br>busybox工具集<br>cp -a &lt;busybox_dir&gt;/_install/* .<br>设备文件<br>sudo cp -a /dev/console /dev/loop0  /dev/loop1  /dev/null  /dev/ram0  /dev/tty  /dev/tty0  /dev/tty1  /dev/zero  dev<br>修改mdev配置，mdev负责自动生成设备节点,mdev.conf是配置文件<br>vim  etc/mdev.conf<br> controlC[0-9] 0:0 0660 =snd/<br>pcm.* 0:0 0660 =snd/<br>seq.* 0:0 0660 =snd/<br>mix.* 0:0 0660 =snd/<br>        timer 0:0 0660 =snd/<br>其他特殊要求的设备文件，同样道理即可. <br>修改启动配置<br>vi etc/init.d/rcS<br> 增加<br>mount -n -t proc none /proc  <br>mount -n -t sysfs none /sys  <br><br></code></pre></td></tr></table></figure><h3 id="根文件系统镜像"><a href="#根文件系统镜像" class="headerlink" title="根文件系统镜像"></a>根文件系统镜像</h3><p>dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;rootfs.img bs&#x3D;1M count&#x3D;32 # 32M的镜像</p><p>mkfs.ext3 rootfs.img</p><p>mkdir tmpfs</p><p>sudo mount -o loop rootfs.img tmpfs</p><p>sudo cp -a rootfs&#x2F;* tmpfs&#x2F;</p><p>sudo umount tmpfs</p><h2 id="NFS挂载配置"><a href="#NFS挂载配置" class="headerlink" title="NFS挂载配置"></a>NFS挂载配置</h2><p>通过apt-get install nfs-kernel-server安装NFS</p><p>在NFS服务的配置文件&#x2F;etc&#x2F;exports中添加   &#x2F;  *(rw,no_root_squash,insecure)  - - &gt;  &#x2F;即将宿主机的根目录进行挂载</p><blockquote><p>可以选择关闭Ubuntu的网关，避免连接不上：（但我没关，可以正常运行，如果你的不行可以试试关闭）</p><p>在&#x2F;etc&#x2F;resolv.conf中全部注释掉，不要DNS服务器地址。 （注释掉后是不能上网的）</p></blockquote><p> 在宿主机Ubuntu中开启NFS服务： &#x2F;etc&#x2F;init.d&#x2F;nfs-kernel-server start</p><p>启动qemu，加上启动命名-net user -net nic参数</p><p> 在目标机中配置网络、挂载NFS文件系统、切换根文件系统：</p><p>​     ifconfig eth0 10.0.2.15 up </p><p>route add default gw 10.0.2.2<br> mount -t nfs -o nolock 192.168.166.242:&#x2F; &#x2F;mnt   （ip改成自己的宿主机ip）</p><blockquote><p>若没成功可以重启NFS试试</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/MadFrey/homework.img/image-20231218200330425.png"></p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>启动命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo  qemu-system-arm -M vexpress-a9 -m 512m -kernel /home/rooy/linux-4.14.333/arch/arm/boot/zImage -dtb /home/rooy/linux-4.14.333/arch/arm/boot/dts/vexpress-v2p-ca9.dtb -append &quot;root=/dev/mmcblk0 init=/linuxrc  console=ttyAMA0&quot; -nographic -sd rootfs.img -net user -net nic<br></code></pre></td></tr></table></figure><p>加载驱动zfko.ko</p><p><img src="https://cdn.jsdelivr.net/gh/MadFrey/homework.img/image-20231218191752387.png"></p><p>&#x2F;dev下</p><p>可以看到在最后有zfko的名称</p><p><img src="https://cdn.jsdelivr.net/gh/MadFrey/homework.img/image-20231218191829640.png"></p><p>调用用户层zfko_app</p><p><img src="https://cdn.jsdelivr.net/gh/MadFrey/homework.img/image-20231218191929125.png"></p><p>zfko.c和zfko_app.c的源代码如下</p><p>zfko.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/miscdevice.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">misc_open</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *file)</span>&#123;<br><br>    printk(<span class="hljs-string">&quot;called misc_open\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">misc_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *file)</span>&#123;<br><br>    printk(<span class="hljs-string">&quot;called misc_release\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">misc_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">char</span> __user *user, <span class="hljs-type">size_t</span> size, <span class="hljs-type">loff_t</span> *<span class="hljs-type">loff_t</span>)</span>&#123;<br><br>printk(<span class="hljs-string">&quot;called misc_read\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">misc_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *user, <span class="hljs-type">size_t</span> size, <span class="hljs-type">loff_t</span> *<span class="hljs-type">loff_t</span>)</span>&#123;<br><br>printk(<span class="hljs-string">&quot;called misc_write\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">misc_fops</span> =</span> &#123;<br>        .owner = THIS_MODULE,<br>        .open = misc_open,<br>        .release = misc_release,<br>        .read = misc_read,<br>        .write = misc_write,<br><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">miscdevice</span> <span class="hljs-title">misc_dev</span> =</span> &#123;<br>        .minor = MISC_DYNAMIC_MINOR,<br>        .name = <span class="hljs-string">&quot;zfko&quot;</span>,<br>        .fops = &amp;misc_fops<br>&#125;;<br><br><span class="hljs-type">int</span> __init <span class="hljs-title function_">zfko_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;zfko is running\n&quot;</span>);<br>    <span class="hljs-type">int</span> ret;<br>    ret = misc_register(&amp;misc_dev);<br>    <span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>)&#123;<br>        printk(<span class="hljs-string">&quot;zfko register failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    printk(<span class="hljs-string">&quot;zfko register succeed\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> __exit <span class="hljs-title function_">zfko_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    misc_deregister(&amp;misc_dev);<br>    printk(<span class="hljs-string">&quot;zfko will exit\n&quot;</span>);<br>&#125;<br><br>MODULE_AUTHOR(<span class="hljs-string">&quot;LiuRongCheng&quot;</span>);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>module_init(zfko_init);<br>module_exit(zfko_exit);<br></code></pre></td></tr></table></figure><p>zfko_app.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> fd;<br><br>    <span class="hljs-type">char</span> buff[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    fd = open(<span class="hljs-string">&quot;/dev/zfko&quot;</span>, O_RDWR);<br><br>    <span class="hljs-keyword">if</span>(fd &lt; <span class="hljs-number">0</span>)&#123;<br><br>        perror(<span class="hljs-string">&quot;open error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> fd;<br>    &#125;<br><br>    read(fd, buff, <span class="hljs-keyword">sizeof</span>(buff));<br><br>    write(fd, buff,<span class="hljs-keyword">sizeof</span>(buff));<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">KDIR:=/home/rooy/linux-4.14.333<br><br>PWD:=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><br><br>obj-m += zfko.o<br><br><span class="hljs-comment"># 编译成模块</span><br><span class="hljs-section">all:</span><br>    make ARCH=arm  CROSS_COMPILE=/opt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-   -C <span class="hljs-variable">$(KDIR)</span> M=<span class="hljs-variable">$(PWD)</span> modules<br><br><span class="hljs-section">clean:</span><br>    make -C <span class="hljs-variable">$(KDIR)</span> M=<span class="hljs-variable">$(PWD)</span> clean<br></code></pre></td></tr></table></figure><p>运行简单的helloworld程序</p><p><img src="https://cdn.jsdelivr.net/gh/MadFrey/homework.img/image-20231218192121351.png"></p><p>qemu启动成功</p><p><img src="https://cdn.jsdelivr.net/gh/MadFrey/homework.img/image-20231218192224793.png"></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>qemu</tag>
      
      <tag>arm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.824Lab2思路总结</title>
    <link href="/2023/11/18/MIT6-824Lab2%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <url>/2023/11/18/MIT6-824Lab2%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>强烈推荐raft理解网站：<br><a href="https://thesecretlivesofdata.com/raft/">Raft (thesecretlivesofdata.com)</a></p><h2 id="lab2A"><a href="#lab2A" class="headerlink" title="lab2A"></a>lab2A</h2><p>断断续续做了很久，主要也是花了很多时间去debug</p><p> lab2a是可以直接上手写的，只要看完了论文的这一部分，可能对写代码有影响的就是对go或者说实验的rpc包并不是很熟悉，没有使用协程去send心跳和投票</p><p>然后卡我最久的是election timeout协程，我一开始是没有使用state来表示三种状态的，是后面改bug的时候才改的（个人感觉和论文一样只使用isleader就够了，是完全可以完成的），于是这里就改漏了，判断可以进入下一个term的条件只有rf.state &#x3D;&#x3D; Follower ，导致第二个测试点一直过不去，最后就是会有两个candidate，无法选出leader（因为判断条件只有follower才能进入），后面debug了我快一天才找出来，太痛苦了，还是自己太粗心了。</p><p>太菜了，我是废物&gt;_&lt;</p><p>条件改为rf.state &#x3D;&#x3D; Follower ||rf.state &#x3D;&#x3D; Candidate  即可通过第二个测试点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//再启一个gorutine，用于election timeout</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span>&#123;<br><span class="hljs-keyword">case</span> &lt;-Ticker.C :  <span class="hljs-comment">//heartbeat timeout </span><br><span class="hljs-comment">//开始选举</span><br><br>rf.Ticker.Reset(time.Duration(<span class="hljs-number">150</span>+rand.Intn(<span class="hljs-number">200</span>)) * time.Millisecond)<br><span class="hljs-keyword">if</span> rf.state == Follower ||rf.state == Candidate &#123;<br><br>rf.state = Candidate<br>rf.currentTerm = rf.currentTerm + <span class="hljs-number">1</span><br>args := &amp;RequestVoteArgs&#123;Term:rf.currentTerm,CandidateId:rf.me&#125;<br><br><span class="hljs-comment">//先投自己一票</span><br>rf.votedFor = me<br>count := <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;[candidate]&quot;</span>,rf.me,rf.currentTerm,time.Now())<br><span class="hljs-keyword">for</span> v:=<span class="hljs-keyword">range</span> rf.peers &#123;<br><span class="hljs-keyword">if</span> v == rf.me &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">//启线程异步进行 - -&gt; 对go的rpc不是很熟悉</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(args *RequestVoteArgs,v <span class="hljs-type">int</span>,count *<span class="hljs-type">int</span>)</span></span>&#123;<br>reply := RequestVoteReply&#123;&#125;<br><span class="hljs-keyword">var</span> ok <span class="hljs-type">bool</span> = <span class="hljs-literal">false</span><br>ok=rf.sendRequestVote(v,args,&amp;reply)<br><br>fmt.Println(rf.me,reply,rf.isleader,rf.state,rf.currentTerm)<br><span class="hljs-keyword">if</span> ok &#123;<br>rf.mu.Lock()<br><span class="hljs-keyword">defer</span> rf.mu.Unlock()<br><span class="hljs-keyword">if</span> reply.Term&gt; rf.currentTerm &#123;<br><br>rf.currentTerm = reply.Term   <span class="hljs-comment">//变为follower不需要重置计时器和投票？</span><br>rf.votedFor = <span class="hljs-number">-1</span><br>rf.state = Follower <br><br>&#125;<br><br><span class="hljs-keyword">if</span> reply.Votegranted &#123;<br>*count +=<span class="hljs-number">1</span>  <br><br>fmt.Println(<span class="hljs-string">&quot;[count num]&quot;</span>,*count,rf.me)<br><span class="hljs-keyword">if</span> *count &gt;<span class="hljs-built_in">len</span>(rf.peers)/<span class="hljs-number">2</span>&#123;<br><span class="hljs-keyword">if</span> rf.currentTerm == args.Term &#123;  <span class="hljs-comment">//解决延迟票</span><br>rf.isleader = <span class="hljs-literal">true</span><br>rf.state = Leader<br>fmt.Println(<span class="hljs-string">&quot;[election leader]&quot;</span>,rf.me)<br><span class="hljs-comment">//发送心跳包，告知已经选上leader</span><br>args := &amp;AppendEntriesArgs&#123;Term:rf.currentTerm,LeaderId: rf.me&#125;<br>reply := &amp;AppendEntriesReply&#123;&#125;<br>rf.sendAppendEntries(args ,reply)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;(args,v,&amp;count)<br><br><br>&#125;<br><br>&#125;<br><br><br><span class="hljs-keyword">case</span> &lt;-rf.IsGetHeartbeat: <span class="hljs-comment">//收到心跳</span><br>rf.Ticker.Reset(time.Duration(<span class="hljs-number">150</span>+rand.Intn(<span class="hljs-number">200</span>)) * time.Millisecond)<br>&#125;<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><p>这边还要注意的一点是统计选票的方式我选择的是这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> reply.Votegranted &#123;<br>*count +=<span class="hljs-number">1</span>  <br><br>fmt.Println(<span class="hljs-string">&quot;[count num]&quot;</span>,*count,rf.me)<br><span class="hljs-keyword">if</span> *count &gt;<span class="hljs-built_in">len</span>(rf.peers)/<span class="hljs-number">2</span>&#123;<br><span class="hljs-keyword">if</span> rf.currentTerm == args.Term &#123;  <span class="hljs-comment">//解决延迟票</span><br>rf.isleader = <span class="hljs-literal">true</span><br>rf.state = Leader<br>fmt.Println(<span class="hljs-string">&quot;[election leader]&quot;</span>,rf.me)<br><span class="hljs-comment">//发送心跳包，告知已经选上leader</span><br>args := &amp;AppendEntriesArgs&#123;Term:rf.currentTerm,LeaderId: rf.me&#125;<br>reply := &amp;AppendEntriesReply&#123;&#125;<br>rf.sendAppendEntries(args ,reply)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只要选票大于1&#x2F;2就会选为leader，所以这就会有一个问题就是如果有延迟的话，怎么样才能避免剩下的选票影响下一次的选举。这里直接使用逻辑时间term来避免这个问题</p><h2 id="Lab2B"><a href="#Lab2B" class="headerlink" title="Lab2B"></a>Lab2B</h2><p>做着感觉难度还行，debug弄了很久（在crash部分）</p><p>难点在怎么处理leader和follower出现故障的问题</p><p>一般来说最可能通不过的是backup那个测试点，其他测试点如果按照论文的实现来的话完完全全是没问题的（当然基于论文实现的raft还有很多优化可以做，这个等后面再说）</p><p>记得初始化 rf.applyCh &#x3D; applyCh，所有提交后的数据都要输入管道，实验的检测将会从每个server的channel中取出数据，核对对应index的command是否相同</p><p>我debug有遇到过前面一个测试点通不过的情况，问题出在发送appendentries的时候，传递的是args和reply的引用，这是非常容易导致错误的，随后重新传参后通过测试点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> sendAppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;<br><span class="hljs-comment">//发给所有的node</span><br><span class="hljs-keyword">if</span> rf.killed() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>CommitSum := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> rf.peers &#123;<br><span class="hljs-keyword">if</span> i == rf.me &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">//心跳也要起协程发</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v *labrpc.ClientEnd, i <span class="hljs-type">int</span>, CommitSum *<span class="hljs-type">int</span>, args AppendEntriesArgs, reply AppendEntriesReply)</span></span> &#123;<br>args.LeaderCommit = rf.commitIndex<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rf.log) != <span class="hljs-number">0</span> &amp;&amp; rf.nextIndex[i] != <span class="hljs-built_in">len</span>(rf.log) &#123;<br><span class="hljs-keyword">if</span> rf.nextIndex[i] == <span class="hljs-number">0</span> &#123;<br>args.Entries = rf.log <span class="hljs-comment">//nextIndex[i] 是已经存储的长度，即最后一个元素的index加1</span><br>args.PrevLogIndex = rf.nextIndex[i] - <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>args.Entries = rf.log[rf.nextIndex[i]:] <span class="hljs-comment">//nextIndex[i] 是已经存储的长度，即最后一个元素的index加1</span><br>args.PrevLogIndex = rf.nextIndex[i] - <span class="hljs-number">1</span><br>args.PrevLogTerm = rf.log[rf.nextIndex[i]<span class="hljs-number">-1</span>].Term<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rf.log) != <span class="hljs-number">0</span> &amp;&amp; rf.nextIndex[i] == <span class="hljs-built_in">len</span>(rf.log) &#123;<br>args.PrevLogIndex = rf.nextIndex[i] - <span class="hljs-number">1</span><br>args.PrevLogTerm = rf.log[rf.nextIndex[i]<span class="hljs-number">-1</span>].Term<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;Raft.AppendEntries&quot;</span>, rf.nextIndex, args, i, rf.log, rf.commitIndex)<br>ok := v.Call(<span class="hljs-string">&quot;Raft.AppendEntries&quot;</span>, &amp;args, &amp;reply)<br><span class="hljs-keyword">if</span> !ok &#123;<br>ok = v.Call(<span class="hljs-string">&quot;Raft.AppendEntries&quot;</span>, &amp;args, &amp;reply)<br>&#125;<br><span class="hljs-keyword">if</span> ok &#123;<br>rf.mu.Lock()<br><span class="hljs-keyword">defer</span> rf.mu.Unlock()<br><br><span class="hljs-keyword">if</span> reply.Success &#123;<br><span class="hljs-comment">//关于commit 持久化</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args.Entries) == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">//heartbeat</span><br><span class="hljs-keyword">return</span><br>&#125;<br><br>rf.nextIndex[i] = <span class="hljs-built_in">len</span>(rf.log)<br>*CommitSum++<br><br><span class="hljs-keyword">if</span> *CommitSum &gt;= <span class="hljs-built_in">len</span>(rf.peers)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span> &#123; <span class="hljs-comment">//commit</span><br>*CommitSum = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> rf.lastApplied &lt; <span class="hljs-built_in">len</span>(rf.log) &#123;<br>rf.lastApplied++<br>aMsg := ApplyMsg&#123;<br>CommandValid: <span class="hljs-literal">true</span>,<br>Command:      rf.log[rf.lastApplied<span class="hljs-number">-1</span>].Command,<br>CommandIndex: rf.lastApplied,<br>&#125;<br>rf.applyCh &lt;- aMsg<br>rf.commitIndex = rf.lastApplied<br>&#125;<br>&#125;<br><br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果对不上日志，那么就重新发logentries?直到对上 还是说等待下一个心跳</span><br><br><span class="hljs-keyword">if</span> reply.Term &gt; rf.currentTerm &#123; <span class="hljs-comment">//如果leader的term小于某个节点，那么会强行提升term与领先一致，变为follower，解决离群节点重恢复term过大的问题</span><br>rf.currentTerm = reply.Term<br>rf.votedFor = <span class="hljs-number">-1</span><br>rf.state = Follower<br>rf.isleader = <span class="hljs-literal">false</span><br><span class="hljs-keyword">return</span><br>&#125;<br>rf.nextIndex[i] = rf.nextIndex[i] - <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>&#125;(v, i, &amp;CommitSum, *args, *reply)<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我个人是尽量还原论文的描述，我的appendentries当logs为空时为心跳或者commit信息，当log不为空时，为appendentries信息，这里需要小心处理，如果你backup测试点过不了，那很可能是因为你崩溃后reconnect解决一致性问题没有做好，我在这块花了挺久时间才debug出来，最后加上<code>args.PrevLogTerm = rf.log[rf.nextIndex[i]-1].Term</code>后，成功通过所有测试点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rf.log) != <span class="hljs-number">0</span> &amp;&amp; rf.nextIndex[i] == <span class="hljs-built_in">len</span>(rf.log) &#123;<br>args.PrevLogIndex = rf.nextIndex[i] - <span class="hljs-number">1</span><br>args.PrevLogTerm = rf.log[rf.nextIndex[i]<span class="hljs-number">-1</span>].Term<br>&#125;<br></code></pre></td></tr></table></figure><p>就是一个小问题但是却花了那么时间才debug出来，确实挺恶心的</p><p>但是虽然我们最后知道了这就是一个小疏忽导致的，但是在debug的时候，因为不知道问题出在哪，造成最终结果不正确的因素有很多，我们得一个个排除，而用来排除的时间我认为是debug中花费时间最多的，想要最后解决问题，就得耐下性子来一个一个排查</p><p>我认为lab2b的难点就在于解决leader和follower crash的问题，所以不止要改appendentries，还得改选举</p><p>根据论文所说，如果一个candidate 光term高也不能直接把票投给他，还得看他的日志是否满足要求</p><p>如果candidate 的日志的最新一个entry的term要比当前投票者的最新term要新，那么就投票给他</p><p>如果term一样新，那么我们再看index，如果candidate的index比投票者的最新log的index长，那么投票给他，其他情况都不投票给他</p><p>如果一个测试点因为网络问题变为candidate ，并且最后重新连回cluster的时候term非常高会怎么样？</p><p>如果是收到candidate投票请求的follower还是发心跳到了candidate的leader，论文要求他们都要同步拉升到相同的term，所以最后不会因为离群的节点他term很高而导致他成为leader，这也是其中一个测试点测试的</p><p>而要通过测试点非常简单，只要在投票之前先经过logvote检测就行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123; <span class="hljs-comment">//candidate 在选举期间发起</span><br>    <span class="hljs-comment">// Your code here (2A, 2B).</span><br>    <span class="hljs-comment">//进行投票 , 同步term，如果candidate的term比自己大</span><br>    <span class="hljs-comment">//会重置election timeout</span><br><br>    <span class="hljs-keyword">if</span> rf.killed() &#123;<br>       reply.Votegranted = <span class="hljs-literal">false</span><br>       <span class="hljs-keyword">return</span><br>    &#125;<br>    rf.mu.Lock()<br>    <span class="hljs-keyword">defer</span> rf.mu.Unlock()<br><br>    <span class="hljs-comment">//当出现有多个candidate的情况，怎么根据任期来解决这个问题</span><br>    <span class="hljs-keyword">if</span> args.Term &gt; rf.currentTerm &#123; <span class="hljs-comment">//什么情况下会有相同的term，同为candidate或着接收到vote的follower</span><br>       rf.IsGetHeartbeat &lt;- <span class="hljs-number">0</span><br>       rf.isleader = <span class="hljs-literal">false</span><br>       rf.state = Follower<br>       rf.votedFor = <span class="hljs-number">-1</span><br>       rf.currentTerm = args.Term<br>       <span class="hljs-comment">//先看log再投票</span><br>       lv := rf.logVote(args)<br>       <span class="hljs-keyword">if</span> lv &#123;<br>          rf.votedFor = args.CandidateId<br>          reply.Votegranted = <span class="hljs-literal">true</span><br>       &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">if</span> args.Term == rf.currentTerm &#123; <span class="hljs-comment">//如果是投给的那个人来要票，那就再给他投一次</span><br>          lv := rf.logVote(args)<br>          <span class="hljs-keyword">if</span> (rf.votedFor == args.CandidateId || rf.votedFor == <span class="hljs-number">-1</span>) &amp;&amp; lv &#123;<br>             rf.IsGetHeartbeat &lt;- <span class="hljs-number">0</span><br>             rf.votedFor = args.CandidateId<br>             reply.Votegranted = <span class="hljs-literal">true</span><br><br>          &#125;<br><br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>          reply.Votegranted = <span class="hljs-literal">false</span><br><br>       &#125;<br><br>    &#125;<br><br>    reply.Term = rf.currentTerm<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> logVote(args *RequestVoteArgs) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rf.log) == <span class="hljs-number">0</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> rf.log[<span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span>].Term &gt; args.LastLogTerm &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-keyword">if</span> rf.log[<span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span>].Term == args.LastLogTerm &amp;&amp; <span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span> &gt; args.LastLogIndex &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>       &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后还得还得解决的问题就是新的leader上台后的初始化问题</p><p>选上leader后，会立即发送一次心跳（我是这么写的），发送参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">args := &amp;AppendEntriesArgs&#123;<br>    Term: rf.currentTerm,<br>    LeaderId:     rf.me,<br>    PrevLogIndex: <span class="hljs-built_in">len</span>(rf.log) - <span class="hljs-number">1</span>,<br>    PrevLogTerm:  <span class="hljs-number">0</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我初始化了但没有用matchindex</p><blockquote><p>matchIndex 它记录了每个 Follower 节点已经复制了 Leader 节点的日志条目的最高索引。matchIndex 的作用是帮助 Leader 节点确定哪些日志条目已经被过半数的 Follower 节点复制，从而可以更新自己的 commitIndex，并将已提交的日志条目应用到状态机上。</p></blockquote><p>因为我已经用其他等效的方法实现了commit记录，就不需要再使用matchindex了</p><p>其中无论用了matchindex还是没用matchindex都要关注的一点就是第一次的试探心跳</p><p>因为新选上来的leader一开始是不知道每个server的log index和commit 进度的</p><p>所以第一次的心跳和普通的心跳还真就不一样，一定要好好处理，不然backup等测试点还是可能过不了的。第一次心跳参数设置如上所述，因为第一次心跳很可能leader的log为空，这个情况也需要特殊处理一下因为如果你的log为空的话，比如<code>args.PrevLogTerm = rf.log[rf.nextIndex[i]-1].Term</code> 是会报错的</p><p>最后lab2b做下来感触颇深的就是，如果有不懂的或者思路不清晰的，建议再回去多看几遍论文，理解透彻了也就会做了</p><p>对了，做lab2b的时候发现raft有很多可以优化的地方（在工业届比如etcd和tikv，他们的raft都是优化过的），这里插个眼，后面完成所有lab后再回来做优化</p><hr><p>11.23记录</p><p>在给lab2c加上presist后lab2b开始通不过，目前认为是加上了lab2b导致处理时间变长，最后导致心跳超时等各种问题</p><blockquote><p>目测解决方法应该是实现 增量返回term优化</p></blockquote><p>测试lab2c的时候发现又出buglab2b</p><p>遂回来重新改bug（虽然当时做的时候测了大概有10次左右都pass了，我就认为没问题了&gt;_&lt;）</p><p>bug如下 TestFailAgree2B：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">2 send heartbeat entry:[&#123;1 105&#125; &#123;1 106&#125; &#123;13 106&#125;] PrevLogIndex 3 PrevLogTerm 1]<br>2 send heartbeat entry:[&#123;1 103&#125; &#123;1 104&#125; &#123;1 105&#125; &#123;1 106&#125; &#123;13 106&#125;] PrevLogIndex 1 PrevLogTerm 1]<br>0 get heartbeat [&#123;1 101&#125;]<br>1 get heartbeat [&#123;1 101&#125; &#123;1 102&#125; &#123;1 103&#125;]<br>1 get heartbeat [&#123;1 101&#125; &#123;1 102&#125; &#123;1 103&#125;]<br>2 send heartbeat entry:[&#123;1 103&#125; &#123;1 104&#125; &#123;1 105&#125; &#123;1 106&#125; &#123;13 106&#125;] PrevLogIndex 1 PrevLogTerm 1]<br>1 get heartbeat [&#123;1 101&#125;]<br>2 send heartbeat entry:[&#123;1 101&#125; &#123;1 102&#125; &#123;1 103&#125; &#123;1 104&#125; &#123;1 105&#125; &#123;1 106&#125; &#123;13 106&#125;] PrevLogIndex -1 PrevLogTerm 0]<br>0 get heartbeat [&#123;1 101&#125; &#123;1 101&#125; &#123;1 102&#125; &#123;1 103&#125; &#123;1 104&#125; &#123;1 105&#125; &#123;1 106&#125; &#123;13 106&#125;]<br></code></pre></td></tr></table></figure><p>发给0的 PrevLogIndex突然从1跳变到了-1</p><p>目前加锁解决 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(v *labrpc.ClientEnd, i <span class="hljs-type">int</span>, CommitSum *<span class="hljs-type">int</span>, args AppendEntriesArgs, reply AppendEntriesReply)</span></span> &#123;<br>subMu.Lock()<br>args.LeaderCommit = rf.commitIndex<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rf.log) != <span class="hljs-number">0</span> &amp;&amp; rf.nextIndex[i] != <span class="hljs-built_in">len</span>(rf.log) &#123;<br><span class="hljs-keyword">if</span> rf.nextIndex[i] == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// no problem</span><br>args.Entries = rf.log <span class="hljs-comment">//nextIndex[i] 是已经存储的长度，即最后一个元素的index加1</span><br>args.PrevLogIndex = rf.nextIndex[i] - <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>args.Entries = rf.log[rf.nextIndex[i]:] <span class="hljs-comment">//nextIndex[i] 是已经存储的长度，即最后一个元素的index加1</span><br>args.PrevLogIndex = rf.nextIndex[i] - <span class="hljs-number">1</span><br>args.PrevLogTerm = rf.log[rf.nextIndex[i]<span class="hljs-number">-1</span>].Term<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rf.log) != <span class="hljs-number">0</span> &amp;&amp; rf.nextIndex[i] == <span class="hljs-built_in">len</span>(rf.log) &#123;<br>args.PrevLogIndex = rf.nextIndex[i] - <span class="hljs-number">1</span><br>args.PrevLogTerm = rf.log[rf.nextIndex[i]<span class="hljs-number">-1</span>].Term<br>&#125;<br>subMu.Unlock()<br>fmt.Printf(<span class="hljs-string">&quot;%d send heartbeat entry:%v PrevLogIndex %d PrevLogTerm %d]\n&quot;</span>, rf.me, args.Entries, args.PrevLogIndex, args.PrevLogTerm)<br>ok := v.Call(<span class="hljs-string">&quot;Raft.AppendEntries&quot;</span>, &amp;args, &amp;reply)<br><span class="hljs-keyword">for</span> !ok &#123;<br>ok = v.Call(<span class="hljs-string">&quot;Raft.AppendEntries&quot;</span>, &amp;args, &amp;reply)<br>&#125;<br><span class="hljs-keyword">if</span> ok &#123;<br>rf.mu.Lock()<br><span class="hljs-keyword">defer</span> rf.mu.Unlock()<br></code></pre></td></tr></table></figure><p>会有一个很奇怪的问题，我自己单独运行test没什么问题，但是一到一起运行要不就是收不到start，要不就是rpc调用不起。应该是处理的太慢了 - -&gt;上面加锁导致心跳处理串行化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">0 send heartbeat entry:[&#123;1 106&#125;] PrevLogIndex 4 PrevLogTerm 1]<br>1 get heartbeat [&#123;1 101&#125;]<br>0 send heartbeat entry:[] PrevLogIndex 5 PrevLogTerm 1]<br>2 get heartbeat [&#123;1 101&#125; &#123;1 102&#125; &#123;1 103&#125; &#123;1 104&#125; &#123;1 105&#125;]<br>0 send heartbeat entry:[&#123;1 106&#125;] PrevLogIndex 4 PrevLogTerm 1]<br>1 get heartbeat [&#123;1 101&#125;]<br>0 send heartbeat entry:[] PrevLogIndex 5 PrevLogTerm 1]<br>2 get heartbeat [&#123;1 101&#125; &#123;1 102&#125; &#123;1 103&#125; &#123;1 104&#125; &#123;1 105&#125;]<br>[candidate] 1 10 2023-11-24 08:11:36.221273525 +0800 CST m=+17.869143605<br></code></pre></td></tr></table></figure><p>当0，和1都有日志并且提交了时，此时2没有日志且无提交，此时切换leader，2没有进行replication</p><p>2的nextindex变为了1</p><p>如果有节点的log提交了但是还没同步到其他的节点上，就开始重新选举了，这个时候应该怎么选？</p><p> <a href="https://www.zhihu.com/question/357207584">(29 封私信 &#x2F; 75 条消息) raft协议，leader在commit了一条日志后，立刻挂了，那其他节点如何处理这条日志？ - 知乎 (zhihu.com)</a></p><p>TestConcurrentStarts2B term变化太频繁了</p><p> FAIL: TestBackup2B (37.12s)<br>    config.go:600: one(8635910386943868591) failed to reach agreement</p><p>before send heartbeat 1 [{1 101}]<br>1 send heartbeat entry:[] PrevLogIndex 0 PrevLogTerm 1 to 2<br>before send heartbeat 1 [{1 101}]<br>panic: runtime error: index out of range [1] with length 1</p><p>TestFailAgree2B选不出leader来 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell">before send heartbeat 1 [&#123;1 101&#125; &#123;2 102&#125; &#123;2 103&#125;] to 2<br>1 send heartbeat entry:[&#123;2 102&#125; &#123;2 103&#125;] PrevLogIndex 0 PrevLogTerm 1 to 2<br>before send heartbeat 1 [&#123;1 101&#125; &#123;2 102&#125; &#123;2 103&#125;] to 0<br>1 send heartbeat entry:[] PrevLogIndex 2 PrevLogTerm 2 to 0<br>[start] new log [&#123;1 101&#125; &#123;2 102&#125; &#123;2 103&#125; &#123;2 104&#125;]<br>[candidate] 0 3 2023-11-26 07:52:01.045145526 +0800 CST m=+16.071576847<br>1 send vote false<br>[candidate] 2 8 2023-11-26 07:52:01.106842539 +0800 CST m=+16.133273850<br>[nextIndex] 0 3 3<br>[candidate] 1 4 2023-11-26 07:52:01.291407124 +0800 CST m=+16.317838435<br>[candidate] 0 4 2023-11-26 07:52:01.338668275 +0800 CST m=+16.365099586<br>1 send vote false<br>0 send vote false<br>[candidate] 2 9 2023-11-26 07:52:01.367998168 +0800 CST m=+16.394429489<br>[candidate] 2 10 2023-11-26 07:52:01.592073742 +0800 CST m=+16.618505053<br>[candidate] 1 5 2023-11-26 07:52:01.627950022 +0800 CST m=+16.654381333<br>0 send vote false<br>[candidate] 0 5 2023-11-26 07:52:01.648159766 +0800 CST m=+16.674591087<br>[candidate] 2 11 2023-11-26 07:52:01.792065309 +0800 CST m=+16.818496640<br>1 send vote false<br>[candidate] 0 6 2023-11-26 07:52:01.891437687 +0800 CST m=+16.917868998<br>[candidate] 1 6 2023-11-26 07:52:01.919971067 +0800 CST m=+16.946402379<br>0 send vote false<br>1 send vote false<br>[candidate] 0 7 2023-11-26 07:52:02.047624436 +0800 CST m=+17.074055747<br>1 send vote false<br>[candidate] 2 12 2023-11-26 07:52:02.110598063 +0800 CST m=+17.137029374<br>[candidate] 0 8 2023-11-26 07:52:02.276945957 +0800 CST m=+17.303377268<br>1 send vote false<br>[candidate] 2 13 2023-11-26 07:52:02.422322676 +0800 CST m=+17.448753987<br>[candidate] 0 9 2023-11-26 07:52:02.507124463 +0800 CST m=+17.533555774<br>1 send vote false<br>[candidate] 2 14 2023-11-26 07:52:02.676923361 +0800 CST m=+17.703354672<br>[candidate] 0 10 2023-11-26 07:52:02.752133458 +0800 CST m=+17.778564769<br>1 send vote false<br>[candidate] 2 15 2023-11-26 07:52:02.835639606 +0800 CST m=+17.862070917<br>[candidate] 1 11 2023-11-26 07:52:02.940533733 +0800 CST m=+17.966965044<br></code></pre></td></tr></table></figure><p>如果最后通过的时间大于了1分钟，调小心跳和选举时间即可</p><p>修改完Lab2C的bug后，buckup又有概率过不去了&gt;_&lt;</p><p><a href="https://zhuanlan.zhihu.com/p/639480562">Raft 必备的优化手段（一）：Leader Election 篇 - 知乎 (zhihu.com)</a></p><blockquote><ul><li><p>Read Index</p></li><li><p>Lease Read</p></li><li><p><em>Pre Vote</em></p></li><li><p>Nuraft ：Priority election</p></li><li><p>Leader change</p></li><li><p>Leadership Expiration</p></li></ul></blockquote><ul><li><p><a href="https://cn.pingcap.com/blog/tikv-source-code-reading-1/">日志复制的优化：为了提高日志复制的效率和吞吐量，Raft 可以使用 batch，pipeline，parallel append，asynchronous apply 等机制来减少网络和磁盘的开销</a><a href="https://cn.pingcap.com/blog/tikv-source-code-reading-1/">4</a><a href="https://cloud.tencent.com/developer/article/1394643">5</a><a href="https://zhuanlan.zhihu.com/p/623294589">6</a>。</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/25735592">读操作的优化：为了保证读操作的线性一致性和高性能，Raft 可以使用 read index，lease read，local read 等机制来减少读操作的延迟和消息开销</a><a href="https://bing.com/search?q=raft+%E4%BC%98%E5%8C%96+etcd+tikv">1</a><a href="https://zhuanlan.zhihu.com/p/25735592">2</a><a href="https://zhuanlan.zhihu.com/p/639480562">3</a> 。</p></li><li><p><a href="https://cn.pingcap.com/blog/tikv-source-code-reading-1/">快照的优化：为了减少快照的生成和传输的开销，Raft 可以使用 SST snapshot，delta snapshot，streaming snapshot 等机制来提高快照的效率</a><a href="https://cn.pingcap.com/blog/tikv-source-code-reading-1/">4</a> 。</p></li></ul><blockquote><p>在 etcd 和 tikv 上，Raft 的优化主要体现在以下几个方面：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/25735592">etcd 使用了 pre-vote，check quorum，read index，lease read，SST snapshot 等机制来优化 Raft 的选举，读写，快照等功能</a><a href="https://bing.com/search?q=raft+%E4%BC%98%E5%8C%96+etcd+tikv">1</a><a href="https://zhuanlan.zhihu.com/p/25735592">2</a><a href="https://zhuanlan.zhihu.com/p/639480562">3</a><a href="https://cloud.tencent.com/developer/article/1394643">5</a> 。</li><li><a href="https://cn.pingcap.com/blog/tikv-source-code-reading-1/">tikv 使用了 pre-vote，check quorum，batch，pipeline，parallel append，asynchronous apply，local read，SST snapshot，delta snapshot，streaming snapshot 等机制来优化 Raft 的选举，读写，快照等功能</a><a href="https://cn.pingcap.com/blog/tikv-source-code-reading-1/">4</a><a href="https://zhuanlan.zhihu.com/p/623294589">6</a> 。</li></ul></blockquote><h2 id="Lab2C"><a href="#Lab2C" class="headerlink" title="Lab2C"></a>Lab2C</h2><p><img src="D:\blogs\hexo-blog\source_posts\MIT6-824Lab2思路总结.assets\image-20231127091146715.png" alt="image-20231127091146715"></p><p>当一个节点有日志没提交，且和新leader的对应下标index相同时会有问题</p><p>当有一个节点的日志提交了，但是崩溃了，换了另外一个leader，那个leader对应index也有日志，但是没有提交，此时会出现不一致的问题</p><p>提交了非当前任期的日志</p><p>如果leader向其他节点同步了日志，并且自己提交了，但是其他节点没有收到提交心跳就挂了，那么新上台的节点是否需要提交 - - -&gt; 因该是要提交的</p><p>什么时候变成follower？ 当请求的term大于当前term的时候是肯定要变的，但当term等于当前term的时候呢</p><p>当nextindex大于len(rf.log)时</p><p>TestFigure8Unreliable2偶尔过不去</p><p>目前看来有提交问题，因为crash可能导致nextindex不一样</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">rf<span class="hljs-selector-class">.nextIndex</span><span class="hljs-selector-attr">[i]</span> = args<span class="hljs-selector-class">.PrevLogIndex</span> + <span class="hljs-built_in">len</span>(args.Entries) + <span class="hljs-number">1</span> <span class="hljs-comment">//这样设置更加可靠安全</span><br></code></pre></td></tr></table></figure><hr><p>（期末复习，没时间写了，回来寒假写）</p><h2 id="Lab2D"><a href="#Lab2D" class="headerlink" title="Lab2D"></a>Lab2D</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// in part 2D you&#x27;ll want to send other kinds of messages (e.g.,</span><br><span class="hljs-comment">// snapshots) on the applyCh, but set CommandValid to false for these</span><br><span class="hljs-comment">// other uses.</span><br><span class="hljs-keyword">type</span> ApplyMsg <span class="hljs-keyword">struct</span> &#123;<br>    CommandValid <span class="hljs-type">bool</span><br>    Command      <span class="hljs-keyword">interface</span>&#123;&#125;<br>    CommandIndex <span class="hljs-type">int</span><br><br>    <span class="hljs-comment">// For 2D:</span><br>    SnapshotValid <span class="hljs-type">bool</span><br>    Snapshot      []<span class="hljs-type">byte</span> <span class="hljs-comment">// important</span><br>    SnapshotTerm  <span class="hljs-type">int</span><br>    SnapshotIndex <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Election timeout 和sendappendentries的锁争用问题</p><p>send为什么要加锁 - -&gt;send 和  commit协程之间的问题</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">rf<span class="hljs-selector-class">.mu</span><span class="hljs-selector-class">.Unlock</span>()<br>rf<span class="hljs-selector-class">.applyCh</span> &lt;- msg<br>rf<span class="hljs-selector-class">.mu</span><span class="hljs-selector-class">.Lock</span>()<br></code></pre></td></tr></table></figure><p>提交并发问题 </p><p>多个协程</p><p>选举问题，选不出leader</p>]]></content>
    
    
    <categories>
      
      <category>lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.824</tag>
      
      <tag>lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.824Lab1思路总结</title>
    <link href="/2023/11/07/MIT6-824Lab1%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <url>/2023/11/07/MIT6-824Lab1%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>因为824的老师不希望我们开源代码，所以我就放在gitee上（doge），外国人总不会用gitee吧</p><p>Gitee仓库地址：<a href="https://gitee.com/MadFray/mit6.824">MadFray&#x2F;MIT6.824 (gitee.com)</a></p><p>然后用写篇blog记录一下在做lab1时候的思路和遇到坑点</p><p>在最开始做的时候，因为论文讲述的是在cluster下的情况，现在放到了单机实现，有一定的上手难度，但是最无语的一件事是没有看完hint就去做，导致当时想要通过协程来实现，这不合老师们的想法（hint没有这方面的提示），同时这方面是思路是空白的，也就是说实现起来会相对比较困难（但其实后面单独测试的时候，去改脚本发现其实他的脚本就是挂后台启动了好几个worker，这也就意味着，这个worker应该是既可以做map也可以做reduce的）。</p><p>在后面看了一篇csdn的博客后，自己私下里又把hint完完整整的看完了一遍，才真正算是理清楚了思路，大致知道了老师们希望我们怎么做。理清楚了思路做起来就快了真正开始动手做到完成lab大花了1天半多的时间，加上看论文等资料，实际需要的时间我估计应该在最多3天左右，当然我指的是一天的大部分时间都花在这上面，需要3天</p><p>接下来就来说一下我的思路和一下经验总结</p><p>我是首先实现的worker</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Worker</span><span class="hljs-params">(mapffunc(<span class="hljs-type">string</span>,<span class="hljs-type">string</span>)</span></span> []KeyValue,<br><br>reduceffunc(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)<span class="hljs-type">string</span>) &#123;<br><br><span class="hljs-comment">// Your worker implementation here.</span><br><br><span class="hljs-keyword">for</span> &#123;<br><br>task := GetTask()<br><br><span class="hljs-keyword">switch</span> task.TaskType &#123;<br><br><span class="hljs-keyword">case</span> MapTask:<br><br>&#123;<br><br>DoMap(mapf, task)<br><br>DoneTask(task)<br><br>&#125;<br><br><span class="hljs-keyword">case</span> CompleteTask:<br><br>&#123;<br><br><span class="hljs-comment">//exit</span><br><br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">case</span> ReduceTask:<br><br>&#123;<br><br>DoReduceTask(reducef,task)<br><br>DoneTask(task)<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">// uncomment to send the Example RPC to the coordinator.</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>因为上面提到过，worker要map和reduce都能处理，所以我们要根据穿过来的task参数中的tasktype来进行判断应该做什么处理</p><p>这边提一下我并没有去维护worker的状态，而只使用了task的状态，只维护task的状态相对来讲会更加简单</p><p>然后在实现DoMap的时候，这里一开始实现的时候没有注意到并发问题（当然，在并发问题之前其实还有一个小问题，我把create文件放到了for循环里，这导致所有的key value都没有追加到对应的tmp文件中，而是后面覆盖前面（create会如果已经存在了同名文件，那么就会进行覆盖），导致到了最后处理完了所有的out都只有一条记录，犯傻了，我好菜&gt;_&lt;🥺）</p><p>如果不使用临时文件的话，可以使用另一种方法：将所有的key value都处理好，然后使用一个二维数组进行存储，最后统一一次性创建文件然后将全部写入文件</p><p>也就是说如果不使用临时文件这一种方法的话，那么就将所有的kv都存在内存中，最后一起写入到文件中来避免并发问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoMap</span><span class="hljs-params">(mapffunc(<span class="hljs-type">string</span>,<span class="hljs-type">string</span>)</span></span> []KeyValue, raw Task) &#123;<span class="hljs-comment">//这里应该有并发问题,已经解决</span><br><br><span class="hljs-comment">//ps： 因为都在GFS里，所以知道了filename就可以直接读(自认为)</span><br><br>file, err := os.Open(raw.Filename)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><br>log.Fatalf(<span class="hljs-string">&quot;cannot open %v&quot;</span>, raw.Filename)<br><br>&#125;<br><br>content, err := io.ReadAll(file)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><br>log.Fatalf(<span class="hljs-string">&quot;cannot read %v&quot;</span>, raw.Filename)<br><br>&#125;<br><br>file.Close()<br><br>kva := mapf(raw.Filename,<span class="hljs-type">string</span>(content))<br><br><span class="hljs-comment">//intermediate = append(intermediate, kva...)</span><br><br><span class="hljs-comment">//create intermediate file  what&#x27;s the mean of k and y</span><br><br><span class="hljs-comment">// use json</span><br><br><span class="hljs-comment">//提前创建好文件</span><br><br>dir, _ := os.Getwd()<br><br>Mapfiles := []*os.File&#123;&#125;<br><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;raw.ReduceSum;i++&#123;<br><br>oname,_:=os.CreateTemp(dir,<span class="hljs-string">&quot;&quot;</span>)<br><br><span class="hljs-comment">//newfile, _ := os.Create(&quot;mr-&quot; + fmt.Sprint(raw.TaskNum)+ &quot;-&quot; + fmt.Sprint(i)) //use ihash to confirm reduceNum</span><br><br>Mapfiles = <span class="hljs-built_in">append</span>(Mapfiles,oname)<br><br>&#125;<br><br><span class="hljs-keyword">for</span> _, v :=<span class="hljs-keyword">range</span> kva &#123;  <span class="hljs-comment">//如果文件存在会将所有文件内容清空，所以不能每次都用create创建一个</span><br><br><span class="hljs-comment">//newfile, _ := os.Create(&quot;mr-&quot; + fmt.Sprint(raw.TaskNum)+ &quot;-&quot; + fmt.Sprint(ihash(v.Key)%raw.ReduceSum)) //use ihash to confirm reduceNum</span><br><br>f := Mapfiles[ihash(v.Key)%raw.ReduceSum]<br><br>enc := json.NewEncoder(f)<br><br>err := enc.Encode(&amp;v)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><br>log.Println(err)<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">for</span> i,v:=<span class="hljs-keyword">range</span> Mapfiles&#123;<br><br>err := os.Rename(v.Name(),fmt.Sprintf(<span class="hljs-string">&quot;mr-%d-%d&quot;</span>, raw.TaskNum, i)) <span class="hljs-comment">//use ihash to confirm reduceNum</span><br><br><span class="hljs-keyword">if</span> err!= <span class="hljs-literal">nil</span> &#123;<br><br>log.Println(err)<br><br>&#125;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>worker相对来说比较简单，这边就先简单的把我踩到的坑写出来给大家吸取教训，Doreduce等比较简单，这边就不再多提</p><p>接下来讲一下coodinator，我个人觉得这一块相较worker来说还是有点难度的，但也还好，100多行代码就能完成，因为我们只维护worker的状态</p><p>然后coodinator关键点在于task的分配，这里hint有提示，我们需要在确保map全部都完成后在分配reduce任务</p><p>这边提一下我在第三次测试是时候有一个job count 测试点过不去，他通过要求的map次数是8次，但是不知道为什么我的会执行出9次来</p><p>后面调了一节课，分析了一波问题有关的上下游，最后发现FinishedTask加的锁给他去掉就能够通过了</p><p>我在一开始写的时候也觉得并不是很有必要加锁，他都是改成true，就算有可能同时修改一个，那他们的结果也是相同的，都是修改成true，实际影响不大</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> FinishedTask(args *FinishArgs, reply *Task) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">//标记任务是否完成</span><br><span class="hljs-comment">//todo 有必要加锁吗， 确实是共享的变量</span><br><span class="hljs-comment">//事实证明是不需要加锁的</span><br><span class="hljs-keyword">switch</span> args.Ts.TaskType &#123;<br><span class="hljs-keyword">case</span> MapTask:<br>c.finishedMapfiles[args.Ts.TaskNum] = <span class="hljs-literal">true</span><br>fmt.Println(args.Ts.TaskNum)<br><br><span class="hljs-keyword">case</span> ReduceTask:<br>c.finishedReducefiles[args.Ts.TaskNum] = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是为什么这里加锁会导致出问题呢？</p><p>我个人分析，可能有不正确的地方，欢迎到gitee上指出</p><p>他的shell脚本会启动3个worker，进行并发，当其中6个都完成了只剩下最后一个没完成是，其中两个worker会在gettask中不断循环，循环会有checkfinish，checkfinish也会对isfinish数组进行访问，此时rpc调用完成借口并且加锁，可能是导致不能及时讲任务的isfinish数组设置true的原因</p><p>最后附上我的结构体定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Coordinator <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Your definitions here.</span><br>mu sync.Mutex<br>nReduce <span class="hljs-type">int</span> <span class="hljs-comment">//how much tasks need to done </span><br>files    []<span class="hljs-type">string</span><br>finishedMapfiles []<span class="hljs-type">bool</span><br>TimesfinishedMapfiles []time.Time<br>finishedReducefiles []<span class="hljs-type">bool</span><br>TimesfinishedReducefiles []time.Time<br>Isdone <span class="hljs-type">bool</span> <span class="hljs-comment">//是否全部完成</span><br><br>&#125;<br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>TaskType   TaskType   <br>TaskNum <span class="hljs-type">int</span>     <span class="hljs-comment">//任务的序号</span><br>ReduceSum <span class="hljs-type">int</span> <span class="hljs-comment">//the sum of tasks needed to reduce</span><br>MapSum <span class="hljs-type">int</span> <span class="hljs-comment">// the sum of tasks needed to map</span><br>Filename   <span class="hljs-type">string</span>   <br>&#125;<br><br><span class="hljs-keyword">type</span> TaskArgs <span class="hljs-keyword">struct</span>&#123;<br>TaskType   TaskType   <br>TaskNum <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> FinishArgs <span class="hljs-keyword">struct</span>&#123;<br>Ts Task<br>&#125;<br><br><span class="hljs-keyword">type</span> TaskType <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>MapTask TaskType = <span class="hljs-literal">iota</span><br>ReduceTask<br>CompleteTask    <br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.824</tag>
      
      <tag>lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法题型思路总结</title>
    <link href="/2023/09/19/%E7%AE%97%E6%B3%95%E9%A2%98%E5%9E%8B%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/19/%E7%AE%97%E6%B3%95%E9%A2%98%E5%9E%8B%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>用于记录个人刷到用时较长或者没有思路的题目记录一下解题思路</p><p>前期用c++刷了一部分剑指offer的题目，后期看要不全转go吧</p><p>记录 9.25 开始刷leetcode热题100 ， 剑指offer差模拟，位运算和其他算法  现已切换到go</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>题目索引 : <a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=23291&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13"><strong>字符串的排列</strong></a></p><p>只能说回溯忘的差不多了，通过这题来回顾一下</p><p>这边主要是用到了一个set，通过set集合来去除重复的部分，让题目变的更加简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param str string字符串</span><br><span class="hljs-comment">     * @return string字符串vector</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-type">int</span> book[<span class="hljs-number">10</span>];<br>    set&lt;string&gt; v;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string tmp, string str, vector&lt;<span class="hljs-type">int</span>&gt; vis)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (tmp.<span class="hljs-built_in">size</span>() == str.<span class="hljs-built_in">size</span>()) &#123;<br>            v.<span class="hljs-built_in">insert</span>(tmp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (vis[i])<br>                <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">//标记为使用过</span><br>            vis[i] = <span class="hljs-number">1</span>;  <br>            <span class="hljs-comment">//加入临时字符串</span><br>            tmp.<span class="hljs-built_in">push_back</span>(str[i]);<br>            <span class="hljs-built_in">dfs</span>( tmp, str, vis);<br>            <span class="hljs-comment">//回溯</span><br>            vis[i] = <span class="hljs-number">0</span>;<br>            tmp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br><br>    &#125;<br><br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>    <br>        <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">empty</span>()) &#123;<br>           <span class="hljs-keyword">return</span>  vector&lt;string&gt;&#123;&#125;;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(str.size(), <span class="hljs-number">0</span>)</span></span>;<br>        string tmp;<br>    <br>        <span class="hljs-built_in">dfs</span>(tmp, str, vis);<br><br>        <span class="hljs-keyword">return</span> vector&lt;string&gt;&#123;v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>()&#125;;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h3><p>题目链接： <a href="https://www.nowcoder.com/practice/48d2ff79b8564c40a50fa79f9d5fa9c7?tpId=13&tqId=2276769&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">最长不含重复字符的子字符串</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param s string字符串 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span> &gt;m;<br>        <span class="hljs-type">int</span> length = <span class="hljs-number">0</span> ;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            m[s[i]]++;<br>            right = i;<br>            <span class="hljs-keyword">while</span> (m[s[i]]&gt;<span class="hljs-number">1</span>) &#123;<br>                m[s[left++]]--;<br><br>            &#125;<br>             <span class="hljs-type">int</span> m_size = m.<span class="hljs-built_in">size</span>();<br>            length = <span class="hljs-built_in">max</span>(length,right - left +<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h3><p>题目连接 ：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">找到字符串中所有字母异位词</a></p><p>自己的只通过了62&#x2F;65个测试用例 ，后面节省时间直接看答案了，发现答案写的比我写的简洁多了 QAQ</p><p>大体思路是差不多的，可能我有些详解没处理好吧，插个眼后面再来一遍</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findAnagrams</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p <span class="hljs-type">string</span>)</span></span>(ans []<span class="hljs-type">int</span>) &#123;<br> sLen, pLen := <span class="hljs-built_in">len</span>(s), <span class="hljs-built_in">len</span>(p)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) &lt; <span class="hljs-built_in">len</span>(p) &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> sCount, pCount [<span class="hljs-number">26</span>]<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> p &#123;<br>        sCount[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>        pCount[ch-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>    &#125;<br><span class="hljs-keyword">if</span> sCount == pCount &#123;<br>        ans = <span class="hljs-built_in">append</span>(ans, <span class="hljs-number">0</span>)<br>    &#125;<br><br> <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> s[:sLen-pLen] &#123;<br>        sCount[ch-<span class="hljs-string">&#x27;a&#x27;</span>]--<br>        sCount[s[i+pLen]-<span class="hljs-string">&#x27;a&#x27;</span>]++<br>        <span class="hljs-keyword">if</span> sCount == pCount &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, i+<span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br><br><br><span class="hljs-keyword">return</span> ans<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="和为-K-的子数组"><a href="#和为-K-的子数组" class="headerlink" title="和为 K 的子数组"></a>和为 K 的子数组</h3><p>题目连接 ： <a href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为 K 的子数组</a></p><p>利用前缀和 与 map 降低复杂度</p><p>pre[i] - pre[j] &#x3D;&#x3D;k</p><p>通过map来记录 m[pre[i]-k]是否存在 ，以及有多少个等于这个值的前缀和</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m:=<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">var</span> pre <span class="hljs-type">int</span><br>    pre = <span class="hljs-number">0</span><br>    count:= <span class="hljs-number">0</span><br>    m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(nums);i++&#123;<br>        pre = pre+nums[i]<br>        v,ok:=m[pre-k]<br>        <span class="hljs-keyword">if</span> ok &#123;<br>            count+=v<br>        &#125;<br>     m[pre] += <span class="hljs-number">1</span><br>    &#125;<br><span class="hljs-keyword">return</span> count<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h3><p>题目链接：<a href="https://leetcode.cn/problems/minimum-window-substring/">最小覆盖子串</a></p><p>自己花了挺长时间才做出来，记录下思路</p><p>其实看到这题的想法是正确的，滑动窗口，map记录</p><p>但是这个窗口怎么定，我一开始的思路是不太好的，我一开始规定了窗口的大小</p><p>然后看了题解的，一开始将窗口定为0，然后如果没有包含字串就移动右指针，如果包含就移动左指针找最小子串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minWindow</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>)<br>left, right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>minn := <span class="hljs-number">99999999</span><br>idx_left, idx_right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> t &#123;<br>m[<span class="hljs-type">byte</span>(v)]++<br>&#125;<br><br>count := <span class="hljs-number">0</span><br>_, ok := m[s[<span class="hljs-number">0</span>]]<br><span class="hljs-keyword">if</span> ok &#123;<br>m2[s[<span class="hljs-number">0</span>]]++<br><span class="hljs-keyword">if</span> m2[s[<span class="hljs-number">0</span>]] == m[s[<span class="hljs-number">0</span>]] &#123;<br>count++<br>&#125;<br>&#125;<br>right++<br><span class="hljs-keyword">for</span> right &lt;= <span class="hljs-built_in">len</span>(s) &#123;<br><span class="hljs-keyword">if</span> count == <span class="hljs-built_in">len</span>(m) &#123;<br><span class="hljs-keyword">if</span> minn &gt; right-left+<span class="hljs-number">1</span> &#123;<br>minn = right - left + <span class="hljs-number">1</span><br>idx_left = left<br>idx_right = right<br>&#125;<br>_, ok := m[s[left]]<br><span class="hljs-keyword">if</span> ok &#123;<br>m2[s[left]]--<br><span class="hljs-keyword">if</span> m2[s[left]] &lt; m[s[left]] &#123;<br>count--<br>&#125;<br>&#125;<br>left++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> right == <span class="hljs-built_in">len</span>(s) &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>_, ok := m[s[right]]<br><span class="hljs-keyword">if</span> ok &#123;<br>m2[s[right]]++<br><span class="hljs-keyword">if</span> m2[s[right]] == m[s[right]] &#123;<br>count++<br>&#125;<br>&#125;<br>right++<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> s[idx_left:idx_right]<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="数字序列中某一位的数字-模拟题"><a href="#数字序列中某一位的数字-模拟题" class="headerlink" title="数字序列中某一位的数字 (模拟题)"></a><strong>数字序列中某一位的数字</strong> (模拟题)</h3><p>题目链接：<a href="https://www.nowcoder.com/practice/29311ff7404d44e0b07077f4201418f5?tpId=13&tqId=2285751&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13"><strong>数字序列中某一位的数字</strong></a></p><p>这题难点主要是时间复杂度怎么降下来，不然当n等于10亿的时候会超时</p><p>我也是看了大佬的题解</p><p>1到9有9个数 9个单个数字</p><p>10到99 有 90个个数 ， 180个单个数字</p><p>100到999有900个个数， 2700个单个数字，由此类推</p><p>我们只需要将n与当前阶段所有的单个数字做个比较</p><p>当n小于当前阶段所有的单个数字后，就说明n在这个范围内</p><p>然后我们通过 n&#x2F;count（count表示当前阶段是几位数）来确定n所在是数是多少</p><p>通过n%count来确定n表示的是所在数的第几个数字</p><p>这边尤其要注意n得减去一，因为数组的下标是从0开始的，如果不减去1的话会越界</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param n int整型 </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findNthDigit</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> deep = <span class="hljs-number">9</span>;<br>        <span class="hljs-type">int</span> num =<span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span>  sum = <span class="hljs-number">9</span>;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span> ;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (n&gt;sum) &#123;<br>           n-=sum;<br>           deep*=<span class="hljs-number">10</span>;<br>           count ++;<br>           sum = deep*count;<br>        &#125;<br>       <span class="hljs-type">int</span> index =  (n<span class="hljs-number">-1</span>)/count;<br>       string ans =    <span class="hljs-built_in">to_string</span>(deep/<span class="hljs-number">9</span> + index);<br>       n= (n<span class="hljs-number">-1</span>)%count;<br><br>        <span class="hljs-keyword">return</span> ans[n] -<span class="hljs-string">&#x27;0&#x27;</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/"> 搜索旋转排序数组</a></p><p>双二分搜索写法，怎么说呢，还是实现的不够优雅</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMin</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">-1</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> <span class="hljs-comment">// 开区间 (-1, n-1)</span><br>    <span class="hljs-keyword">for</span> left+<span class="hljs-number">1</span> &lt; right &#123; <span class="hljs-comment">// 开区间不为空</span><br>        mid := left + (right-left)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>] &#123; <br>            right = mid<br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            left = mid<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    mi := findMin(nums)<br>    left := <span class="hljs-number">0</span> <br>    right := <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">if</span> target &gt; nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>] &#123;<br>        right = mi<span class="hljs-number">-1</span><br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        left = mi<br>    &#125;<br>    mid := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        mid  = (left + right)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span> nums[mid]&lt;target &#123;<br>                left = mid + <span class="hljs-number">1</span> <br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                left = mid <br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">if</span> nums[left] == target&#123;<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>插个眼记得补档只用一次二分搜索的情况 </p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><blockquote><p>个人对于这一块比较薄弱，所以开始可能会比较多的题目以及这些题目可能在后面基础扎实了后会觉得非常简单的题目，见谅~</p></blockquote><h3 id="JZ42-连续子数组的最大和"><a href="#JZ42-连续子数组的最大和" class="headerlink" title="JZ42 连续子数组的最大和"></a>JZ42 连续子数组的最大和</h3><p>题目链接： <a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=23259&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">连续子数组的最大和</a></p><p> 重新捡起动态规划的第一题。之前有一定的动态规划基础，所以见到这题就想用状态机，上来就来一个book[30000][2],来表示选或者不选对应的数，但发现无从下手（题刷少了，思维还是太僵硬了）</p><p>后直接看大佬的解析，然后领会到了意思后，很快就写出来了</p><p>因为是选数都要是连续的，所以我们可以将array[i]作为当前子数组dp[i]的结尾，这样的话就能构成递推关系了，我们只需要将array[i]和dp[i-1]+array[i]进行对比取最大的就可以得到dp[i]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param array int整型vector </span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-type">int</span> dp[<span class="hljs-number">30000</span>];<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; array)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        dp[<span class="hljs-number">0</span>]= array[<span class="hljs-number">0</span>];<br>         <span class="hljs-type">int</span> max1 = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i&lt;array.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>]+array[i],array[i]);<br>            <span class="hljs-keyword">if</span> (max1&lt;dp[i]) &#123;<br>               max1 = dp[i];<br>            &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">return</span> max1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="买股票的最佳时机"><a href="#买股票的最佳时机" class="headerlink" title="买股票的最佳时机"></a>买股票的最佳时机</h3><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><p>题目链接： <a href="https://leetcode.cn/problems/target-sum/">目标和</a></p><p>经过数学转换后就是01背包问题</p><p>递归解法 ： 时间复杂度很差</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>,index <span class="hljs-type">int</span> )</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span>  &#123;<br>         <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <br>    &#125;<br>   <br>    <span class="hljs-keyword">if</span> nums[index]&gt; target &#123;<br>        <span class="hljs-keyword">return</span> dfs(nums,target,index<span class="hljs-number">-1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(nums,target,index<span class="hljs-number">-1</span>)+dfs(nums,target-nums[index],index<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//设选择的正数的和是p</span><br>    <span class="hljs-comment">//那么负数的和就是s , 总和是t    s = t -p </span><br>    <span class="hljs-comment">//所以  target =  p - t +p = 2p - t   p = (target+t) /2</span><br>    t :=  <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> _,v :=  <span class="hljs-keyword">range</span> nums&#123;<br>        t+=v<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (target + t )%<span class="hljs-number">2</span>!= <span class="hljs-number">0</span>  &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <br>    <span class="hljs-keyword">return</span>  dfs(nums,(target+t)/<span class="hljs-number">2</span>,<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>动态规划解法，时间复杂度已经是最优的了，占用内存比上面的大些</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">//设选择的正数的和是p</span><br>    <span class="hljs-comment">//那么负数的和就是s , 总和是t    s = t -p </span><br>    <span class="hljs-comment">//所以  target =  p - t +p = 2p - t   p = (target+t) /2</span><br>    t :=  <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> _,v :=  <span class="hljs-keyword">range</span> nums&#123;<br>        t+=v<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (target + t )%<span class="hljs-number">2</span>!= <span class="hljs-number">0</span> || target+t &lt; <span class="hljs-number">0</span>  &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125; <br>    target =  (target + t )/<span class="hljs-number">2</span><br>    <span class="hljs-keyword">var</span> dp [<span class="hljs-number">21</span>][<span class="hljs-number">1100</span>]<span class="hljs-type">int</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] =<span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i,v :=  <span class="hljs-keyword">range</span> nums&#123;<br>        <span class="hljs-keyword">for</span> j:= <span class="hljs-number">0</span> ;j&lt;target+<span class="hljs-number">1</span> ; j++&#123;<br>            <span class="hljs-keyword">if</span> j &lt; v &#123;<br>                dp[i+<span class="hljs-number">1</span>][j] = dp[i][j]<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i+<span class="hljs-number">1</span>][j] = dp[i][j] + dp[i][j-v]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)][target]  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h3><p>题目链接：<a href="https://leetcode.cn/problems/word-break/">单词拆分</a></p><p>代码很少，看起来也很简单，但是我当时在做的时候没思路QAQ，还是动态规划题刷太少了</p><p>用dp，先取字符串的子串，然后判断字串能否被字典里的字符串拼接表示</p><p>我当时觉得难主要是想着一个字符串可以拆成”l” “e” e” “t”等等，拆出非常多来</p><p>但后面发现其实都是子问题罢了 :joy:</p><p>还是太菜了，要狠狠的刷题！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(s <span class="hljs-type">string</span>, wordDict []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br>    <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> wordDict &#123;<br>         m[v] = <span class="hljs-literal">true</span><br>    &#125;<br>    dp:=<span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>,<span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(s);i++ &#123;<br>        <span class="hljs-keyword">for</span> j :=<span class="hljs-number">0</span> ; j&lt;i;j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[j]&amp;&amp;m[s[j:i]]&#123;<br>                dp[i] = <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></p><p>时间复杂度和空间复杂度都比较差的做法，用了两个循环 O(n^2)</p><p>dp[i]表示当前以第 <em>i</em>个数字结尾的最长上升子序列的长度</p><p>所以如果nums[i]&gt; nums[j] 那么会有dp[i] &#x3D; dp[j]+1 (如果比dp【i】大的话)</p><p>自己当时做的时候想到了dp【i】的含义，但是就过程怎么计算出了点问题</p><p>还可以进行优化，插个眼</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>     <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br>dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums)+<span class="hljs-number">1</span>)<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>m := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>dp[i] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br><span class="hljs-keyword">if</span> nums[j] &lt; nums[i] &#123;<br>dp[i] = max(dp[i], dp[j]+<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br>m = max(m, dp[i])<br>&#125;<br><span class="hljs-keyword">return</span> m<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span> )</span></span><span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a&lt;b&#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span>  a<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="把数字翻译成字符串"><a href="#把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a><strong>把数字翻译成字符串</strong></h3><p>题目链接：<a href="https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=13&tqId=1024831&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">把数字翻译成字符串</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;streambuf&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 解码</span><br><span class="hljs-comment">     * @param nums string字符串 数字串</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>   <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string nums)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>          <span class="hljs-type">int</span> dp[nums.<span class="hljs-built_in">size</span>()] ;<br>          <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>        <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                dp[i] += dp[i -<br>                            <span class="hljs-number">1</span>]; <span class="hljs-comment">// 如果nums[i]不为0，那么就可以单独作为一个数进行解析</span><br>            &#125;<br><br>            <span class="hljs-comment">//接着判断是否可以和nums[i-1]进行组合翻译</span><br>            <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                string str;<br>                str.<span class="hljs-built_in">push_back</span>(nums[i - <span class="hljs-number">1</span>]);<br>                str.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">stoi</span>(str) &gt;= <span class="hljs-number">10</span> &amp;&amp; <span class="hljs-built_in">stoi</span>(str) &lt;= <span class="hljs-number">26</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//即f(2)，因为不存在f(0)，所以需要特殊处理：</span><br>                        dp[i] += <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        dp[i] += dp[i - <span class="hljs-number">2</span>];<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br><br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>];<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p>题目链接： <a href="https://leetcode.cn/problems/perfect-squares/">完全平方数</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,n+<span class="hljs-number">1</span>)<br>    m[<span class="hljs-number">0</span>] =<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=n;i++ &#123;<br>        minn:= math.MaxInt32<br>        <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span>; j*j&lt;=i;j++ &#123;<br>            minn = min(minn,m[i-j*j])<br>        &#125;<br>        m[i] = minn+<span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> m[n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span> )</span></span> <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a&lt;b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/maximum-product-subarray/">乘积最大子数组</a></p><p>题解的思路非常的巧妙简洁</p><p>题解用了两种状态进行记录而不是一种</p><p>并且使用滚动数组将空间复杂度降到了O(1), 因为包含当前下标乘积dp[i] 和他的前一个dp[i-1]是强相关的</p><p>为什么使用两种状态会是使得代码变得更简洁更优雅</p><p>使用一种状态的话，对于nums[i]大于等于0的时候是没有影响的</p><p>但是当nums[i]小于0的时候，dp[i]和dp[i-1]不是强相关的</p><p>如果dp[i]是正的，如果使用nums[i]大于0的递推公式，那么比如 -2 3 -4  ，会因为dp[1] &#x3D;3 ,3* -4 &#x3D; -12 而使得dp[2] &#x3D; -4,但是实际上dp[2]&#x3D; -2* 3 *-4 &#x3D; 24</p><p>如果要处理的话要加很多条件语句进行判断</p><p>但如果使用两种状态的话，比如定义一个max和min ，分别用于计入下标i之前最大值和最小值</p><p>当nums[i]大于0的时候，乘上最大值，那么得到的就是dp[i]的最大值</p><p>当nums[i]是小于0时，可以尝试乘上最小值，如果最小值是小于0的，那么就会的到一个最大值，这样就可以解决nums[i]为负数的问题</p><p>引入一个最小值的状态，可谓是画龙点睛之笔</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>m := nums[<span class="hljs-number">0</span>]<br>    mi:=  nums[<span class="hljs-number">0</span>]<br>    ans := nums[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;    <br>    mx, mn := m, mi<br>m= max(max(nums[i], mx*nums[i]),nums[i]*mn)<br>    mi = min( min(nums[i], mn*nums[i]),mx*nums[i])     <br>         ans =max(ans,m)<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span> )</span></span><span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a&lt;b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a,b <span class="hljs-type">int</span> )</span></span><span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a&gt;b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/partition-equal-subset-sum/">分割等和子集</a></p><p>虽然一次就做出了并且ac了，并且代码也还算优雅</p><p>但一看时间复杂度和空间复杂度。。。我太菜了还是QAQ</p><p>记录一下自己的解法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">//就是个类0-1背包</span><br>count := <span class="hljs-number">0</span><br>ans := <span class="hljs-literal">false</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>count += v<br>&#125;<br><span class="hljs-keyword">if</span> count%<span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br><span class="hljs-keyword">var</span> dp [<span class="hljs-number">210</span>][<span class="hljs-number">20010</span>]<span class="hljs-type">int</span><br>dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]] = nums[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; count; j++ &#123;<br><span class="hljs-keyword">if</span> dp[i<span class="hljs-number">-1</span>][j] != <span class="hljs-number">0</span> &#123;<br>dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]<br>&#125;<br><span class="hljs-keyword">if</span> dp[i<span class="hljs-number">-1</span>][j] != <span class="hljs-number">0</span> &amp;&amp; dp[i][j]+nums[i] == dp[i<span class="hljs-number">-1</span>][j]+nums[i] &#123;<br>dp[i][j+nums[i]] = dp[i<span class="hljs-number">-1</span>][j] + nums[i]<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> dp[i][count/<span class="hljs-number">2</span>] == count/<span class="hljs-number">2</span> &#123;<br>ans = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><p>优化插个眼</p><h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">最长回文子序列</a></p><p>一开始从第5题直接跳到516题来的，以为题目意思基本相同，只是这题是求最长回文串的长度而已</p><p>但后面发现这题求的是“序列”的长度，所相对来讲更加简单</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s))<br>    &#125;<br>    <span class="hljs-keyword">for</span> a:= <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span> ;a&gt;=<span class="hljs-number">0</span>;a-- &#123;<br>        dp[a][a] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> b := a+<span class="hljs-number">1</span>;b&lt;<span class="hljs-built_in">len</span>(s);b++ &#123;<br><br>        <span class="hljs-keyword">if</span> s[a] == s[b] &#123;<br>            dp[a][b] =  dp[a+<span class="hljs-number">1</span>][b<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span> <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>             dp[a][b] =  max(dp[a+<span class="hljs-number">1</span>][b],dp[a][b<span class="hljs-number">-1</span>])<br>        &#125;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span>  dp[<span class="hljs-number">0</span>][<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子序列</a></p><p>子序列问题，只需要满足顺序是一样的即可，不需要保证连续</p><p>体会感觉还不是很深刻，回去看看灵神的视频再理解理解</p><p>好的，这下理解了！</p><p>i，j表示在text1的i，和text2的j之前的最长公共子序列是多少</p><p>如果下标为i，和j对应的字母不相等，那么他的最长公共子序列就是i-1，j或者j-1，i对应的最长公共子序列，为什么没有i-1，j-1？看下图应该就懂了 –&gt;i-1，j-1已经被包含在内了</p><p><img src="https://cdn.jsdelivr.net/gh/MadFrey/homework.img/Screenshot%202023-11-23%20100423.png"></p><p>然后是为什么text1[i] &#x3D;&#x3D; text[2] 时我们只需要让<code>ans[i-1][j-1]+1</code>就行？</p><p>如果j与i-1之前的任何一个匹配上了，那么此时Lcs为m &#x3D; 【j,i-1】</p><p>若j放弃匹配i-1之前的数，转而匹配i，那么因为j不匹配了，所以此时为【j-1，i-1】 &#x3D; m-1</p><p>如果一开始j就没有任何i-1及其之前的数和他匹配，此时【j,i-1】 &#x3D; 【j-1,i-1】</p><p>所以此时【i，j】 &#x3D; 【i-1,j-1】+1 </p><p>j,i-1和j-1,i都同理</p><p>综上可以得出结论text1[i] &#x3D;&#x3D; text[2]，只需要让LCS &#x3D; <code>ans[i-1][j-1]+1</code>就行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> ans [][]<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(text1))<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ans &#123;<br>ans[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(text2))<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(text1); i++ &#123;<br><span class="hljs-keyword">if</span> text1[i] == text2[<span class="hljs-number">0</span>] ||(i&gt;<span class="hljs-number">0</span> &amp;&amp;ans[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>ans[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ans[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(text2); i++ &#123;<br><span class="hljs-keyword">if</span> text1[<span class="hljs-number">0</span>] == text2[i] || (i&gt;<span class="hljs-number">0</span> &amp;&amp;ans[<span class="hljs-number">0</span>][i<span class="hljs-number">-1</span>]== <span class="hljs-number">1</span>) &#123;<br>ans[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ans[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(text1); i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j != <span class="hljs-built_in">len</span>(text2); j++ &#123;<br><span class="hljs-keyword">if</span> text1[i] == text2[j] &#123;<br>ans[i][j] = ans[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ans[i][j] = max(ans[i<span class="hljs-number">-1</span>][j], ans[i][j<span class="hljs-number">-1</span>])<br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">return</span> ans[<span class="hljs-built_in">len</span>(text1)<span class="hljs-number">-1</span>][<span class="hljs-built_in">len</span>(text2)<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/edit-distance/">编辑距离</a></p><p>等价替换</p><p>给我好好分析下这题！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-type">string</span>, word2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> ans [][]<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ans &#123;<br>ans[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(word1); i++ &#123;<br>ans[<span class="hljs-number">0</span>][i] = i <br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(word2); i++ &#123;<br>ans[i+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = i + <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(word1); j++ &#123;<br><span class="hljs-keyword">if</span> word2[i] == word1[j] &#123;<br>ans[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = ans[i][j]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ans[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = min(ans[i][j+<span class="hljs-number">1</span>], min(ans[i][j], ans[i+<span class="hljs-number">1</span>][j])) + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">return</span> ans[<span class="hljs-built_in">len</span>(word2)][<span class="hljs-built_in">len</span>(word1)]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h3><p>题目链接 ：<a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=23260&ru=/exam/oj/ta&qru=/ta/coding-interviews/question-ranking&sourceUrl=/exam/oj/ta?page=1&tpId=13&type=13">数组中的逆序对</a></p><p>使用到了归并排序的思想 （然而平时不怎么用，忘的差不多了。。 回顾一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param nums int整型vector</span><br><span class="hljs-comment">     * @return int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; sourceArr, <span class="hljs-type">int</span> tempArr[], <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> midIndex,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-type">int</span> endIndex)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = startIndex, j = midIndex + <span class="hljs-number">1</span>, k = startIndex;<br>        <span class="hljs-keyword">while</span> (i != midIndex + <span class="hljs-number">1</span> &amp;&amp; j != endIndex + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (sourceArr[i] &gt; sourceArr[j]) &#123;<br>                tempArr[k++] = sourceArr[j++];<br>                count+=midIndex-i+<span class="hljs-number">1</span>;<br>                count %= <span class="hljs-number">1000000007</span>;<br>            &#125; <span class="hljs-keyword">else</span><br>                tempArr[k++] = sourceArr[i++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i != midIndex + <span class="hljs-number">1</span>)<br>            tempArr[k++] = sourceArr[i++];<br>        <span class="hljs-keyword">while</span> (j != endIndex + <span class="hljs-number">1</span>)<br>            tempArr[k++] = sourceArr[j++];<br>        <span class="hljs-keyword">for</span> (i = startIndex; i &lt;= endIndex; i++)<br>            sourceArr[i] = tempArr[i];<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; sourceArr, <span class="hljs-type">int</span> tempArr[], <span class="hljs-type">int</span> startIndex,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-type">int</span> endIndex)</span> </span>&#123;<br>        <span class="hljs-type">int</span> midIndex;<br>        <span class="hljs-keyword">if</span> (startIndex &lt; endIndex) &#123;<br>            midIndex = startIndex + (endIndex - startIndex) / <span class="hljs-number">2</span>; <br>            <span class="hljs-built_in">MergeSort</span>(sourceArr, tempArr, startIndex, midIndex);<br>            <span class="hljs-built_in">MergeSort</span>(sourceArr, tempArr, midIndex + <span class="hljs-number">1</span>, endIndex);<br>            <span class="hljs-built_in">Merge</span>(sourceArr, tempArr, startIndex, midIndex, endIndex);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> b[nums.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">MergeSort</span>(nums, b, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/two-sum/solutions/434597/liang-shu-zhi-he-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked">两数之和</a></p><p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p><p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N)O(N) 降低到 O(1)O(1)O(1)。</p><p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>      <span class="hljs-keyword">var</span> m  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>        <span class="hljs-keyword">for</span> i,v := <span class="hljs-keyword">range</span> nums&#123;<br>           index ,ok:= m[target-v];<br>           <span class="hljs-keyword">if</span> !ok &#123;<br>             m[v] = i;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>             <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;index,i&#125;<br>           &#125;<br>        &#125;<br><br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked">字母异位词分组</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(strs []<span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">var</span> m  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>)<br>    <span class="hljs-keyword">var</span> str [][]<span class="hljs-type">string</span><br>   <br>    <span class="hljs-keyword">for</span> _,v:=<span class="hljs-keyword">range</span> strs&#123;<br>        chars := []<span class="hljs-type">byte</span>(v)<br>        sort.Slice(chars,<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i,j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>&#123;<br>             <span class="hljs-keyword">return</span> chars[i] &lt; chars[j]<br>        &#125;)<br>         sortedStr := <span class="hljs-type">string</span>(chars)<br>        m[sortedStr] = <span class="hljs-built_in">append</span>(m[sortedStr],v)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _,v := <span class="hljs-keyword">range</span> m&#123;<br>        str=<span class="hljs-built_in">append</span>(str,v)<br>    &#125; <br>         <br>    <span class="hljs-keyword">return</span> str<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h3><p> 题目链接 <a href="https://leetcode.cn/problems/longest-consecutive-sequence/">最长连续序列</a></p><p>我的解法 O(nlogn + n)   </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>     <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>     <span class="hljs-built_in">len</span> := <span class="hljs-number">0</span><br>     sort.Ints(nums)<br>    <span class="hljs-keyword">for</span> _ ,v := <span class="hljs-keyword">range</span> nums&#123;<br>        _,ok := m[v<span class="hljs-number">-1</span>]<br>        <span class="hljs-keyword">if</span> !ok &#123;<br>            m[v]=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>&lt;m[v])&#123;<br>                <span class="hljs-built_in">len</span>= m[v]<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            m[v]=m[v<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span><br>             <span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>&lt;m[v])&#123;<br>                <span class="hljs-built_in">len</span>= m[v]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span><br>&#125;<br></code></pre></td></tr></table></figure><p>O(n)或者说O(2n)解法  </p><p>这边是直接复制题解的，其实两种方法大差不差，都是根据m[i-1]来判断长度，这个就是将排序换成了初始化map，然后每次会重新统计总数</p><p>但是这种解法确实会比我的更加节省内存，以及确实更快</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        m[v] = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">var</span> maxCount <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> tmpCount <span class="hljs-type">int</span><br>    <span class="hljs-keyword">for</span> num := <span class="hljs-keyword">range</span> m &#123;<br>        <span class="hljs-keyword">if</span> m[num<span class="hljs-number">-1</span>] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        tmpCount = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> m[num] &#123;<br>            num++<br>            tmpCount++<br>        &#125;<br>        <span class="hljs-keyword">if</span> tmpCount &gt; maxCount &#123;<br>            maxCount = tmpCount<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxCount<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><p>题目链接 <a href="https://leetcode.cn/problems/move-zeroes/">移动零</a></p><p>个人解法，时间复杂度和空间复杂度都高了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>     length := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span>  i:=<span class="hljs-number">0</span>;i&lt;length; &#123;<br>        <span class="hljs-keyword">if</span> nums[i]==<span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> i==length &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            <span class="hljs-keyword">for</span>  j := i;j&lt;length<span class="hljs-number">-1</span>;j++&#123;<br>                temp :=  nums[j]<br>                nums[j]=nums[j+<span class="hljs-number">1</span>]<br>                nums[j+<span class="hljs-number">1</span>]=temp<br>            &#125;<br>            length--<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i++<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>更快更简单的解法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>     length := <span class="hljs-built_in">len</span>(nums)<br>     left:=<span class="hljs-number">0</span><br>     right :=<span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> left&lt;length&amp;&amp;right&lt;length &#123;<br>        <span class="hljs-keyword">if</span> nums[right] != <span class="hljs-number">0</span> &#123;<br>            nums[left], nums[right] = nums[right], nums[left]   <span class="hljs-comment">//这样写会更加节省时间</span><br>            left++<br>        &#125;<br>        right++<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/3sum/">三数之和</a></p><p>突然发现灵神讲的确实挺不错的，看他的讲三数之和的视频没到一半就懂了 ，很透彻，有引导</p><p>强烈推荐  <a href="https://www.bilibili.com/video/BV1bP411c7oJ/?vd_source=9b4c75905899e9c060de474426e69d22">灵神视频</a></p><p>灵神视频里提到一个点：<strong>如果数组是有序的就可以使用相向双指针了</strong> ， 感觉还是挺有用的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>sort.Ints(nums) <span class="hljs-comment">//排好序后就可以使用相向双指针了</span><br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> ans [][]<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>; i++ &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>k := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>j := i + <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> j &lt; k &#123;<br><span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="hljs-number">0</span> &#123;<br>ans = <span class="hljs-built_in">append</span>(ans, []<span class="hljs-type">int</span>&#123;nums[i], nums[j], nums[k]&#125;)<br>j++<br><span class="hljs-keyword">for</span> j&lt;k&amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>j++<br>&#125;<br>k--<br><span class="hljs-keyword">for</span> k&gt;j&amp;&amp; nums[k] == nums[k+<span class="hljs-number">1</span>] &#123;<br>k--<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[k] &lt; <span class="hljs-number">0</span> &#123;<br>j++<br><span class="hljs-keyword">for</span> j&lt;k&amp;&amp;nums[j] == nums[j<span class="hljs-number">-1</span>] &#123;<br>j++<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> nums[i]+nums[j]+nums[k] &gt; <span class="hljs-number">0</span> &#123;<br>k--<br><span class="hljs-keyword">for</span>  k&gt;j&amp;&amp;nums[k] == nums[k+<span class="hljs-number">1</span>] &#123;<br>k--<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/trapping-rain-water/">接雨水</a></p><p>通过移动左右双指针来找两边的max高度，因为小于max高度就说明该高度是可能可以接水的</p><p>由因为木桶效应，能不能接水关键取决于最短的那条边，所以我们通过对pre_max和suf_max进行后，对小的那边进行运算，max减去height就是可以接的雨水</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left :=<span class="hljs-number">0</span> <br>    right := <span class="hljs-built_in">len</span>(height)<span class="hljs-number">-1</span><br>    pre_max := <span class="hljs-number">0</span><br>    suf_max := <span class="hljs-number">0</span><br>    ans :=<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> left&lt;=right&#123;<br>      pre_max = max(pre_max,height[left])<br>      suf_max = max(suf_max,height[right])<br>      <span class="hljs-keyword">if</span> pre_max &lt; suf_max&#123;<br>        ans +=pre_max - height[left]<br>        left++<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        ans+=suf_max-height[right]<br>        right--<br>      &#125;<br>     <br>    &#125;<br><br>  <span class="hljs-keyword">return</span> ans<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span> &#123;<br>  <span class="hljs-keyword">if</span> a&lt;b&#123;<br>    <span class="hljs-keyword">return</span> b<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> a<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h3><p>题目连接 ：<a href="https://leetcode.cn/problems/set-matrix-zeroes/">矩阵置零</a></p><p>这题要想实现常数级的空间复杂度，需要复用matrix的空间，用第一行和第一列进行标记该行或该列是否有值为0的数</p><p>在标记完成后，再通过一轮遍历完成赋值0，最后再对第一行和第一列进行处理，避免发生覆盖</p><p>这边要注意的一个点就是在赋值的时候记得把<code>matrix[0][0]</code>给跳过了，不然如果这个地方的值为0，将会发生覆盖现象，因为这个点会先处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @Author: lrc</span><br><span class="hljs-comment"> * @Date: 2023/9/25-14:29</span><br><span class="hljs-comment"> * @Desc:</span><br><span class="hljs-comment"> **/</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> &#123;<br>flag_h := <span class="hljs-number">0</span><br>flag_l := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]); i++ &#123;<br><span class="hljs-keyword">if</span> flag_h == <span class="hljs-number">0</span> &amp;&amp; matrix[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span> &#123;<br>flag_h = <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br><span class="hljs-keyword">if</span> flag_l == <span class="hljs-number">0</span> &amp;&amp; matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &#123;<br>flag_l = <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> matrix &#123;<br><span class="hljs-keyword">for</span> j, va := <span class="hljs-keyword">range</span> v &#123;<br><span class="hljs-keyword">if</span> va == <span class="hljs-number">0</span> &#123;<br>matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// matrix[0][0]有影响</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> matrix &#123;<br><span class="hljs-keyword">for</span> j, _ := <span class="hljs-keyword">range</span> v &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &#123;<br>matrix[i][j] = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">if</span> matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span> &#123;<br>matrix[i][j] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]); i++ &#123;<br><span class="hljs-keyword">if</span> flag_h == <span class="hljs-number">1</span> &#123;<br>matrix[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br><span class="hljs-keyword">if</span> flag_l == <span class="hljs-number">1</span> &#123;<br>matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h3><p>题目链接：<a href="https://leetcode.cn/problems/rotate-image/">旋转图像</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span>  &#123;<br>    n:= <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> matrix &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> matrix &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>; j++ &#123;<br>        matrix[i][j], matrix[i][n-j] = matrix[i][n-j], matrix[i][j]<br>    &#125;<br>&#125;<br><br>&#125;   <br></code></pre></td></tr></table></figure><p>看到了一个题解我觉得写的思路非常好,这边记录一下</p><p>解题思路<br>顺时针旋转90：先沿对角线反转矩阵，再沿竖中轴线反转矩阵；<br>顺时针旋转180：先沿横中轴线反转矩阵，再沿竖中轴线反转矩阵；<br>顺时针旋转270：先沿对角线反转矩阵，再沿横中轴线反转矩阵；<br>代码<br>给出各种方式的反转的实现，解具体题目时将他们组合就好了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go">idx, halfLen := <span class="hljs-built_in">len</span>(matrix)<span class="hljs-number">-1</span>, <span class="hljs-built_in">len</span>(matrix) / <span class="hljs-number">2</span> <span class="hljs-comment">// 记录最后一个元素的下标和边长的一半</span><br><br><span class="hljs-comment">// 按对角线反转矩阵</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> matrix &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>        matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 按竖中轴线反转矩阵</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> matrix &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; halfLen; j++ &#123;<br>        matrix[i][j], matrix[i][idx-j] = matrix[i][idx-j], matrix[i][j]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 按横中轴线反转矩阵</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; helfLen; i++ &#123;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> matrix[i] &#123;<br>        matrix[idx-i][j], matrix[i][j] = matrix[i][j], matrix[idx-i][j]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/product-of-array-except-self/">除自身以外数组的乘积</a></p><p>时间复杂度和空间复杂度都太差了，插个眼待优化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  []<span class="hljs-type">int</span> &#123;<br>    L := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))<br>     R := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))<br>     ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))<br><br>    L[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i,_ := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        L[i] = L[i<span class="hljs-number">-1</span>]*nums[i]<br>    &#125;<br>    R[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>] = nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;<br>        R[i] = R[i+<span class="hljs-number">1</span>]*nums[i]<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>  &#123;<br>            ans[i] = R[i+<span class="hljs-number">1</span>]<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ans[i]= L[i<span class="hljs-number">-1</span>]*R[i+<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    ans[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>]=L[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>]<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><p>优化后的代码</p><p>可以不开辟除了返回的数组外的其他数组，可以在算右侧后缀积的时候顺便把答案算出来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  []<span class="hljs-type">int</span> &#123;<br>    L := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-built_in">len</span>(nums))<br><br><br>    L[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>;i++ &#123;<br>        L[i] = L[i<span class="hljs-number">-1</span>]*nums[i<span class="hljs-number">-1</span>]<br>    &#125;<br>    r := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--&#123;<br>        L[i] = L[i]*r<br>        r*=nums[i]<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> L<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/first-missing-positive/">缺失的第一个正数</a></p><p>直接用排序然后来做空间复杂度会更好一点，但时间复杂度不知道，反正不是O(n)</p><p>要不用排序的话得用置换的方法，如果对应下标的存的值不是对应nums，那么就将存的值换到对应下标下</p><p>同时用len（n）进行约束 （如果对应的数值超出了len（n），对应下标超出了nums的范围，直接不交换即可）</p><p>只有nums[i]不满足条件的时候才进行++，不然无法正确归位各数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n:= <span class="hljs-built_in">len</span>(nums)<br>    i:= <span class="hljs-number">0</span> <br>    <span class="hljs-keyword">for</span> i&lt;<span class="hljs-built_in">len</span>(nums)  &#123;<br>        <span class="hljs-keyword">if</span> nums[i] != i+<span class="hljs-number">1</span>&amp;&amp;nums[i]&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]&lt;n &#123;<br>            <span class="hljs-keyword">if</span> nums[nums[i]<span class="hljs-number">-1</span>] != nums[i] &#123;<br>             nums[i], nums[nums[i]<span class="hljs-number">-1</span>] = nums[nums[i]<span class="hljs-number">-1</span>],nums[i]<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>i++<br>&#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i++<br>          &#125;<br>    &#125; <br><br>    <span class="hljs-keyword">for</span> j,v :=<span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span>  j+<span class="hljs-number">1</span> != v &#123;<br>            <span class="hljs-keyword">return</span> j+<span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> n+<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a>反转链表 II</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/reverse-linked-list-ii/">反转链表 II</a></p><p>最初的代码，思路基本正确，但没考虑到left 等于1的情况，此时没有节点指向left &#x3D; 1 的节点，如果通过变量来记录的话，最后将记录变量的next指向新节点的时候会报错，因为他是空的</p><p>解决方法就是在最前面加一个哨兵节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>  <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> head.Next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> head<br>&#125;<br>  <span class="hljs-keyword">var</span> dummy *ListNode = head <br><span class="hljs-keyword">var</span> pre, cur, l, r *ListNode = dummy, head, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>count := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> count != left &#123;<br>pre = cur<br>cur = cur.Next<br>count++<br>&#125;<br>l = pre<br>r = cur<br><span class="hljs-keyword">for</span> count != right+<span class="hljs-number">1</span> &#123;<br>nxt := cur.Next<br>cur.Next = pre<br>pre = cur<br>cur = nxt<br>count++<br><br>&#125;<br>l.Next = pre<br>r.Next = cur<br><span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure><p>解决问题后的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br><span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">if</span> head.Next == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> head<br>&#125;<br>dummy := &amp;ListNode&#123;Next: head&#125;<br>p0 := dummy<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; left<span class="hljs-number">-1</span>; i++ &#123;<br>p0 = p0.Next<br>&#125;<br><span class="hljs-keyword">var</span> pre, cur *ListNode = <span class="hljs-literal">nil</span>, head<br>count := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> count != left &#123;<br>pre = cur<br>cur = cur.Next<br>count++<br>&#125;<br><br><span class="hljs-keyword">for</span> count != right+<span class="hljs-number">1</span> &#123;<br>nxt := cur.Next<br>cur.Next = pre<br>pre = cur<br>cur = nxt<br>count++<br><br>&#125;<br><br>p0.Next.Next = cur<br>p0.Next = pre<br><span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N <strong>个结点</strong></h3><p>题目链接： <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除链表的倒数第 N 个结点</a></p><p>最优做法使用双指针，左指针距离右指针n个距离</p><p>注意使用哨兵节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> dummy *ListNode = &amp;ListNode&#123;Val:<span class="hljs-number">0</span>,Next:<span class="hljs-literal">nil</span>&#125;<br>    dummy.Next = head<br>    <span class="hljs-keyword">var</span> left,right *ListNode =dummy, head<br>    <span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>;i&lt;n;i++ &#123;<br>        right= right.Next<br>    &#125;<br>    <span class="hljs-keyword">for</span> right != <span class="hljs-literal">nil</span>&#123;<br>        right = right.Next<br>        left = left.Next<br>    &#125;<br>    left.Next = left.Next.Next<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>tmp1 := head<br>tmp2 := head<br><span class="hljs-keyword">var</span> l *ListNode = head<br>dummy := &amp;ListNode&#123;Val: <span class="hljs-number">0</span>, Next: head&#125;<br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> l != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">var</span> pre, cur, tmp3 *ListNode = <span class="hljs-literal">nil</span>, tmp1, tmp1<br><span class="hljs-keyword">for</span> count != k &amp;&amp; l != <span class="hljs-literal">nil</span> &#123;<br>count++<br>l = l.Next<br>&#125;<br><span class="hljs-keyword">if</span> count != k &#123;<br><span class="hljs-keyword">if</span> tmp1 == head &#123;<br><span class="hljs-keyword">return</span> dummy.Next<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>tmp2.Next = tmp1<br><span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> cur != l &amp;&amp; count != <span class="hljs-number">1</span> &#123;<br>nxt := cur.Next<br>tmp1 = nxt <span class="hljs-comment">//</span><br>cur.Next = pre<br>pre = cur<br>cur = nxt<br>&#125;<br><span class="hljs-keyword">if</span> dummy.Next == head &amp;&amp; count != <span class="hljs-number">1</span> &#123;<br>dummy.Next = pre<br>tmp2 = head<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> count != <span class="hljs-number">1</span> &#123;<br>tmp2.Next = pre<br>tmp2 = tmp3<br>&#125;<br>&#125;<br><br>count = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="随机链表的复制"><a href="#随机链表的复制" class="headerlink" title="随机链表的复制"></a>随机链表的复制</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">随机链表的复制</a></p><p>这题可以用哈希表或者迭代的方式来做</p><p>但是哈希表加两次遍历是最简单且时间复杂度低的，空间复杂度中等</p><p>使用迭代空间复杂度最低，但是时间复杂度高，得遍历三次</p><p>哈希表加回溯，时间复杂度高，空间复杂度也高，代码也不易理解，下下策</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyRandomList</span><span class="hljs-params">(head *Node)</span></span> *Node &#123;<br>    hash := <span class="hljs-keyword">map</span>[*Node]*Node&#123;&#125;<br>    <span class="hljs-keyword">for</span> it := head; it != <span class="hljs-literal">nil</span>; it = it.Next &#123;<br>        hash[it] = &amp;Node&#123;it.Val, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125; <br>    &#125;<br>    <span class="hljs-keyword">for</span> it := head; it != <span class="hljs-literal">nil</span>; it = it.Next &#123;<br>        itNew := hash[it]<br>        itNew.Next, itNew.Random = hash[it.Next], hash[it.Random] <br>    &#125;<br>    <span class="hljs-keyword">return</span> hash[head]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a></p><p>双百做法 ： 递归</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(left *TreeNode,right *TreeNode)</span></span><span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> (left ==<span class="hljs-literal">nil</span>&amp;&amp;right!=<span class="hljs-literal">nil</span>)||(left != <span class="hljs-literal">nil</span> &amp;&amp;right==<span class="hljs-literal">nil</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span>&amp;&amp;right==<span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <br>    &#125;<br><br>    <span class="hljs-keyword">if</span> left.Val == right.Val&#123;<br>        ok:=dfs(left.Left,right.Right)<br>        ok2:=dfs(left.Right,right.Left)<br>        <span class="hljs-keyword">return</span> ok&amp;&amp;ok2<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root==<span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(root.Left,root.Right)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这题很简单，但是因为要用迭代来做所以查个眼，回来把迭代做法补上</p><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></p><p>解法一 ： 使用两个队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> (ans [][]<span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br>q := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">1</span>)<br>q2 := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">0</span>)<br>q[<span class="hljs-number">0</span>] = root<br>top := <span class="hljs-number">0</span><br>top2 := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> top != <span class="hljs-built_in">len</span>(q) || top2 != <span class="hljs-built_in">len</span>(q2) &#123;<br>m2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> top != <span class="hljs-built_in">len</span>(q) &#123;<br>m2 = <span class="hljs-built_in">append</span>(m2, q[top].Val)<br><span class="hljs-keyword">if</span> q[top].Left != <span class="hljs-literal">nil</span> &#123;<br>q2 = <span class="hljs-built_in">append</span>(q2, q[top].Left)<br>&#125;<br><span class="hljs-keyword">if</span> q[top].Right != <span class="hljs-literal">nil</span> &#123;<br>q2 = <span class="hljs-built_in">append</span>(q2, q[top].Right)<br>&#125;<br><br>top++<br><span class="hljs-keyword">if</span> top == <span class="hljs-built_in">len</span>(q) &#123;<br>ans = <span class="hljs-built_in">append</span>(ans, m2)<br>q = q[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>top = <span class="hljs-number">0</span><br>m := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> top2 != <span class="hljs-built_in">len</span>(q2) &#123;<br><br>m = <span class="hljs-built_in">append</span>(m, q2[top2].Val)<br><span class="hljs-keyword">if</span> q2[top2].Left != <span class="hljs-literal">nil</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, q2[top2].Left)<br>&#125;<br><span class="hljs-keyword">if</span> q2[top2].Right != <span class="hljs-literal">nil</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, q2[top2].Right)<br>&#125;<br><br>top2++<br><span class="hljs-keyword">if</span> top2 == <span class="hljs-built_in">len</span>(q2) &#123;<br>ans = <span class="hljs-built_in">append</span>(ans, m)<br>q2 = q2[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>top2 = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>解法二优化 ： 使用一个队列</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> (ans [][]<span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br>q := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">1</span>)<br>q[<span class="hljs-number">0</span>] = root<br>top := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) != <span class="hljs-number">0</span> &#123;<br>n := <span class="hljs-built_in">len</span>(q)<br>m2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> top != n &#123;<br>m2 = <span class="hljs-built_in">append</span>(m2, q[top].Val)<br><span class="hljs-keyword">if</span> q[top].Left != <span class="hljs-literal">nil</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, q[top].Left)<br>&#125;<br><span class="hljs-keyword">if</span> q[top].Right != <span class="hljs-literal">nil</span> &#123;<br>q = <span class="hljs-built_in">append</span>(q, q[top].Right)<br>&#125;<br>top++<br><br><span class="hljs-keyword">if</span> top == n &#123;<br>ans = <span class="hljs-built_in">append</span>(ans, m2)<br>q = q[n:]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>top = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>两种方法各有优势，第一种方法使用两个队列，对于内存的消耗来说是小于第二种方法的，第二种方法就是速度会比第一种方法的快</p><h3 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a>二叉搜索树中第K小的元素</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">二叉搜索树中第K小的元素</a></p><p>之前自己想的太复杂了，发现一篇题解的代码非常简洁高效，就直接用他的代码了</p><p>（水平还不够，鉴定为刷题刷少了0.0）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(root *TreeNode, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    arr := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *TreeNode)</span></span><br>    f = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *TreeNode)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span>&#123;<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    f(n.Left)<br>    arr = <span class="hljs-built_in">append</span>(arr,n.Val)<br>    f(n.Right)<br>    &#125;<br>    f(root)<br>    <span class="hljs-keyword">return</span> arr[k<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a></p><p>时间复杂度太差了，待优化</p><p>还是我太垃圾了，官方题解的最后一种做法直接可以达到双百QAQ</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode)</span></span> *TreeNode &#123;<br><span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>l := dfs(root.Left)<br>    <span class="hljs-keyword">var</span> r *TreeNode<br><span class="hljs-keyword">if</span> l == <span class="hljs-literal">nil</span> &#123;<br>r = dfs(root.Right)<br><span class="hljs-keyword">if</span> r == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> root<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>tmp := root.Right<br>root.Right = root.Left<br>l.Right = tmp<br>root.Left = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">if</span> l.Right == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> l<br>&#125;<br><span class="hljs-keyword">return</span> dfs(l.Right)<br>&#125;<br><br><span class="hljs-keyword">if</span> root.Right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> r != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> r<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> dfs(root.Right)<br>        &#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> root ==<span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    dfs(root)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III"></a>路径总和 III</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/path-sum-iii/">路径总和 III</a></p><p>这题剑指offer上有，但是当时是用的暴力做法做的，今天在leetcode上二刷，换了种更好的思路，利用前缀和来完成这一题，可以得到最优的时间复杂度</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span> <br>    ans  := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *TreeNode,num <span class="hljs-type">int</span>)</span></span><br>   dfs =   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(root *TreeNode,num <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    ans += m[num + root.Val - targetSum]<br>    m[num + root.Val] +=<span class="hljs-number">1</span> <br>    dfs(root.Left,num + root.Val)<br>    dfs(root.Right,num + root.Val)<br>    m[num+root.Val]--<br>    <span class="hljs-keyword">return</span> <br>&#125;<br>    dfs(root,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>题目链接：<a href="https://leetcode.cn/problems/subsets/">子集</a></p><p>灵神讲解视频：<a href="https://www.bilibili.com/video/BV1mG4y1A7Gu/?vd_source=9b4c75905899e9c060de474426e69d22">回溯算法套路①子集型回溯【基础算法精讲 14】_哔哩哔哩_bilibili</a></p><p>子集型回溯，对每一个元素都进行判断选或者不选，递归到最后</p><p>坑点：记得copy，不要直接把tmp append进去了&gt;_&lt;</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> (ans [][]<span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> count == <span class="hljs-built_in">len</span>(nums) &#123;<br>a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br>a = <span class="hljs-built_in">append</span>(a, tmp...)<br>ans = <span class="hljs-built_in">append</span>(ans, a)<br><span class="hljs-keyword">return</span><br>&#125;<br>dfs(count + <span class="hljs-number">1</span>)<br>tmp = <span class="hljs-built_in">append</span>(tmp, nums[count])<br>dfs(count + <span class="hljs-number">1</span>)<br>tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span><br>&#125;<br>dfs(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p>题目链接： <a href="https://leetcode.cn/problems/combination-sum/">组合总和</a></p><p>首先拿到题目可以认为这是一道组合型回溯</p><p>但是题目要求每个数都可以无限次使用 - - - &gt; 那么我们对每个数就不是采取选或者不选这种策略了</p><p>不是说每个数可无限选吗，那么我每次递归都对所有的数进行判断，无论之前选没选过</p><p>这样可以得出正确结果，<strong>但是有重复</strong></p><p>这边翻了下leetcode题解，发现有个大佬的思路非常巧妙简洁&gt;_&lt;</p><p>思路是每次递归的时候传一个head参数进去，做为下一个数的起点</p><p>这样就能很好的避免出现右边出现之前出现过的数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> (ans [][]<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">//那其实就是每次都计算所有条件</span><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> tmp []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)<br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">( head <span class="hljs-type">int</span>)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> count == target&#123;<br>           ans = <span class="hljs-built_in">append</span>(ans,<span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>),tmp...))<br>           <span class="hljs-keyword">return</span>  <br>        &#125;<br>        <span class="hljs-keyword">for</span> i:=head;i&lt;<span class="hljs-built_in">len</span>(candidates);i++&#123;<br>            <span class="hljs-keyword">if</span>  candidates[i]+count&lt;=target&#123;<br>                count += candidates[i]<br>                tmp =<span class="hljs-built_in">append</span>(tmp,candidates[i])<br>                dfs(i)<br>                tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>                count-= candidates[i]<br>            &#125;<br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span>  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/palindrome-partitioning/">分割回文串</a></p><p>这题也是可以用选或者不选来做，但是在实现的时候有变，不只是单纯的不选就直接dfs(i+1),选了的话就记录状态</p><p>这里使用了一个for循环来实现基于前一个分割处往后所有的字符串的可能性</p><p>并进行判断，如果字符串是回文的，那么就以该字符串的结尾+1作为dfs的参数（下一个字符串的起点）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ishuiwen</span><span class="hljs-params">(a <span class="hljs-type">string</span>)</span></span><span class="hljs-type">bool</span>&#123;<br>    <span class="hljs-keyword">if</span> a == <span class="hljs-string">&quot;&quot;</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    head := <span class="hljs-number">0</span><br>    near := <span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> head &lt; near &#123;<br>        <span class="hljs-keyword">if</span> a[head] == a[near]&#123;<br>            head ++ <br>            near --<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (ans [][]<span class="hljs-type">string</span>) &#123;<br>    <span class="hljs-keyword">var</span> tmp []<span class="hljs-type">string</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span> , <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>  count == <span class="hljs-built_in">len</span>(s) &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans ,<span class="hljs-built_in">append</span>([]<span class="hljs-type">string</span>(<span class="hljs-literal">nil</span>),tmp...))<br>            <span class="hljs-keyword">return</span> <br>        &#125;<br>        <span class="hljs-keyword">for</span> j := count;j&lt;<span class="hljs-built_in">len</span>(s);j++ &#123;<br>            <span class="hljs-keyword">if</span> ishuiwen(s[count:j+<span class="hljs-number">1</span>]) &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp,s[count:j+<span class="hljs-number">1</span>])<br>                dfs(j+<span class="hljs-number">1</span>)<br>                tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br>    dfs(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ans <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="N-皇后"><a href="#N-皇后" class="headerlink" title="N 皇后"></a>N 皇后</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/n-queens/">N 皇后</a></p><p>空间换时间，注意要开两个map，不能公用一个map，因为如count+ i为定值确定斜线只针对{count + i}唯一，可能会和count-i有重复</p><p>这里用了个book来记录是否有放置皇后（懒得初始化col切片的值不为0了）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (ans [][]<span class="hljs-type">string</span>) &#123; <span class="hljs-comment">//k</span><br><span class="hljs-keyword">var</span> col []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">var</span> book []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> count == n &#123;<br><span class="hljs-keyword">var</span> ts []<span class="hljs-type">string</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> col &#123;<br><span class="hljs-keyword">var</span> t []<span class="hljs-type">byte</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br><span class="hljs-keyword">if</span> j == v &#123;<br>t = <span class="hljs-built_in">append</span>(t, <span class="hljs-string">&#x27;Q&#x27;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>t = <span class="hljs-built_in">append</span>(t, <span class="hljs-string">&#x27;.&#x27;</span>)<br>&#125;<br>&#125;<br>ts = <span class="hljs-built_in">append</span>(ts, <span class="hljs-type">string</span>(t))<br>&#125;<br>ans = <span class="hljs-built_in">append</span>(ans, ts)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">if</span> book[i] == <span class="hljs-number">0</span> &amp;&amp; !m[count+i] &amp;&amp; !m2[count-i] &#123;<br>m[count+i] = <span class="hljs-literal">true</span><br>m2[count-i] = <span class="hljs-literal">true</span><br>col[count] = i<br>book[i] = <span class="hljs-number">1</span><br>dfs(count + <span class="hljs-number">1</span>)<br>col[count] = <span class="hljs-number">0</span><br>book[i] = <span class="hljs-number">0</span><br>m2[count-i] = <span class="hljs-literal">false</span><br>m[count+i] = <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>&#125;<br>dfs(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/course-schedule/">课程表</a></p><p>图论的题有向图还是有点难度的，这里记录一下刷到的一题有向图的算法题目</p><p>注意，无向图如果几个点相互之间都连起来了，那就真的是环，但有向图得看方向，不一定就是环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-type">int</span>, prerequisites [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">var</span> nums [][]<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br>nums = <span class="hljs-built_in">append</span>(nums, <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>))<br>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> prerequisites &#123;<br>nums[v[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(nums[v[<span class="hljs-number">1</span>]], v[<span class="hljs-number">0</span>])<br>&#125;<br><span class="hljs-comment">//检查是否有有向环</span><br><span class="hljs-keyword">var</span> visited []<span class="hljs-type">int</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, numCourses)<br><span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span><br>dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> visited[i] == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> visited[i] == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>visited[i] = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums[i] &#123;<br><span class="hljs-keyword">if</span> !dfs(v) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>visited[i] = <span class="hljs-number">-1</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br><span class="hljs-keyword">if</span> !dfs(i) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/decode-string/">字符串解码</a></p><p>有点后缀表达式的思想，一直入栈直到遇到 ] 后出栈到 [ ，出栈后的子串就是要进行repeate的字符串，此时再将需要重复的次数num出栈（怎么处理还是有点东西的，第一次wrong就在这里），使用strings的repeat包就可得到最终字符串，然后将其再入栈参加运算</p><p>最后的结果就是题目想要的字符串</p><p>我太菜了，后面还得再刷几遍&gt;_&lt;</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> stack []<span class="hljs-type">rune</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> v != <span class="hljs-string">&#x27;]&#x27;</span> &#123;<br>stack = <span class="hljs-built_in">append</span>(stack, v)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">var</span> str []<span class="hljs-type">rune</span> = <span class="hljs-built_in">make</span>([]<span class="hljs-type">rune</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != <span class="hljs-string">&#x27;[&#x27;</span> &#123;<br>str = <span class="hljs-built_in">append</span>(str, stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>&#125;<br>stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">var</span> num <span class="hljs-type">int</span> = <span class="hljs-number">0</span><br><span class="hljs-comment">//将出栈字符串反转</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str)/<span class="hljs-number">2</span>; i++ &#123;<br>str[i], str[<span class="hljs-built_in">len</span>(str)<span class="hljs-number">-1</span>-i] = str[<span class="hljs-built_in">len</span>(str)<span class="hljs-number">-1</span>-i], str[i]<br>&#125;<br><span class="hljs-comment">//num可以是多位数</span><br><span class="hljs-keyword">var</span> j <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &amp;&amp; stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br>num += <span class="hljs-type">int</span>(stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>) * j<br>j *= <span class="hljs-number">10</span><br>stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>&#125;<br><br>t := strings.Repeat(<span class="hljs-type">string</span>(str), num)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> t &#123;<br>stack = <span class="hljs-built_in">append</span>(stack, v)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> res <span class="hljs-type">string</span> = <span class="hljs-type">string</span>(stack)<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/daily-temperatures/">每日温度</a></p><p>确实太久没写搞算法了，单调栈都忘的差不多了</p><p>这题通过维护一个单调栈来判断下一次比当前温度高在什么时候出现</p><p>如果当前温度高于栈顶温度，则出栈，直到栈顶元素大于当前温度为止，该温度就是我们要找的温度</p><p>同时将当前元素下标入栈，继续循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(temperatures []<span class="hljs-type">int</span>)</span></span> (ans []<span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">//维护一个单调栈</span><br>s := []<span class="hljs-type">int</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-built_in">len</span>(temperatures)<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i-- &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(s)!= <span class="hljs-number">0</span>&amp;&amp; temperatures[i]&gt;=temperatures[s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]] &#123;<br>s = s[:<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]<br>&#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123;<br>ans = <span class="hljs-built_in">append</span>(ans , <span class="hljs-number">0</span>)<br>s = <span class="hljs-built_in">append</span>(s,i)<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans,s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>]-i)<br>            s= <span class="hljs-built_in">append</span>(s,i)<br>        &#125;<br>&#125;<br><span class="hljs-comment">//ans翻转下</span><br><span class="hljs-keyword">for</span> i,j:=<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(ans)<span class="hljs-number">-1</span>;i&lt;j;i,j=i+<span class="hljs-number">1</span>,j<span class="hljs-number">-1</span> &#123;<br>ans[i],ans[j] = ans[j],ans[i]<br>&#125;<br><br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="柱状图中最大的矩形"><a href="#柱状图中最大的矩形" class="headerlink" title="柱状图中最大的矩形"></a>柱状图中最大的矩形</h3><p> 题目链接 ：<a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">柱状图中最大的矩形</a></p><p>自己一开始的想法和b站的up差不多，都是找到最小的那个值后进行计算，但是自己想的时间复杂度太高了，而且没有很好的思路去实现</p><p>题解的思路很明确，计算以栈顶元素的为高的最大矩形</p><p>因为确保了栈是单调的 ，所以保证了循环结束后计算出来的答案矩形都是要比当前下标对应高度矩形面积要大的</p><p>（循环一到比当前下标高度小时就停止）</p><blockquote><p>这里其实就是一种优化，一般的暴力做法是对于当前高度，先向左找到小于他的高度，然后向右找到小于他的高度，然后求面积</p><p>而现在就是用了一种非常巧妙的算法（我没想到，而且非常简洁）只用一个单调栈就解决了这个问题，而且时间复杂度和空间复杂度还非常好</p></blockquote><p>别忘了给高度数组最后添加上一个-1来结束一直递增的情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(heights []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>     stack := []<span class="hljs-type">int</span>&#123;&#125;<br>     heights = <span class="hljs-built_in">append</span>(heights,<span class="hljs-number">-1</span>)<br>     ans := <span class="hljs-number">0</span><br>     <span class="hljs-keyword">for</span> i :=<span class="hljs-keyword">range</span> heights &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack)!= <span class="hljs-number">0</span>&amp;&amp; heights[i] &lt; heights[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] &#123;<br>            high := heights[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            left := <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack)!=<span class="hljs-number">0</span> &#123;<br>                  left = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                left = <span class="hljs-number">-1</span>  <span class="hljs-comment">//如果只有一个数，令left = 0 得不出正确答案</span><br>            &#125;<br>             ans = max(ans ,(i-left<span class="hljs-number">-1</span>)*high)<br>        &#125;<br>        stack = <span class="hljs-built_in">append</span>(stack,i)<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span> )</span></span><span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> a&lt;b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h3><p>题目链接 ： <a href="https://leetcode.cn/problems/top-k-frequent-elements/"> 前 K 个高频元素</a></p><p>使用堆排序完成</p><p>还可以优化， 二刷的时候在来</p><p>这边遇到一个bug ，太粗心了&gt;_&lt;</p><p>在push进堆的时候，我取了一个局部的k值覆盖了传进来的k值，导致堆中最后剩下了三个数，，重命名成key即可解决</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span>&#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> _,v:= <span class="hljs-keyword">range</span> nums &#123;<br>        m[v]++<br>    &#125;<br>    h := &amp;ArrayHeap&#123;&#125;<br>    heap.Init(h)<br>    <span class="hljs-keyword">for</span> key,v:=<span class="hljs-keyword">range</span> m &#123;<br>        heap.Push(h, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;key, v&#125;)<br>        <span class="hljs-keyword">if</span> h.Len() &gt; k &#123; <span class="hljs-comment">//创建的小根堆</span><br>            heap.Pop(h)<br>        &#125;<br>    &#125;<br><br>   <br>    ret := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        ret[k - i - <span class="hljs-number">1</span>] = heap.Pop(h).([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret<br><br>&#125;<br><br><span class="hljs-keyword">type</span> ArrayHeap [][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>  <span class="hljs-comment">//默认建立的堆是小根堆？</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h ArrayHeap)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h ArrayHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i][<span class="hljs-number">1</span>] &lt; h[j][<span class="hljs-number">1</span>] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h ArrayHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; h[i], h[j] = h[j], h[i] &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *ArrayHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    *h = <span class="hljs-built_in">append</span>(*h, x.([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *ArrayHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    x :=  (*h)[<span class="hljs-built_in">len</span>(*h)<span class="hljs-number">-1</span>]<br>    *h =  (*h)[: <span class="hljs-built_in">len</span>(*h)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/find-median-from-data-stream/">数据流的中位数</a></p><p>hard题确实难，主要是思路</p><p>普通的做法使用插入排序等方法维护有序数组，最后取中间的值就是中位数</p><p>但这显然是低效的</p><p>更加高效的做法是使用大根堆和小根堆来做，中位数以前为大根堆，中位数以后为小根堆</p><p>好像还有更好的做法，二刷的时候再来做</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MedianFinder <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">//两个堆</span><br>big   ArrayHeap<br>small SArrayHeap<br>count <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ArrayHeap <span class="hljs-keyword">struct</span> &#123;<br>sort.IntSlice<br>&#125;<br><span class="hljs-keyword">type</span> SArrayHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x SArrayHeap)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(x) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x SArrayHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> x[i] &gt; x[j] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x SArrayHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; x[i], x[j] = x[j], x[i] &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *SArrayHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *SArrayHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>old := *h<br>n := <span class="hljs-built_in">len</span>(old)<br>x := old[n<span class="hljs-number">-1</span>]<br>*h = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *ArrayHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>h.IntSlice = <span class="hljs-built_in">append</span>(h.IntSlice, x.(<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *ArrayHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>x := h.IntSlice[<span class="hljs-built_in">len</span>(h.IntSlice)<span class="hljs-number">-1</span>]<br>h.IntSlice = h.IntSlice[:<span class="hljs-built_in">len</span>(h.IntSlice)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MedianFinder &#123;<br>c := MedianFinder&#123;&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MedianFinder)</span></span> AddNum(num <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> this.count%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>heap.Push(&amp;this.small, num)<br>s := heap.Pop(&amp;this.small)<br>heap.Push(&amp;this.big, s)<br>this.count++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>heap.Push(&amp;this.big, num)<br>s := heap.Pop(&amp;this.big)<br>heap.Push(&amp;this.small, s)<br>this.count++<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MedianFinder)</span></span> FindMedian() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">var</span> ans <span class="hljs-type">float64</span><br><span class="hljs-keyword">if</span> this.count%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>s := heap.Pop(&amp;this.small)<br>heap.Push(&amp;this.small, s)<br>m := heap.Pop(&amp;this.big)<br>heap.Push(&amp;this.big, m)<br>ans =<span class="hljs-type">float64</span>((m.(<span class="hljs-type">int</span>) + s.(<span class="hljs-type">int</span>))) / <span class="hljs-number">2</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s := heap.Pop(&amp;this.big)<br>heap.Push(&amp;this.big, s)<br>ans = <span class="hljs-type">float64</span>( s.(<span class="hljs-type">int</span>))<br>&#125;<br><span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a></p><p>自己的思路写的代码又臭又长，还卡最后一个测试点过不了</p><p>看看题解写的，代码简洁，思路巧妙，我还是太菜了&gt;_&lt;</p><p>第一个起始点能跳到到最远距离记作m，则在【0，m】内的所有点都可以作为起跳点，然后重复上述过程，更新能跳到点最远距离m，如果能一直跳到最后，那就为true，否则为false</p><p>这里把跳跃次数屏蔽了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i :=<span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> i&gt; index &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        index = max(index,i + nums[i])<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a,b <span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">if</span> a&lt;b &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="只出现一次的数字-·位运算"><a href="#只出现一次的数字-·位运算" class="headerlink" title="只出现一次的数字 ·位运算"></a>只出现一次的数字 ·位运算</h3><p>题目链接 ：<a href="https://leetcode.cn/problems/single-number/">只出现一次的数字</a></p><p>只能说妙</p><p>一起异或，相同异或为0，最后只剩只出现一次的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    single := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        single ^= num<br>    &#125;<br>    <span class="hljs-keyword">return</span> single<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h3><p><a href="https://leetcode.cn/problems/majority-element/">多数元素</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>剑指offer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT6.S081实验记录</title>
    <link href="/2023/09/02/MIT6-S081%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/02/MIT6-S081%E5%AE%9E%E9%AA%8C%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>吸取cs144的教训，一定要写完一个lab就把blog给写了，不然时间久了，要么不记得了，要么就会觉得当时卡了很久的问题，其实很简单，不想写上去</p><p>装环境这块相比cs144来说更麻烦一点，需要自己下载编译，但是按照官方的安装说明来其实也还好</p><p><a href="https://pdos.csail.mit.edu/6.S081/2020/tools.html">实验环境安装</a></p><p>因为才重新开始写blog不久，确实有很多地方做的不太好，目前来说的几篇blog感觉不能让读者非常轻松的阅读，只适合自己阅读，这点后面慢慢改吧</p><p>（9.4：因为lab1和lab2没有用git做版本控制导致库里没有这两实验的相关code，只能在blog里记录了）</p><h2 id="lab1-Xv6-and-Unix-utilities"><a href="#lab1-Xv6-and-Unix-utilities" class="headerlink" title="lab1 Xv6 and Unix utilities"></a>lab1 Xv6 and Unix utilities</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><p>This lab will familiarize you with xv6 and its system calls.</p><h3 id="sleep-easy"><a href="#sleep-easy" class="headerlink" title="sleep (easy)"></a>sleep (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h3><p>练手题，非常简单  主要是熟悉一下怎么输入输出</p><p>因为我开始并不熟悉整个实验的环境和测试流程，所以sleep我就拿大佬的代码来快速上手了，代码也很简单，主要是熟悉一下实验平台</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// sleep.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span> <span class="hljs-comment">// 必须以这个顺序 include，由于三个头文件有依赖关系</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: sleep &lt;ticks&gt;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pingpong-easy"><a href="#pingpong-easy" class="headerlink" title="pingpong (easy)"></a>pingpong (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h3><p>这里涉及到两个关键的点，fork（）和pipe（），如果能理解到这两系统调用的作用是什么，那这题也非常简单</p><p>todo： pipe()的概念</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span> <span class="hljs-comment">// 必须以这个顺序 include，由于三个头文件有依赖关系</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span>&#123;<br>    <span class="hljs-type">int</span> pi[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> pi2[<span class="hljs-number">2</span>];<br>    pipe(pi);<br>    pipe(pi2);<br>    <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//child process</span><br>        <span class="hljs-type">char</span> buf;<br>        read(pi[<span class="hljs-number">0</span>],&amp;buf,<span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>,getpid());<br>        write(pi2[<span class="hljs-number">1</span>],&amp;buf,<span class="hljs-keyword">sizeof</span>(buf));<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        write(pi[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;?&quot;</span>,<span class="hljs-number">1</span>);<br>        <span class="hljs-type">char</span> buf;<br>        read(pi2[<span class="hljs-number">0</span>],&amp;buf,<span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>,getpid());<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="primes-moderate-hard"><a href="#primes-moderate-hard" class="headerlink" title="primes (moderate)&#x2F;(hard)"></a>primes (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)&#x2F;(<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h3><p>这题如果说是难题，那么难就难在理解埃氏筛这个算法和怎么实现，由于我之前刷算法的时候刷到过素数筛，所以了解过相关概念，这题对于我来说难度不大，就是处理细节得花挺多时间</p><p>相关资料：<a href="https://swtch.com/~rsc/thread/">埃氏筛</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span> <span class="hljs-comment">// 必须以这个顺序 include，由于三个头文件有依赖关系</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> pip[])</span>&#123;<br>    <span class="hljs-type">int</span> pi[<span class="hljs-number">2</span>];<br>    pipe(pi);<br>    <span class="hljs-keyword">if</span> (num==<span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br><br>    <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        close(pi[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//关写进程</span><br>        close(pip[<span class="hljs-number">0</span>]);<br>        read(pi[<span class="hljs-number">0</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, tmp);<br>        dfs(tmp,pi);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        close(pi[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//关读进程</span><br>        <span class="hljs-keyword">while</span>(read(pip[<span class="hljs-number">0</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp))&amp;&amp;tmp!=<span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">if</span> (tmp%num!=<span class="hljs-number">0</span>)&#123;<br>                write(pi[<span class="hljs-number">1</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp));<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> end = <span class="hljs-number">-1</span>;      <span class="hljs-comment">//忘记补写了，一直在这里超时</span><br>        write(pi[<span class="hljs-number">1</span>],&amp;end,<span class="hljs-keyword">sizeof</span>(end));<br>        wait(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-type">int</span> pi[<span class="hljs-number">2</span>];<br>    pipe(pi);<br>    <span class="hljs-type">int</span> num =<span class="hljs-number">2</span> ;<br>    <span class="hljs-keyword">if</span>(fork()==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        close(pi[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//关写进程</span><br>        read(pi[<span class="hljs-number">0</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp));<br>        dfs(tmp,pi);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-number">3</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, num);<br>        close(pi[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">while</span>(tmp&lt;=<span class="hljs-number">35</span>)&#123;<br>            <span class="hljs-keyword">if</span>(tmp%num!=<span class="hljs-number">0</span>)&#123;<br>                write(pi[<span class="hljs-number">1</span>],&amp;tmp,<span class="hljs-keyword">sizeof</span>(tmp));<br>            &#125;<br>            tmp++;<br>        &#125;<br>        <span class="hljs-type">int</span> end = <span class="hljs-number">-1</span>;<br>        write(pi[<span class="hljs-number">1</span>],&amp;end,<span class="hljs-keyword">sizeof</span>(end));<br>    &#125;<br>    wait(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这边的一个坑点就是管道 要注意关闭不需要用到的文件描述符，否则跑到 n &#x3D; 13 的时候就会爆掉，出现读到全是 0 的情况。</p><blockquote><p>这里的理由是，fork 会将父进程的所有文件描述符都复制到子进程里，而 xv6 每个进程能打开的文件描述符总数只有 16 个 （见 <code>defs.h</code> 中的 <code>NOFILE</code> 和 <code>proc.h</code> 中的 <code>struct file *ofile[NOFILE]; // Open files</code>）。</p><p>由于一个管道会同时打开一个输入文件和一个输出文件，所以<strong>一个管道就占用了 2 个文件描述符</strong>，并且复制的<strong>子进程还会复制父进程的描述符</strong>，于是跑到第六七层后，就会由于最末端的子进程出现 16 个文件描述符都被占满的情况，导致新管道创建失败。</p></blockquote><p>关闭不必要的管道即可，如文中代码所示</p><h3 id="find-moderate"><a href="#find-moderate" class="headerlink" title="find (moderate)"></a>find (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p></blockquote><p>hint让我们去看ls的源码，其实大部分代码都可以复用ls的代码，所以难度不大</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// find.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *target)</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    <span class="hljs-keyword">if</span> ((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (st.type)<br>    &#123;<br>    <span class="hljs-keyword">case</span> T_FILE:<br>       <br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(path + <span class="hljs-built_in">strlen</span>(path) - <span class="hljs-built_in">strlen</span>(target), target) == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, path);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> T_DIR:<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">strcpy</span>(buf, path);<br>        p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>        *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>        <span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))<br>        &#123;<br>            <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            memmove(p, de.name, DIRSIZ);<br>            p[DIRSIZ] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf + <span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">2</span>, <span class="hljs-string">&quot;/.&quot;</span>) != <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(buf + <span class="hljs-built_in">strlen</span>(buf) - <span class="hljs-number">3</span>, <span class="hljs-string">&quot;/..&quot;</span>) != <span class="hljs-number">0</span>)<br>            &#123;<br>                find(buf, target); <span class="hljs-comment">// 递归查找</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    close(fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> target[<span class="hljs-number">512</span>];<br>    target[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;/&#x27;</span>; <span class="hljs-comment">// 为查找的文件名添加 / 在开头</span><br>    <span class="hljs-built_in">strcpy</span>(target + <span class="hljs-number">1</span>, argv[<span class="hljs-number">2</span>]);<br>    find(argv[<span class="hljs-number">1</span>], target);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="xargs-moderate"><a href="#xargs-moderate" class="headerlink" title="xargs (moderate)"></a>xargs (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p></blockquote><p>这题对于我来说一个是理解到位xargs的作用是什么，一个是c的语法和特性，比如在题解中使用了的大量的指针等等</p><p>xargs：将标准输入转换成命令行输入（让echo等命令可以接收到），然后还有其他的作用，比如说格式化输出等等 <a href="https://www.runoob.com/linux/linux-comm-xargs.html">Linux xargs 命令 | 菜鸟教程 (runoob.com)</a></p><p>之前一直没花太多时间在c语言上，可能对于我来说还是不太熟悉c的特性和操作系统的相关概念，写这题还是花了挺长时间的，最后这题还是参考了大佬的博客才吃透把这题过了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// xargs.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(<span class="hljs-type">char</span> *program, <span class="hljs-type">char</span> **args)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)<br>    &#123; <span class="hljs-comment">// child exec</span><br>        exec(program, args);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// parent return</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-comment">// 读取所有的xargs的参数</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">2048</span>]; <span class="hljs-comment">// 缓冲read里读出来的字符拼接成字符串参数</span><br>    <span class="hljs-type">char</span> **argans;<br>    <span class="hljs-type">char</span> *argv2[<span class="hljs-number">128</span>]; <span class="hljs-comment">// 不能直接使用++移动指针</span><br>    argans = argv2;<br>    <span class="hljs-type">char</span> *start = buf;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++)<br>    &#123;<br>        *argans = argv[i];<br>        argans++;<br>    &#125;<br><br>    <span class="hljs-comment">// 读入参数</span><br>    <span class="hljs-type">char</span> *p = buf;<br>    <span class="hljs-type">char</span> **pa = argans; <span class="hljs-comment">// argans作为头部指针，重置到数组开头的时候用</span><br>    <span class="hljs-keyword">while</span> (read(<span class="hljs-number">0</span>, p, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (*p == <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-comment">// 说明是参数</span><br>        &#123;<br>            *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            *(pa++) = start;<br>            start = p + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (*p == <span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-comment">// 开始执行指令</span><br>        &#123;<br>            *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            *(pa++) = start;<br>            start = p + <span class="hljs-number">1</span>;<br>            *pa = <span class="hljs-number">0</span>;<br>            run(argv[<span class="hljs-number">1</span>], argv2);<br>            pa = argans; <span class="hljs-comment">// 重置</span><br>        &#125;<br>        p++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pa != argans)<br>    &#123; <span class="hljs-comment">// 如果最后一行不是空行</span><br>        <span class="hljs-comment">// 收尾最后一个参数</span><br>        *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        *(pa++) = start;<br>        <span class="hljs-comment">// 收尾最后一行</span><br>        *pa = <span class="hljs-number">0</span>; <span class="hljs-comment">// 参数列表末尾用 null 标识列表结束</span><br>        <span class="hljs-comment">// 执行最后一行指令</span><br>        run(argv[<span class="hljs-number">1</span>], argv2);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (wait(<span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>)<br>    &#123;<br>    &#125;; <span class="hljs-comment">// 循环等待所有子进程完成，每一次 wait(0) 等待一个</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230903095735393.png"></p><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>记录一下自己在做实验过程中的疑惑</p><p>trapframe : 发生trap时，用于保存当前进程如寄存器等状态</p></blockquote><p>lab2和lab1都是挺简单的，而且lab2的任务量和难度都比lab1小，留意lab给的提示就行</p><p>因为lab2的源码也丢失了，这里也没办法放代码了</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230903140502352.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/20230917104450.png"></p><p>务必注意指导书提示：</p><blockquote><p>Some hints:</p><ul><li>Add <code>$U/_trace</code> to UPROGS in Makefile</li><li>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</li><li>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</li><li>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</li><li>Modify the <code>syscall()</code> function in <code>kernel/syscall.c</code> to print the trace output. You will need to add an array of syscall names to index into.</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230903151705364.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/20230917104433.png"></p><h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><blockquote><p>Define a function called <code>vmprint()</code>. It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process’s page table. You receive full credit for this assignment if you pass the <code>pte printout</code> test of <code>make grade</code>.</p></blockquote><p>第一行打印传入vm的参数，我们把传进来的pagetable用%p打印一下就好了</p><blockquote><p>The root of the tree is a 4096-byte page-table page that contains 512 PTEs, which contain the physical addresses for page-table pages in the next level of the tree.Each of those pages contains 512 PTEs for the final level in the tree.</p></blockquote><p>接着遍历他的512个PTE，根据标志位判断是否有child，如果有的话就继续递归，这边可以通过depth参数来进行打印 .. 的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable,uint64 depth)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (depth&gt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(depth==<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. ..&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>        <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>        <span class="hljs-keyword">if</span>((pte &amp; PTE_V) )&#123;<br>            <span class="hljs-keyword">if</span> (depth==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;..&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (depth==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;.. .. ..&quot;</span>);<br>            &#125;<br>            uint64 child = PTE2PA(pte);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: pte %p pa %p\n&quot;</span>,i,pagetable[i],child);<br>            <span class="hljs-keyword">if</span>( (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>)&#123;<br>                dfs((<span class="hljs-type">pagetable_t</span>)child,depth+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> ptb)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, ptb);<br>    dfs(ptb,<span class="hljs-number">0</span>);<br>&#125;s<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230904172005306.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230904172910125.png"></p><h3 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h3><blockquote><p>Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. Modify <code>struct proc</code> to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if <code>usertests</code> runs correctly.</p></blockquote><p>这题注意他给的hint，看着一步一步来，还是比较好做的，主要是题意好理解</p><blockquote><p>A PTE can only refer to a physical address that is aligned on a 4096-byte boundary (is a multiple of 4096), so freerange uses PGROUNDUP to ensure that it frees only aligned physical addresses. </p></blockquote><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230905163657350.png"></p><h3 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify <code>copyin/copyinstr</code></h3><blockquote><p>Replace the body of <code>copyin</code> in <code>kernel/vm.c</code> with a call to <code>copyin_new</code> (defined in <code>kernel/vmcopyin.c</code>); do the same for <code>copyinstr</code> and <code>copyinstr_new</code>. Add mappings for user addresses to each process’s kernel page table so that <code>copyin_new</code> and <code>copyinstr_new</code> work. You pass this assignment if <code>usertests</code> runs correctly and all the <code>make grade</code> tests pass.</p></blockquote><p>卡了有段时间，一开始题意理解到就去做，费了很大的精力，最后还是不得不回滚到一开始的版本（所以下次一定把他的题目意思是什么搞懂再去做，不然很容易理解错题意，浪费精力。。虽然但是花的时间也是去了解xv6的设计，也可以说不算浪费？）</p><blockquote><p> However, this scheme does limit the maximum size of a user process to be less than the kernel’s lowest virtual address. After the kernel has booted, that address is <code>0xC000000</code> in xv6, the address of the PLIC registers; see <code>kvminit()</code> in <code>kernel/vm.c</code>, <code>kernel/memlayout.h</code>, and Figure 3-4 in the text. You’ll need to modify xv6 to prevent user processes from growing larger than the PLIC address.</p></blockquote><p>copyin在用户进程使用，va !&#x3D; pa，copyin_new在kernel中使用，va &#x3D; pa。 理解到这个就非常简单了</p><p>详见下面，我们需要使用的是0到PLIC下面的地址</p><p>所以我们映射的时候不需要映射CLINT</p><p>接着根据hint提到的和内核页表相关的地方进行修改</p><p><img src="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/images/c3/p3.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230905204525549.png"></p><h2 id="lab4-Traps"><a href="#lab4-Traps" class="headerlink" title="lab4 Traps"></a>lab4 Traps</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><h3 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h3><ul><li>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</li></ul><p>​     <strong>A:</strong>   a0-a7; a2;</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230906112130650.png"></p><ul><li>Where is the call to function f in the assembly code for main? Where is the call to g? <strong>(Hint: the compiler may inline functions.)</strong></li></ul><p><strong>A:</strong> 被内联到了main函数中</p><ul><li>At what address is the function <code>printf</code> located?</li></ul><p> <strong>A:</strong> 0x630</p><ul><li>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</li></ul><p><strong>A:</strong> 0x38</p><ul><li><blockquote><p>Run the following code.</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">unsigned <span class="hljs-keyword">int</span> i = <span class="hljs-number">0x00646c72</span>;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, &amp;i);<br>     <br></code></pre></td></tr></table></figure><p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p></blockquote></li></ul><p>很简单，懒得复制代码跑了，</p><ul><li>In the following code, what is going to be printed after ‘y&#x3D;’? (note: the answer is not a specific value.) Why does this happen?</li></ul><p><strong>A:</strong>  随机的，取决于a2寄存器里的值</p><h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><blockquote><p>Implement a <code>backtrace()</code> function in <code>kernel/printf.c</code>. Insert a call to this function in <code>sys_sleep</code>, and then run bttest, which calls <code>sys_sleep</code>. Your output should be as follows:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">backtrace:</span><br><span class="hljs-number">0x0000000080002cda</span><br><span class="hljs-number">0x0000000080002bb6</span><br><span class="hljs-number">0x0000000080002898</span><br>  <br></code></pre></td></tr></table></figure><p>After <code>bttest</code> exit qemu. In your terminal: the addresses may be slightly different but if you run <code>addr2line -e kernel/kernel</code> (or <code>riscv64-unknown-elf-addr2line -e kernel/kernel</code>) and cut-and-paste the above addresses as follows:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">$ addr2line -e kernel/kernel<br><span class="hljs-number">0x0000000080002de2</span><br><span class="hljs-number">0x0000000080002f4a</span><br><span class="hljs-number">0x0000000080002bfc</span><br>Ctrl-D<br>  <br></code></pre></td></tr></table></figure><p>You should see something like this:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kernel</span>/sysproc.c:<span class="hljs-number">74</span><br><span class="hljs-attribute">kernel</span>/syscall.c:<span class="hljs-number">224</span><br><span class="hljs-attribute">kernel</span>/trap.c:<span class="hljs-number">85</span><br></code></pre></td></tr></table></figure></blockquote><p>这题注意一下</p><blockquote><ul><li>These <a href="https://pdos.csail.mit.edu/6.828/2020/lec/l-riscv-slides.pdf">lecture notes</a> have a picture of the layout of stack frames. Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.</li></ul></blockquote><p>这个就好了，easy题，没什么难度</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230906164256057.png"></p><h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><blockquote><p>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you’ll be implementing a primitive form of user-level interrupt&#x2F;fault handlers; you could use something similar to handle page faults in the application, for example. Your solution is correct if it passes alarmtest and usertests.</p></blockquote><p>这边调用传入的alarm函数是直接用程序计数器指向函数进行运行，然后通过sigreturn恢复</p><p>但是一开始尝试只恢复epc不行，还是会报错</p><p>原因是在函数调用的过程中也会对寄存器进行修改</p><p>所以得把整个都保存下来</p><p>因为c语言的基础确实差，最后用的笨方法，直接存储30多个寄存器的值，一开始也想着用一个struct trapframe *trapframe 这样的结构体指针的，发现直接赋值行不通，然后尝试初始化指针分配内存后还是报错不知道为什么，然后就直接把30多个寄存器都放到p里用于保存。</p><blockquote><p>后面了解到好像还得实现结构体的free才行，但我后面没去没尝试过</p></blockquote><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230907221659128.png"></p><h2 id="lab5-xv6-lazy-page-allocation"><a href="#lab5-xv6-lazy-page-allocation" class="headerlink" title="lab5 xv6 lazy page allocation"></a>lab5 xv6 lazy page allocation</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>One of the many neat tricks an O&#x2F;S can play with page table hardware is lazy allocation of user-space heap memory. Xv6 applications ask the kernel for heap memory using the sbrk() system call. In the kernel we’ve given you, sbrk() allocates physical memory and maps it into the process’s virtual address space. It can take a long time for a kernel to allocate and map memory for a large request. Consider, for example, that a gigabyte consists of 262,144 4096-byte pages; that’s a huge number of allocations even if each is individually cheap. In addition, some programs allocate more memory than they actually use (e.g., to implement sparse arrays), or allocate memory well in advance of use. To allow sbrk() to complete more quickly in these cases, sophisticated kernels allocate user memory lazily. That is, sbrk() doesn’t allocate physical memory, but just remembers which user addresses are allocated and marks those addresses as invalid in the user page table. When the process first tries to use any given page of lazily-allocated memory, the CPU generates a page fault, which the kernel handles by allocating physical memory, zeroing it, and mapping it. You’ll add this lazy allocation feature to xv6 in this lab.</p></blockquote><p>这次的lab比较简单，大概用时3-4小时做完了，没有hard题</p><h3 id="Eliminate-allocation-from-sbrk-easy"><a href="#Eliminate-allocation-from-sbrk-easy" class="headerlink" title="Eliminate allocation from sbrk() (easy)"></a>Eliminate allocation from sbrk() (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h3><blockquote><p>Your first task is to delete page allocation from the sbrk(n) system call implementation, which is the function sys_sbrk() in sysproc.c. The sbrk(n) system call grows the process’s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process’s size (myproc()-&gt;sz) by n and return the old size. It should not allocate memory – so you should delete the call to growproc() (but you still need to increase the process’s size!).</p></blockquote><p>纯概念，故跳过</p><p>因为这次lab的几个题都是有联系的，这题也是为了后面几题做铺垫</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-keyword">if</span> (n&lt;<span class="hljs-number">0</span>)&#123;<br>        uvmdealloc(myproc()-&gt;pagetable,myproc()-&gt;sz,myproc()-&gt;sz+n);<br>    &#125;<br>  myproc()-&gt;sz=myproc()-&gt;sz+n;<br><br><span class="hljs-comment">//  if(growproc(n) &lt; 0)</span><br><span class="hljs-comment">//    return -1;</span><br></code></pre></td></tr></table></figure><h3 id="Lazy-allocation-moderate"><a href="#Lazy-allocation-moderate" class="headerlink" title="Lazy allocation (moderate)"></a>Lazy allocation (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Modify the code in trap.c to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. You should add your code just before the <code>printf</code> call that produced the “usertrap(): …” message. Modify whatever other xv6 kernel code you need to in order to get <code>echo hi</code> to work.</p></blockquote><p>这题跟着hint走就行，为下一题做铺垫</p><blockquote><ul><li>You can check whether a fault is a page fault by seeing if r_scause() is 13 or 15 in usertrap().</li><li><code>r_stval()</code> returns the RISC-V <code>stval</code> register, which contains the virtual address that caused the page fault.</li><li>Steal code from uvmalloc() in vm.c, which is what sbrk() calls (via growproc()). You’ll need to call kalloc() and mappages().</li><li>Use PGROUNDDOWN(va) to round the faulting virtual address down to a page boundary.</li><li>uvmunmap() will panic; modify it to not panic if some pages aren’t mapped.</li><li>If the kernel crashes, look up sepc in kernel&#x2F;kernel.asm</li><li>Use your <code>vmprint</code> function from pgtbl lab to print the content of a page table.</li><li>If you see the error “incomplete type proc”, include “spinlock.h” then “proc.h”.</li></ul></blockquote><h3 id="Lazytests-and-Usertests-moderate"><a href="#Lazytests-and-Usertests-moderate" class="headerlink" title="Lazytests and Usertests (moderate)"></a>Lazytests and Usertests (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>We’ve supplied you with <code>lazytests</code>, an xv6 user program that tests some specific situations that may stress your lazy memory allocator. Modify your kernel code so that all of both <code>lazytests</code> and <code>usertests</code> pass.</p></blockquote><p>题目中提到的hint都要实现，我写到后面发现漏了read这几个系统调用也得修改，然后就是最后一个stack，我做了判断，但是没有else把kill设置为1杀掉进程，导致usertest过不去，卡在stack那个测试点不动，因为我一直认为我是if如果没进去那就会被杀掉，开始就没往这边想，后面回头一看才发现不得行。浪费我1个多小时的时间</p><blockquote><ul><li>Handle negative sbrk() arguments.</li><li>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</li><li>Handle the parent-to-child memory copy in fork() correctly.</li><li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</li><li>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</li><li>Handle faults on the invalid page below the user stack.</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span><br>usertests starting<br>test execout: OK<br>test copyin: OK<br>test copyout: OK<br>test copyinstr1: OK<br>test copyinstr2: OK<br>test copyinstr3: OK<br>test rwsbrk: OK<br>test truncate1: OK<br>test truncate2: OK<br>test truncate3: OK<br>test reparent2: OK<br>test pgbug: OK<br>test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3235<br>            sepc=0x0000000000005580 stval=0x0000000000005580<br>usertrap(): unexpected scause 0x000000000000000c pid=3236<br>            sepc=0x0000000000005580 stval=0x0000000000005580<br>OK<br>test badarg: OK<br>test reparent: OK<br>test twochildren: OK<br>test forkfork: OK<br>test forkforkfork: OK<br>test argptest: OK<br>test createdelete: OK<br>test linkunlink: OK<br>test linktest: OK<br>test unlinkread: OK<br>test concreate: OK<br>test subdir: OK<br>test fourfiles: OK<br>test sharedfd: OK<br>test exectest: OK<br>test bigargtest: OK<br>test bigwrite: OK<br>test bsstest: OK<br>test sbrkbasic: OK<br>test sbrkmuch: OK<br>test kernmem: OK<br>test sbrkfail: OK<br>test sbrkarg: OK<br>test validatetest: OK<br>test stacktest: OK<br>test opentest: OK<br>test writetest: OK<br>test writebig: OK<br>test createtest: OK<br>test openiput: OK<br>test exitiput: OK<br>test iput: OK<br>test mem: OK<br>test pipe1: OK<br>test preempt: kill... wait... OK<br>test exitwait: OK<br>test rmdot: OK<br>test fourteen: OK<br>test bigfile: OK<br>test dirfile: OK<br>test iref: OK<br>test forktest: OK<br>test bigdir: OK<br>ALL TESTS PASSED<br></code></pre></td></tr></table></figure><h2 id="lab6-Copy-on-Write-Fork-for-xv6"><a href="#lab6-Copy-on-Write-Fork-for-xv6" class="headerlink" title="lab6 Copy-on-Write Fork for xv6"></a>lab6 Copy-on-Write Fork for xv6</h2><blockquote><p>Virtual memory provides a level of indirection: the kernel can intercept memory references by marking PTEs invalid or read-only, leading to page faults, and can change what addresses mean by modifying PTEs. There is a saying in computer systems that any systems problem can be solved with a level of indirection. The lazy allocation lab provided one example. This lab explores another example: copy-on write fork.</p></blockquote><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><p>哎，啥也不多说了，题目做起来快，但是debug花的时间太多了（我太菜了QAQ）</p><p>第一个遇到的bug，也是我花了最多时间，并且目前还没get到为什么不行的地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">COW_alloc</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> ptl,uint64 va)</span>&#123;<br>    va = PGROUNDDOWN(va);<br>    <span class="hljs-type">pte_t</span> * pte;<br>    <span class="hljs-keyword">if</span>((pte=walk(ptl,va,<span class="hljs-number">0</span>))==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;judge_page_fault walk err\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    uint64 pa =   PA2PTE(*pte);<br>    <span class="hljs-comment">//重设flag</span><br>    *pte=*pte | PTE_W;<br>    *pte=*pte &amp; ~PTE_COW;<br>    <span class="hljs-type">int</span> flag =  PTE_FLAGS(*pte);<br><br>    <span class="hljs-comment">//分配内存</span><br>    uint64  mem = (uint64) kalloc();<br>    <span class="hljs-keyword">if</span>(mem==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;COW_alloc kalloc failed\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    memmove((<span class="hljs-type">char</span>*)mem,(<span class="hljs-type">char</span>* )pa,PGSIZE);<br>    <span class="hljs-comment">//解除映射关系</span><br>    uvmunmap(ptl,va,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//重新映射</span><br>    <span class="hljs-keyword">if</span>(mappages(ptl,va,PGSIZE,(uint64)mem,flag)&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;COW_alloc mappages failed\n&quot;</span>);<br>        kfree((<span class="hljs-type">void</span>*)mem);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cow</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va)</span> &#123;<br>    <span class="hljs-keyword">if</span> (va &gt;= MAXVA) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 找到va对应的pte</span><br>    <span class="hljs-type">pte_t</span>* pte = walk(pagetable, va, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pte == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*pte &amp; PTE_V) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*pte &amp; PTE_COW) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((*pte &amp; PTE_U) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 物理地址</span><br>    uint64 pa = PTE2PA(*pte);<br>    uint64 ka = (uint64) kalloc();<br>    <span class="hljs-keyword">if</span> (ka == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 复制pa到ka</span><br>        memmove((<span class="hljs-type">char</span>*)ka, (<span class="hljs-type">char</span>*)pa, PGSIZE);<br>        uint64 flags = PTE_FLAGS(*pte);<br>        *pte = PA2PTE(ka) | flags | PTE_W;<br>        *pte &amp;= (~PTE_COW);<br>        <span class="hljs-comment">// 更新计数</span><br>        kfree((<span class="hljs-type">void</span> *)pa);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两段代码只有下面的可以跑通，上面的不行，但我自己看起来感觉没什么太大区别，上面的memmove通过不了，这是我最疑惑的地方，先插个眼，后面回过头来研究下</p><p>第二个就是锁，他的测试有几个是会上压力并发测试的，我在这里吃了个亏，读取的时候直接return了（QAQ）,所有的对COW引用数组的操作全要加锁，不然过不了usertests</p><p>最后是va大于MAXVA返回的位置，记得要放到walk前，不然最后会爆释放的页数对不上的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (va &gt;= MAXVA) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>差一个page对不上，改这里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa_start, <span class="hljs-type">void</span> *pa_end)</span><br>&#123;<br>  <span class="hljs-type">char</span> *p;<br>  p = (<span class="hljs-type">char</span>*)PGROUNDUP((uint64)pa_start);<br>  <span class="hljs-keyword">for</span>(; p + PGSIZE &lt;= (<span class="hljs-type">char</span>*)pa_end; p += PGSIZE)&#123;<br>      COW_COUNT[((uint64)p)/<span class="hljs-number">4096</span>] = <span class="hljs-number">1</span>;    <br>      kfree(p);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230911111329196.png"></p><h2 id="lab7-Multithreading"><a href="#lab7-Multithreading" class="headerlink" title="lab7 Multithreading"></a>lab7 Multithreading</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>This lab will familiarize you with multithreading. You will implement switching between threads in a user-level threads package, use multiple threads to speed up a program, and implement a barrier.</p></blockquote><p>线程相关的两节课看的我有点心累，也许是这两天状态没有调整好，还是说课程本来就比较抽象？（应该是自己的原因吧，确实感觉这两天很累）</p><h3 id="Uthread-switching-between-threads-moderate"><a href="#Uthread-switching-between-threads-moderate" class="headerlink" title="Uthread: switching between threads (moderate)"></a>Uthread: switching between threads (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Your job is to come up with a plan to create threads and save&#x2F;restore registers to switch between threads, and implement that plan. When you’re done, <code>make grade</code> should say that your solution passes the <code>uthread</code> test.</p></blockquote><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230912212557518.png"></p><h3 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h3><blockquote><p>Why are there missing keys with 2 threads, but not with 1 thread? Identify a sequence of events with 2 threads that can lead to a key being missing. Submit your sequence with a short explanation in answers-thread.txt</p><p>To avoid this sequence of events, insert lock and unlock statements in <code>put</code> and <code>get</code> in <code>notxv6/ph.c</code> so that the number of keys missing is always 0 with two threads. The relevant pthread calls are:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pthread_mutex_t <span class="hljs-keyword">lock</span>;            // <span class="hljs-keyword">declare</span> a <span class="hljs-keyword">lock</span><br>pthread_mutex_init(&amp;<span class="hljs-keyword">lock</span>, <span class="hljs-keyword">NULL</span>); // initialize the <span class="hljs-keyword">lock</span><br>pthread_mutex_lock(&amp;<span class="hljs-keyword">lock</span>);       // acquire <span class="hljs-keyword">lock</span><br>pthread_mutex_lock(&amp;<span class="hljs-keyword">lock</span>);       // <span class="hljs-keyword">release</span> <span class="hljs-keyword">lock</span><br></code></pre></td></tr></table></figure><p>You’re done when <code>make grade</code> says that your code passes the <code>ph_safe</code> test, which requires zero missing keys with two threads. It’s OK at this point to fail the <code>ph_fast</code> test.</p></blockquote><p>这里是并发不安全的，所以我们先测试在这里加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">put_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *xa)</span><br>&#123;<br>  <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) (<span class="hljs-type">long</span>) xa; <span class="hljs-comment">// thread number</span><br>  <span class="hljs-type">int</span> b = NKEYS/nthread;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b; i++) &#123;<br>pthread_mutex_lock(&amp;lock);     <span class="hljs-comment">//here</span><br>    put(keys[b*n + i], n);<br>pthread_mutex_lock(&amp;lock);  <span class="hljs-comment">//here</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是可以通过安全测试的，但是速度上慢得多，原因是我们加锁粒度太大了，我们一次把整个哈希表都锁住了</p><p>所以我们需要去降低锁的粒度，锁住每一个桶，而不是整个表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <br><span class="hljs-type">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span><br>&#123;<br>  <span class="hljs-type">int</span> i = key % NBUCKET;<br>    pthread_mutex_lock(&amp;lock[i]);<br>  <span class="hljs-comment">// is the key already present?</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (e = table[i]; e != <span class="hljs-number">0</span>; e = e-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;key == key)<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(e)&#123;<br>    <span class="hljs-comment">// update the existing key.</span><br>    e-&gt;value = value;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// the new is new.</span><br>    insert(key, value, &amp;table[i], table[i]);<br>  &#125;<br>    pthread_mutex_unlock(&amp;lock[i]);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> entry*<br><span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span><br>&#123;<br>  <span class="hljs-type">int</span> i = key % NBUCKET;<br>    pthread_mutex_lock(&amp;lock[i]);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">entry</span> *<span class="hljs-title">e</span> =</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (e = table[i]; e != <span class="hljs-number">0</span>; e = e-&gt;next) &#123;<br>    <span class="hljs-keyword">if</span> (e-&gt;key == key) <span class="hljs-keyword">break</span>;<br>  &#125;<br>    pthread_mutex_unlock(&amp;lock[i]);<br>  <span class="hljs-keyword">return</span> e;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">put_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *xa)</span><br>&#123;<br>  <span class="hljs-type">int</span> n = (<span class="hljs-type">int</span>) (<span class="hljs-type">long</span>) xa; <span class="hljs-comment">// thread number</span><br>  <span class="hljs-type">int</span> b = NKEYS/nthread;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b; i++) &#123;<br><br>    put(keys[b*n + i], n);<br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-type">pthread_t</span> *tha;<br>  <span class="hljs-type">void</span> *value;<br>  <span class="hljs-type">double</span> t1, t0;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;NBUCKET;i++) &#123;<br>        pthread_mutex_init(&amp;lock[i],<span class="hljs-literal">NULL</span>);<br>    &#125;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s nthreads\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br>  nthread = atoi(argv[<span class="hljs-number">1</span>]);<br>  tha = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">pthread_t</span>) * nthread);<br>  srandom(<span class="hljs-number">0</span>);<br>  assert(NKEYS % nthread == <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NKEYS; i++) &#123;<br>    keys[i] = random();<br>  &#125;<br><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// first the puts</span><br>  <span class="hljs-comment">//</span><br>  t0 = now();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    assert(pthread_create(&amp;tha[i], <span class="hljs-literal">NULL</span>, put_thread, (<span class="hljs-type">void</span> *) (<span class="hljs-type">long</span>) i) == <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    assert(pthread_join(tha[i], &amp;value) == <span class="hljs-number">0</span>);<br>  &#125;<br>  t1 = now();<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d puts, %.3f seconds, %.0f puts/second\n&quot;</span>,<br>         NKEYS, t1 - t0, NKEYS / (t1 - t0));<br><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// now the gets</span><br>  <span class="hljs-comment">//</span><br>  t0 = now();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    assert(pthread_create(&amp;tha[i], <span class="hljs-literal">NULL</span>, get_thread, (<span class="hljs-type">void</span> *) (<span class="hljs-type">long</span>) i) == <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nthread; i++) &#123;<br>    assert(pthread_join(tha[i], &amp;value) == <span class="hljs-number">0</span>);<br>  &#125;<br>  t1 = now();<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d gets, %.3f seconds, %.0f gets/second\n&quot;</span>,<br>         NKEYS*nthread, t1 - t0, (NKEYS*nthread) / (t1 - t0));<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Barrier-moderate"><a href="#Barrier-moderate" class="headerlink" title="Barrier(moderate)"></a>Barrier(moderate)</h3><blockquote><p>Your goal is to achieve the desired barrier behavior. In addition to the lock primitives that you have seen in the <code>ph</code> assignment, you will need the following new pthread primitives; look <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_wait.html">here</a> and <a href="https://pubs.opengroup.org/onlinepubs/007908799/xsh/pthread_cond_broadcast.html">here</a> for details.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">pthread<span class="hljs-constructor">_cond_wait(&amp;<span class="hljs-params">cond</span>, &amp;<span class="hljs-params">mutex</span>)</span>;  <span class="hljs-comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span><br>pthread<span class="hljs-constructor">_cond_broadcast(&amp;<span class="hljs-params">cond</span>)</span>;     <span class="hljs-comment">// wake up every thread sleeping on cond</span><br></code></pre></td></tr></table></figure><p>Make sure your solution passes <code>make grade</code>‘s <code>barrier</code> test.</p></blockquote><p>跟着他的提示来就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <br><span class="hljs-title function_">barrier</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">// YOUR CODE HERE</span><br>  <span class="hljs-comment">//</span><br>  <span class="hljs-comment">// Block until all threads have called barrier() and</span><br>  <span class="hljs-comment">// then increment bstate.round.</span><br>  <span class="hljs-comment">//</span><br>    pthread_mutex_lock(&amp;bstate.barrier_mutex);<br>    bstate.nthread++;<br>    <span class="hljs-keyword">if</span>(bstate.nthread&lt;nthread)&#123;<br>        pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        bstate.nthread=<span class="hljs-number">0</span>;<br>        bstate.round++;<br>        pthread_cond_broadcast(&amp;bstate.barrier_cond);<br>    &#125;<br>    pthread_mutex_unlock(&amp;bstate.barrier_mutex);<br><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>怎么说呢，这次的实验还是挺简单的，全程3个小时多</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/20230917103802.png"></p><h2 id="Lab8-locks"><a href="#Lab8-locks" class="headerlink" title="Lab8: locks"></a>Lab8: locks</h2><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>In this lab you’ll gain experience in re-designing code to increase parallelism. A common symptom of poor parallelism on multi-core machines is high lock contention. Improving parallelism often involves changing both data structures and locking strategies in order to reduce contention. You’ll do this for the xv6 memory allocator and block cache.</p></blockquote><h3 id="Memory-allocator-moderate"><a href="#Memory-allocator-moderate" class="headerlink" title="Memory allocator (moderate)"></a>Memory allocator (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Your job is to implement per-CPU freelists, and stealing when a CPU’s free list is empty. You must give all of your locks names that start with “kmem”. That is, you should call <code>initlock</code> for each of your locks, and pass a name that starts with “kmem”. Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run <code>usertests sbrkmuch</code>. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ. Make sure all tests in <code>usertests</code> pass. <code>make grade</code> should say that the kalloctests pass.</p></blockquote><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/20230917104314.png"></p><h3 id="Buffer-cache-hard"><a href="#Buffer-cache-hard" class="headerlink" title="Buffer cache (hard)"></a>Buffer cache (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h3><blockquote><p>Modify the block cache so that the number of <code>acquire</code> loop iterations for all locks in the bcache is close to zero when running <code>bcachetest</code>. Ideally the sum of the counts for all locks involved in the block cache should be zero, but it’s OK if the sum is less than 500. Modify <code>bget</code> and <code>brelse</code> so that concurrent lookups and releases for different blocks that are in the bcache are unlikely to conflict on locks (e.g., don’t all have to wait for <code>bcache.lock</code>). You must maintain the invariant that at most one copy of each block is cached. When you are done, your output should be similar to that shown below (though not identical). Make sure usertests still passes. <code>make grade</code> should pass all tests when you are done.</p></blockquote><p>锁竞争优化一般有几个思路：</p><ul><li>只在必须共享的时候共享（对应为将资源从 CPU 共享拆分为每个 CPU 独立）</li><li>必须共享时，尽量减少在关键区中停留的时间（对应“大锁化小锁”，降低锁的粒度）</li></ul><p>感觉挺有用的</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230913225009710.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">usertests</span><br>usertests starting<br>test manywrites: OK<br>test execout: OK<br>test copyin: OK<br>test copyout: OK<br>test copyinstr1: OK<br>test copyinstr2: OK<br>test copyinstr3: OK<br>test rwsbrk: OK<br>test truncate1: OK<br>test truncate2: OK<br>test truncate3: OK<br>test reparent2: OK<br>test pgbug: OK<br>test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3243<br>            sepc=0x00000000000056a4 stval=0x00000000000056a4<br>usertrap(): unexpected scause 0x000000000000000c pid=3244<br>            sepc=0x00000000000056a4 stval=0x00000000000056a4<br>OK<br>test badarg: OK<br>test reparent: OK<br>test twochildren: OK<br>test forkfork: OK<br>test forkforkfork: OK<br>test argptest: OK<br>test createdelete: OK<br>test linkunlink: OK<br>test linktest: OK<br>test unlinkread: OK<br>test concreate: OK<br>test subdir: OK<br>test fourfiles: OK<br>test sharedfd: OK<br>test dirtest: OK<br>test exectest: OK<br>test bigargtest: OK<br>test bigwrite: OK<br>test bsstest: OK<br>test sbrkbasic: OK<br>test sbrkmuch: OK<br>test kernmem: usertrap(): unexpected scause 0x000000000000000d pid=6224<br>            sepc=0x000000000000215c stval=0x0000000080000000<br>usertrap(): unexpected scause 0x000000000000000d pid=6225<br>            sepc=0x000000000000215c stval=0x000000008000c350<br>usertrap(): unexpected scause 0x000000000000000d pid=6226<br>            sepc=0x000000000000215c stval=0x00000000800186a0<br>usertrap(): unexpected scause 0x000000000000000d pid=6227<br>            sepc=0x000000000000215c stval=0x00000000800249f0<br>usertrap(): unexpected scause 0x000000000000000d pid=6228<br>            sepc=0x000000000000215c stval=0x0000000080030d40<br>usertrap(): unexpected scause 0x000000000000000d pid=6229<br>            sepc=0x000000000000215c stval=0x000000008003d090<br>usertrap(): unexpected scause 0x000000000000000d pid=6230<br>            sepc=0x000000000000215c stval=0x00000000800493e0<br>usertrap(): unexpected scause 0x000000000000000d pid=6231<br>            sepc=0x000000000000215c stval=0x0000000080055730<br>usertrap(): unexpected scause 0x000000000000000d pid=6232<br>            sepc=0x000000000000215c stval=0x0000000080061a80<br>usertrap(): unexpected scause 0x000000000000000d pid=6233<br>            sepc=0x000000000000215c stval=0x000000008006ddd0<br>usertrap(): unexpected scause 0x000000000000000d pid=6234<br>            sepc=0x000000000000215c stval=0x000000008007a120<br>usertrap(): unexpected scause 0x000000000000000d pid=6235<br>            sepc=0x000000000000215c stval=0x0000000080086470<br>usertrap(): unexpected scause 0x000000000000000d pid=6236<br>            sepc=0x000000000000215c stval=0x00000000800927c0<br>usertrap(): unexpected scause 0x000000000000000d pid=6237<br>            sepc=0x000000000000215c stval=0x000000008009eb10<br>usertrap(): unexpected scause 0x000000000000000d pid=6238<br>            sepc=0x000000000000215c stval=0x00000000800aae60<br>usertrap(): unexpected scause 0x000000000000000d pid=6239<br>            sepc=0x000000000000215c stval=0x00000000800b71b0<br>usertrap(): unexpected scause 0x000000000000000d pid=6240<br>            sepc=0x000000000000215c stval=0x00000000800c3500<br>usertrap(): unexpected scause 0x000000000000000d pid=6241<br>            sepc=0x000000000000215c stval=0x00000000800cf850<br>usertrap(): unexpected scause 0x000000000000000d pid=6242<br>            sepc=0x000000000000215c stval=0x00000000800dbba0<br>usertrap(): unexpected scause 0x000000000000000d pid=6243<br>            sepc=0x000000000000215c stval=0x00000000800e7ef0<br>usertrap(): unexpected scause 0x000000000000000d pid=6244<br>            sepc=0x000000000000215c stval=0x00000000800f4240<br>usertrap(): unexpected scause 0x000000000000000d pid=6245<br>            sepc=0x000000000000215c stval=0x0000000080100590<br>usertrap(): unexpected scause 0x000000000000000d pid=6246<br>            sepc=0x000000000000215c stval=0x000000008010c8e0<br>usertrap(): unexpected scause 0x000000000000000d pid=6247<br>            sepc=0x000000000000215c stval=0x0000000080118c30<br>usertrap(): unexpected scause 0x000000000000000d pid=6248<br>            sepc=0x000000000000215c stval=0x0000000080124f80<br>usertrap(): unexpected scause 0x000000000000000d pid=6249<br>            sepc=0x000000000000215c stval=0x00000000801312d0<br>usertrap(): unexpected scause 0x000000000000000d pid=6250<br>            sepc=0x000000000000215c stval=0x000000008013d620<br>usertrap(): unexpected scause 0x000000000000000d pid=6251<br>            sepc=0x000000000000215c stval=0x0000000080149970<br>usertrap(): unexpected scause 0x000000000000000d pid=6252<br>            sepc=0x000000000000215c stval=0x0000000080155cc0<br>usertrap(): unexpected scause 0x000000000000000d pid=6253<br>            sepc=0x000000000000215c stval=0x0000000080162010<br>usertrap(): unexpected scause 0x000000000000000d pid=6254<br>            sepc=0x000000000000215c stval=0x000000008016e360<br>usertrap(): unexpected scause 0x000000000000000d pid=6255<br>            sepc=0x000000000000215c stval=0x000000008017a6b0<br>usertrap(): unexpected scause 0x000000000000000d pid=6256<br>            sepc=0x000000000000215c stval=0x0000000080186a00<br>usertrap(): unexpected scause 0x000000000000000d pid=6257<br>            sepc=0x000000000000215c stval=0x0000000080192d50<br>usertrap(): unexpected scause 0x000000000000000d pid=6258<br>            sepc=0x000000000000215c stval=0x000000008019f0a0<br>usertrap(): unexpected scause 0x000000000000000d pid=6259<br>            sepc=0x000000000000215c stval=0x00000000801ab3f0<br>usertrap(): unexpected scause 0x000000000000000d pid=6260<br>            sepc=0x000000000000215c stval=0x00000000801b7740<br>usertrap(): unexpected scause 0x000000000000000d pid=6261<br>            sepc=0x000000000000215c stval=0x00000000801c3a90<br>usertrap(): unexpected scause 0x000000000000000d pid=6262<br>            sepc=0x000000000000215c stval=0x00000000801cfde0<br>usertrap(): unexpected scause 0x000000000000000d pid=6263<br>            sepc=0x000000000000215c stval=0x00000000801dc130<br>OK<br>test sbrkfail: usertrap(): unexpected scause 0x000000000000000d pid=6275<br>            sepc=0x00000000000041fc stval=0x0000000000012000<br>OK<br>test sbrkarg: OK<br>test validatetest: OK<br>test stacktest: usertrap(): unexpected scause 0x000000000000000d pid=6279<br>            sepc=0x00000000000022cc stval=0x000000000000fb90<br>OK<br>test opentest: OK<br>test writetest: OK<br>test writebig: OK<br>test createtest: OK<br>test openiput: OK<br>test exitiput: OK<br>test iput: OK<br>test mem: OK<br>test pipe1: OK<br>test preempt: kill... wait... OK<br>test exitwait: OK<br>test rmdot: OK<br>test fourteen: OK<br>test bigfile: OK<br>test dirfile: OK<br>test iref: OK<br>test forktest: OK<br>test bigdir: OK<br>ALL TESTS PASSED<br></code></pre></td></tr></table></figure><p>这里有个坑点折腾了很久</p><p>如果你make qemu后不make clean，那么你会发现你在xv6终端里可以通过bcachetest，但是退出后make grade 会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">== Test   bcachetest: test0 == <br>  bcachetest: test0: FAIL <br>    ...<br>         tot= 3280<br>         test0: FAIL<br>         start test1<br>         test1 OK<br>         $ qemu-system-riscv64: terminating on signal 15 from pid 9889 (make)<br>    MISSING &#x27;^test0: OK$&#x27;<br></code></pre></td></tr></table></figure><p>所以make grade的时候记得先make clean QAQ</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230914090136982.png"></p><h2 id="Lab9-file-system"><a href="#Lab9-file-system" class="headerlink" title="Lab9: file system"></a>Lab9: file system</h2><p>（从此题开始持续优化blog的创作流，目前还没有形成一个属于自己的创作体系）</p><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><blockquote><p>Before writing code, you should read “Chapter 8: File system” from the <a href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a> and study the corresponding code.</p></blockquote><h3 id="Large-files-moderate"><a href="#Large-files-moderate" class="headerlink" title="Large files (moderate)"></a>Large files (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>Modify <code>bmap()</code> so that it implements a doubly-indirect block, in addition to direct blocks and a singly-indirect block. You’ll have to have only 11 direct blocks, rather than 12, to make room for your new doubly-indirect block; you’re not allowed to change the size of an on-disk inode. The first 11 elements of <code>ip-&gt;addrs[]</code> should be direct blocks; the 12th should be a singly-indirect block (just like the current one); the 13th should be your new doubly-indirect block. You are done with this exercise when <code>bigfile</code> writes 65803 blocks and <code>usertests</code> runs successfully:</p></blockquote><p>第一个要你实现二级链接块，我一开始没理解到题目意思，理解了二级链接块的概念后，这题就很快了</p><p>他是每一个bn对应一个块</p><p>也就是说如果是直接块，那么久可以直接读取 0–10块</p><p>如果是间接块，一级间接块在11块</p><p>二级间接块在12块</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230915074742194.png"></p><p>对于1级间接块，代码中已经给出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//如果大于等于11，说明是一级间接块</span><br>   bn -= NDIRECT;<br>   <span class="hljs-keyword">if</span> (bn &lt; NINDIRECT) &#123;<br>       <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>       <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>           ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>       bp = bread(ip-&gt;dev, addr);   <span class="hljs-comment">//文件载入</span><br>       a = (uint *) bp-&gt;data;<br>       <span class="hljs-keyword">if</span> ((addr = a[bn]) == <span class="hljs-number">0</span>) &#123;<br>           a[bn] = addr = balloc(ip-&gt;dev);<br>           log_write(bp);<br>       &#125;<br>       brelse(bp);<br>       <span class="hljs-keyword">return</span> addr;<br>   &#125;<br></code></pre></td></tr></table></figure><p>二级间接块 ，之前看到一个csdn讲二级链接块概念的blog，里面有章图很形象，但没找到，这边就手动绘制一下（有点丑，见谅QAQ）</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230915075928178.png"></p><p>由图可知，我们需要先从块缓存中载入一级索引表，用bn&#x2F;NINDIRECT找到所在的二级索引表的index，最后载入对应的二级索引表，根据bn%NINDIRECT,可以确定实际块的位置，总之理解到了的话就是复制粘贴一级索引块的处理方式，让他多载入几次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint<br><span class="hljs-title function_">bmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip, uint bn)</span> &#123;<br>    uint addr, *a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span>;</span><br><br>    <span class="hljs-keyword">if</span> (bn &lt; NDIRECT) &#123;  <span class="hljs-comment">// 如果bn是小于11的， 处理直接块</span><br>        <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[bn]) == <span class="hljs-number">0</span>)<br>            ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);<br>        <span class="hljs-keyword">return</span> addr;<br>    &#125;<br>    <span class="hljs-comment">//如果大于等于11，说明是一级间接块</span><br>    bn -= NDIRECT;<br>    <span class="hljs-keyword">if</span> (bn &lt; NINDIRECT) &#123;<br>        <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>        <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT]) == <span class="hljs-number">0</span>)<br>            ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);<br>        bp = bread(ip-&gt;dev, addr);   <span class="hljs-comment">//文件载入</span><br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">if</span> ((addr = a[bn]) == <span class="hljs-number">0</span>) &#123;<br>            a[bn] = addr = balloc(ip-&gt;dev);<br>            log_write(bp);<br>        &#125;<br>        brelse(bp);<br>        <span class="hljs-keyword">return</span> addr;<br>    &#125;<br>    bn -= NINDIRECT;     <span class="hljs-comment">//剪前11块，和一级间接地址的256块减掉，就是2级间接块的地址</span><br><br>    <span class="hljs-keyword">if</span> (bn &lt; NINDIRECT * NINDIRECT) &#123;<br>        <span class="hljs-comment">// Load indirect block, allocating if necessary.</span><br>        <span class="hljs-keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>)<br>            ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>] = addr = balloc(ip-&gt;dev);<br>        bp = bread(ip-&gt;dev, addr);   <span class="hljs-comment">//文件载入   256个2级索引表载入</span><br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">if</span> ((addr = a[bn / NINDIRECT]) == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//最终指向的索引块载入</span><br>            a[bn / NINDIRECT] = addr = balloc(ip-&gt;dev);<br>            log_write(bp);<br>        &#125;<br>        brelse(bp);<br>        <span class="hljs-comment">//块中对应的地址载入</span><br>        <span class="hljs-type">int</span> index = bn % NINDIRECT; <span class="hljs-comment">//确定在块中的位置</span><br>        bp = bread(ip-&gt;dev, addr);   <span class="hljs-comment">//文件载入   256个2级索引表载入</span><br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">if</span> ((addr = a[index]) == <span class="hljs-number">0</span>) &#123;<br>            a[index] = addr = balloc(ip-&gt;dev);<br>            log_write(bp);<br>        &#125;<br>        brelse(bp);<br>        <span class="hljs-keyword">return</span> addr;<br>    &#125;<br><br>    panic(<span class="hljs-string">&quot;bmap: out of range&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>理解到位后，释放也是差不多的原理，也可以说是可以复制粘贴吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Truncate inode (discard contents).</span><br><span class="hljs-comment">// Caller must hold ip-&gt;lock.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">itrunc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *ip)</span> &#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bp</span> ,*<span class="hljs-title">bp1</span>;</span><br>    uint *a, *b;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NDIRECT; i++) &#123;  <span class="hljs-comment">// direct blocks</span><br>        <span class="hljs-keyword">if</span> (ip-&gt;addrs[i]) &#123;<br>            bfree(ip-&gt;dev, ip-&gt;addrs[i]);<br>            ip-&gt;addrs[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ip-&gt;addrs[NDIRECT]) &#123;   <span class="hljs-comment">//indirect block</span><br>        bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++) &#123;<br>            <span class="hljs-keyword">if</span> (a[j])<br>                bfree(ip-&gt;dev, a[j]);<br>        &#125;<br>        brelse(bp);<br>        bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);<br>        ip-&gt;addrs[NDIRECT] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]) &#123;   <span class="hljs-comment">// second indirect block</span><br>        bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]);<br>        a = (uint *) bp-&gt;data;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; NINDIRECT; j++) &#123;<br>            <span class="hljs-keyword">if</span>(a[j])&#123;<br>                bp1 = bread(ip-&gt;dev, a[j]);<br>                b = (uint *) bp1-&gt;data;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; NINDIRECT; ++k) &#123;<br>                    <span class="hljs-keyword">if</span> (b[k])<br>                        bfree(ip-&gt;dev, b[k]);<br>                &#125;<br>                brelse(bp1);<br>                bfree(ip-&gt;dev, a[j]);<br>            &#125;<br>        &#125;<br>        brelse(bp);<br>        bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>]);<br>        ip-&gt;addrs[NDIRECT + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br>    ip-&gt;size = <span class="hljs-number">0</span>;<br>    iupdate(ip);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230914211707841.png"></p><h3 id="Symbolic-links-moderate"><a href="#Symbolic-links-moderate" class="headerlink" title="Symbolic links (moderate)"></a>Symbolic links (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3><blockquote><p>You will implement the <code>symlink(char *target, char *path)</code> system call, which creates a new symbolic link at path that refers to file named by target. For further information, see the man page symlink. To test, add symlinktest to the Makefile and run it. Your solution is complete when the tests produce the following output (including usertests succeeding).</p></blockquote><p>这题比较简单，当时也比较晚了快11点图书馆闭馆了，我就直接看大佬的博客了，理解到了概念就很简单</p><p>理解可以参考这篇文章 <a href="https://blog.csdn.net/Csw_PHPer/article/details/106684375">https://blog.csdn.net/Csw_PHPer/article/details/106684375</a></p><p>个人感觉把软链接讲的很清楚了</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230914225252339.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230915103108823.png"></p><h2 id="Lab10-mmap-hard"><a href="#Lab10-mmap-hard" class="headerlink" title="Lab10: mmap (hard)"></a>Lab10: mmap (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h2><blockquote><p>You should implement enough <code>mmap</code> and <code>munmap</code> functionality to make the <code>mmaptest</code> test program work. If <code>mmaptest</code> doesn’t use a <code>mmap</code> feature, you don’t need to implement that feature.</p></blockquote><p><strong>代码仓库地址：</strong><a href="https://github.com/MadFrey/xv6">MadFrey&#x2F;xv6 (github.com)</a></p><p>9.17  mit6.s081就算是正式完结了，network要看很多手册，而且我看了下其他做完了的博客也并不是很难，这里就先不做了</p><p>然后mmap还是有难度的，花了我大概10个小时左右的时间吧（虽然在前一天花了一晚上调bug，太菜了QAQ)</p><p>先是sys_mmap的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">sys_mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr, sz, offset;<br>    <span class="hljs-type">int</span> prot, flags, fd; <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span>;</span><br>    uint64 end  =  TRAPFRAME;<br>    <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;sz) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">2</span>, &amp;prot) &lt; <span class="hljs-number">0</span><br>       || argint(<span class="hljs-number">3</span>, &amp;flags) &lt; <span class="hljs-number">0</span> || argfd(<span class="hljs-number">4</span>, &amp;fd, &amp;f) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">5</span>, &amp;offset) &lt; <span class="hljs-number">0</span> || sz == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span>(!f-&gt;writable &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; (flags == MAP_SHARED))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; VMASIZE; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">0</span>)<br>        &#123;<br>            j=i;<br>            p-&gt;vmas[i].valid = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// important!</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            end = PGROUNDDOWN(p-&gt;vmas[i].vastart);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(j == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span>* <span class="hljs-title">v</span> =</span> &amp;p-&gt;vmas[j];<br>    sz = PGROUNDUP(sz);     <span class="hljs-comment">//注意对齐</span><br><br><br>    v-&gt;vastart = end - sz;<br>    v-&gt;sz = sz;<br>    v-&gt;prot = prot;<br>    v-&gt;flags = flags;<br>    v-&gt;f = f;<br>    v-&gt;offset = offset;<br><br>    filedup(v-&gt;f);<br><br>    <span class="hljs-keyword">return</span> v-&gt;vastart;<br>&#125;<br></code></pre></td></tr></table></figure><p>前一天晚上调了很久就是因为有些细节没处理好</p><p>这里一定要  end &#x3D; PGROUNDDOWN(p-&gt;vmas[i].vastart)，因为test中所有的mmap的addr都是从0开始的，一定要记得更新end，不然test mmap two files 会过不去</p><p>加了更新end的分支后一定要记得加break，不然第二个就过不去了（全部vma都被设置成了1在第一个测试点中）</p><p>最后不要忘了sz &#x3D; PGROUNDUP(sz); 内存对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">0</span>)<br>      &#123;<br>          j=i;<br>          p-&gt;vmas[i].valid = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// important!</span><br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          end = PGROUNDDOWN(p-&gt;vmas[i].vastart);<br>      &#125;<br></code></pre></td></tr></table></figure><p>因为是lazy allocation，所以要在usertrap中进行修改处理page fault，这个和之前做过的实验差不多，这里就不多讲了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);<br><br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),</span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.</span><br>  w_stvec((uint64)kernelvec);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <br>  <span class="hljs-comment">// save user program counter.</span><br>  p-&gt;trapframe-&gt;epc = r_sepc();<br>  <br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br><br>    <span class="hljs-keyword">if</span>(p-&gt;killed)<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// sepc points to the ecall instruction,</span><br>    <span class="hljs-comment">// but we want to return to the next instruction.</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// an interrupt will change sstatus &amp;c registers,</span><br>    <span class="hljs-comment">// so don&#x27;t enable until done with those registers.</span><br>    intr_on();<br><br>    syscall();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span>  (r_scause()==<span class="hljs-number">13</span>||r_scause()==<span class="hljs-number">15</span>)&#123;<br>          uint64 va = r_stval();<br>          <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span>* <span class="hljs-title">v</span> =</span> <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; VMASIZE; ++i) &#123;<br>              <span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; va &gt;= p-&gt;vmas[i].vastart &amp;&amp; va &lt; p-&gt;vmas[i].vastart + p-&gt;vmas[i].sz) &#123;<br>                 v=&amp;p-&gt;vmas[i];<br>              &#125;<br>          &#125;<br><br>          <span class="hljs-keyword">if</span>(v==<span class="hljs-number">0</span>)&#123;<br>              p-&gt;killed=<span class="hljs-number">1</span>;<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>              <span class="hljs-type">void</span> *pa = kalloc();<br>              <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>) &#123;<br>                  panic(<span class="hljs-string">&quot;vmalazytouch: kalloc&quot;</span>);<br>              &#125;<br>              <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">0</span>, PGSIZE);<br>              begin_op();<br>              ilock(v-&gt;f-&gt;ip);<br>              readi(v-&gt;f-&gt;ip, <span class="hljs-number">0</span>, (uint64)pa, v-&gt;offset + PGROUNDDOWN(va - v-&gt;vastart), PGSIZE);<br>              iunlock(v-&gt;f-&gt;ip);<br>              end_op();<br><br>              <span class="hljs-type">int</span> perm = PTE_U;<br>              <span class="hljs-keyword">if</span>(v-&gt;prot &amp; PROT_READ)<br>                  perm |= PTE_R;<br>              <span class="hljs-keyword">if</span>(v-&gt;prot &amp; PROT_WRITE)<br>                  perm |= PTE_W;<br>              <span class="hljs-keyword">if</span>(v-&gt;prot &amp; PROT_EXEC)<br>                  perm |= PTE_X;<br><br>              <span class="hljs-keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, (uint64)pa, perm) &lt; <span class="hljs-number">0</span>) &#123;<br>                  panic(<span class="hljs-string">&quot;vmalazytouch: mappages&quot;</span>);<br>              &#125;<br><br>          &#125;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());<br>          p-&gt;killed = <span class="hljs-number">1</span>;<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(p-&gt;killed)<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    yield();<br><br>  usertrapret();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是munmap ，这里为了方便，就直接使用页为单位来进行解除映射（可以直接使用uvmmap，偷个懒），如果sz为0了记得取消引用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c">uint64 <span class="hljs-title function_">sys_munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 addr, sz;<br><br>    <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">1</span>, &amp;sz) &lt; <span class="hljs-number">0</span> || sz == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span>* <span class="hljs-title">v</span> =</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; VMASIZE; ++i) &#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">1</span> &amp;&amp; addr &gt;= p-&gt;vmas[i].vastart &amp;&amp; addr &lt; p-&gt;vmas[i].vastart + p-&gt;vmas[i].sz) &#123;<br>            v=&amp;p-&gt;vmas[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(v == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(v-&gt;flags &amp; MAP_SHARED)&#123;<br>        filewrite(v-&gt;f, addr, sz);<br>    &#125;<br><br>    uvmunmap(p-&gt;pagetable, addr, PGROUNDUP(sz) / PGSIZE, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(addr == v-&gt;vastart)&#123;<br>       v-&gt;vastart += PGROUNDUP(sz);<br>    &#125;<br>    v-&gt;sz -= sz;<br>    <span class="hljs-keyword">if</span>(v-&gt;sz == <span class="hljs-number">0</span>)<br>    &#123;<br>        fileclose(v-&gt;f);<br>        <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)v, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(v));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>到此就已经可以通过mmap_test了</p><p>最后对fork和exit进行简单修改即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  np-&gt;parent = p;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; VMASIZE; i++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vma</span> *<span class="hljs-title">v</span> =</span> &amp;p-&gt;vmas[i];<br>        <span class="hljs-keyword">if</span>(v-&gt;valid) &#123;<br>            np-&gt;vmas[i] = *v;<br>            filedup(v-&gt;f);<br>        &#125;<br>    &#125;<br><br><br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  np-&gt;state = RUNNABLE;<br><br>  release(&amp;np-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span>(p == initproc)<br>    panic(<span class="hljs-string">&quot;init exiting&quot;</span>);<br><br>  <span class="hljs-comment">// Close all open files.</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>; fd &lt; NOFILE; fd++)&#123;<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[fd])&#123;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">f</span> =</span> p-&gt;ofile[fd];<br>      fileclose(f);<br>      p-&gt;ofile[fd] = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; VMASIZE; i ++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;vmas[i].valid == <span class="hljs-number">1</span>)<br>        &#123;<br>            uint64 sz = p-&gt;vmas[i].sz;<br>            fileclose(p-&gt;vmas[i].f);<br>            <span class="hljs-comment">// 取消映射</span><br>            uvmunmap(p-&gt;pagetable, p-&gt;vmas[i].vastart, PGROUNDUP(sz) / PGSIZE, <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 清空vma</span><br>            <span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)&amp;p-&gt;vmas[i], <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;vmas[i]));<br><br>        &#125;<br>    &#125;<br><br><br> ......<br>&#125;<br></code></pre></td></tr></table></figure><p>在make grade的时候可能会遇到env: python3\r: No such file or directory 的问题</p><p>vim打开 lab-mmap脚本,输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">:set ff=unix<br>:wq!<br></code></pre></td></tr></table></figure><p>即可解决问题   <a href="https://code84.com/79.html">env: python3\r</a></p><p>通过测试如下图</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230917083149756.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230917085710821.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大概花了两个星期吧做完lab0-lab10 ，个人感觉印象深刻是lab3，lab8，和lab10吧，lab8最后一个实验我是看着大佬的博客来写的，确实水平还不够</p><p>在这个实验的后半部分开始慢慢优化我的blog写作，还是希望自己的blog能够有能帮助大家的东西，慢慢来吧</p><p>个人感觉还是很有收获的，但是感觉对于学习os来说还远远不够，比如说作为教学os的xv6一个进程只有一个线程等等，很多地方都简化了</p><p>但作为一门导论课来说还是非常有含金量的，整顿一下明天开二周目了</p><p>有机会我想开一个读论文的坑了，后面有时间再说吧 </p><p>到这里就完结了，下个坑再见， bye ~</p>]]></content>
    
    
    <categories>
      
      <category>lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT6.S081</tag>
      
      <tag>lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cs144-lab0~lab7</title>
    <link href="/2023/08/12/cs144-lab0-lab7/"/>
    <url>/2023/08/12/cs144-lab0-lab7/</url>
    
    <content type="html"><![CDATA[<p>lab0-lab5 code：<a href="https://github.com/MadFrey/minnow">MadFrey&#x2F;minnow (github.com)</a></p><p>lab6和lab7自行测试</p><p>历时大概两个星期，八月中旬到八月底，期间还有段时间没花在这上面</p><p>整体感觉下来lab1和lab3难度较高，其他的根据pdf的描述再加上自己去了解一下原理，都不难写</p><h2 id="lab-0"><a href="#lab-0" class="headerlink" title="lab 0"></a>lab 0</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@hecs-271160 ~]# telnet cs144.keithw.org http<br>Trying 104.196.238.229...<br>Connected to cs144.keithw.org.<br>Escape character is &#x27;^]&#x27;.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">telnet&gt; </span><span class="language-bash"></span><br><span class="language-bash">GET /hello HTTP/1.1</span><br>Host: cs144.keithw.org<br><br>HTTP/1.1 200 OK<br>Date: Sat, 12 Aug 2023 15:07:45 GMT<br>Server: Apache<br>Last-Modified: Thu, 13 Dec 2018 15:45:29 GMT<br>ETag: &quot;e-57ce93446cb64&quot;<br>Accept-Ranges: bytes<br>Content-Length: 14<br>Content-Type: text/plain<br><br>Hello, CS144!<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hecs-271160 ~]# telnet cs144.keithw.org http<br>Trying 104.196.238.229...<br>Connected to cs144.keithw.org.<br>Escape character is &#x27;^]&#x27;.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">telnet&gt; </span><span class="language-bash"></span><br><span class="language-bash">GET /lab0/MadFrey HTTP/1.1</span>    <br>Host: cs144.keithw.org<br><br>HTTP/1.1 200 OK<br>Date: Sat, 12 Aug 2023 15:13:12 GMT<br>Server: Apache<br>X-You-Said-Your-SunetID-Was: MadFrey<br>X-Your-Code-Is: 794944<br>Content-length: 111<br>Vary: Accept-Encoding<br>Content-Type: text/plain<br><br>Hello! You told us that your SUNet ID was &quot;MadFrey&quot;. Please see the HTTP headers (above) for your secret code.<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hecs-271160 etc]# telnet localhost 9090<br>Trying ::1...<br>telnet: connect to address ::1: Connection refused<br>Trying 127.0.0.1...<br>Connected to localhost.<br>Escape character is &#x27;^]&#x27;.<br>11111<br>3243435<br>MadFrey <br>^CConnection closed by foreign host.<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@hecs-271160 netcat-0.7.1]# netcat -u 127.0.0.1 8004<br>^C[root@hecs-271160 netcat-0.7.1]# netcat -v -l -p 9090<br>Connection from 127.0.0.1:34572<br>11111<br>3243435<br>MadFrey<br>Exiting.<br>[root@hecs-271160 netcat-0.7.1]# <br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">( <span class="hljs-type">const</span> string&amp; host, <span class="hljs-type">const</span> string&amp; path )</span></span><br><span class="hljs-function"></span>&#123;<br>  TCPSocket socket;<br>  socket.<span class="hljs-built_in">connect</span>( <span class="hljs-built_in">Address</span>( host, <span class="hljs-string">&quot;http&quot;</span> ) );<br>  socket.<span class="hljs-built_in">write</span>( <span class="hljs-string">&quot;GET &quot;</span> + path + <span class="hljs-string">&quot; HTTP/1.1\r\nHost: &quot;</span> + host + <span class="hljs-string">&quot;\r\nConnection: close\r\n\r\n&quot;</span> );<br><br>  <span class="hljs-keyword">while</span> ( !socket.<span class="hljs-built_in">eof</span>() ) &#123;<br>    std::string buffers;<br>    socket.<span class="hljs-built_in">read</span>( buffers );<br>    cout &lt;&lt; buffers;<br>  &#125;<br>  socket.<span class="hljs-built_in">close</span>();<br>  cerr &lt;&lt; <span class="hljs-string">&quot;Function called: get_URL(&quot;</span> &lt;&lt; host &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; path &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>  cerr &lt;&lt; <span class="hljs-string">&quot;Warning: get_URL() has not been implemented yet.\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230901135240852.png"></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230817174534608.png" alt="img"></p><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p>自己先用优先队列写了一遍，发现代码过于复杂，并且时间复杂度太高了，测试点超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;reassembler.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reassembler::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> closed_ &amp;&amp; <span class="hljs-built_in">bytes_pending</span>() == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reassembler::insert</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> first_index, string data, <span class="hljs-type">bool</span> is_last_substring, Writer&amp; output )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// Your code here.</span><br>  <span class="hljs-keyword">if</span> ( is_last_substring ) &#123;<br>    closed_ = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// important!</span><br>  <span class="hljs-keyword">if</span> ( first_index &gt;= unassembled_index + output.<span class="hljs-built_in">available_capacity</span>() || <span class="hljs-comment">/* Out of bound */</span><br>       first_index + data.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> &lt; unassembled_index ||            <span class="hljs-comment">/* Data have been transferred */</span><br>       data.<span class="hljs-built_in">empty</span>() || output.<span class="hljs-built_in">available_capacity</span>() == <span class="hljs-number">0</span> ) &#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">is_closed</span>() ) &#123;<br>      output.<span class="hljs-built_in">close</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ( first_index &lt; unassembled_index ) &#123;<br>    <span class="hljs-comment">// overlap</span><br>    <span class="hljs-keyword">if</span> ( first_index + data.<span class="hljs-built_in">size</span>() &gt; unassembled_index ) &#123;<br>      <span class="hljs-comment">// overlap</span><br>      <span class="hljs-type">size_t</span> overlap = unassembled_index - first_index;<br>      <span class="hljs-type">size_t</span> new_data_size = data.<span class="hljs-built_in">size</span>() - overlap;<br>      string new_data = data.<span class="hljs-built_in">substr</span>( overlap, new_data_size );<br>      output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>( new_data );<br>      unassembled_index += new_data_size;<br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( first_index == unassembled_index ) &#123;<br>    <span class="hljs-comment">// no overlap, 要进行cap比较</span><br>    <span class="hljs-type">uint64_t</span> cap = output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-keyword">if</span> ( data.<span class="hljs-built_in">size</span>() &gt; cap ) &#123;<br>      <span class="hljs-comment">// cap不够</span><br>      <span class="hljs-type">size_t</span> new_data_size = cap;<br>      string new_data = data.<span class="hljs-built_in">substr</span>( <span class="hljs-number">0</span>, new_data_size );<br>      output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>( new_data );<br>      unassembled_index += new_data_size;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// cap够</span><br>      output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>( data );<br>      unassembled_index += data.<span class="hljs-built_in">size</span>();<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 使用priority queue来存储碎片</span><br>    <span class="hljs-keyword">if</span> ( q.<span class="hljs-built_in">empty</span>() ) &#123;<br>      q.<span class="hljs-built_in">push</span>( <span class="hljs-built_in">make_pair</span>( first_index, data ) );<br>      unassembled_bytes_ += data.<span class="hljs-built_in">size</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        &#125;<br><br>    <span class="hljs-keyword">while</span> ( !q.<span class="hljs-built_in">empty</span>() ) &#123;<br>      <span class="hljs-type">uint64_t</span> new_index = q.<span class="hljs-built_in">top</span>().first;<br>      std::string new_data = q.<span class="hljs-built_in">top</span>().second;<br>      q.<span class="hljs-built_in">pop</span>();<br>      unassembled_bytes_ -= new_data.<span class="hljs-built_in">size</span>();<br>      <span class="hljs-keyword">if</span> ( q.<span class="hljs-built_in">empty</span>() ) &#123;<br>        q.<span class="hljs-built_in">push</span>( <span class="hljs-built_in">make_pair</span>( new_index, new_data ) );<br>        unassembled_bytes_ += new_data.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">uint64_t</span> new_index2 = q.<span class="hljs-built_in">top</span>().first;<br>        std::string new_data2 = q.<span class="hljs-built_in">top</span>().second;<br>        <span class="hljs-keyword">if</span> ( new_index &lt;= new_index2 ) &#123;<br>          <span class="hljs-type">size_t</span> overlap = new_index + new_data.<span class="hljs-built_in">size</span>() - new_index2;<br>          <span class="hljs-keyword">if</span> ( overlap &gt;= new_data.<span class="hljs-built_in">size</span>() ) &#123;<br>            q.<span class="hljs-built_in">pop</span>();<br>            unassembled_bytes_ -= new_data2.<span class="hljs-built_in">size</span>();<br>            q.<span class="hljs-built_in">push</span>( <span class="hljs-built_in">make_pair</span>( new_index, new_data ) );<br>            unassembled_bytes_ += new_data.<span class="hljs-built_in">size</span>();<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// overlap</span><br>            std::string substr = new_data.<span class="hljs-built_in">substr</span>( <span class="hljs-number">0</span>, new_index2 - new_index )<br>                                 + new_data2.<span class="hljs-built_in">substr</span>( overlap, new_data2.<span class="hljs-built_in">size</span>() - overlap );<br>            q.<span class="hljs-built_in">pop</span>();<br>            unassembled_bytes_ -= new_data2.<span class="hljs-built_in">size</span>();<br>            q.<span class="hljs-built_in">push</span>( <span class="hljs-built_in">make_pair</span>( first_index, substr ) );<br>            unassembled_bytes_ += substr.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 循环</span><br>  <span class="hljs-keyword">while</span> ( !q.<span class="hljs-built_in">empty</span>() ) &#123;<br>    <span class="hljs-type">uint64_t</span> new_index = q.<span class="hljs-built_in">top</span>().first;<br>    std::string new_data = q.<span class="hljs-built_in">top</span>().second;<br>    <span class="hljs-type">uint64_t</span> cap = output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-keyword">if</span> ( new_index &lt;= unassembled_index ) &#123;<br>      <span class="hljs-comment">// overlap</span><br>      <span class="hljs-keyword">if</span> ( new_index + new_data.<span class="hljs-built_in">size</span>() &gt; unassembled_index ) &#123;<br>        <span class="hljs-comment">// overlap</span><br>        <span class="hljs-type">size_t</span> overlap = unassembled_index - new_index;<br>        <span class="hljs-type">size_t</span> new_data_size = <span class="hljs-built_in">min</span>( new_data.<span class="hljs-built_in">size</span>() - overlap, cap );<br>        string new_data_2 = new_data.<span class="hljs-built_in">substr</span>( overlap, new_data_size );<br>        output.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>( new_data_2 );<br>        unassembled_index += new_data_size;<br>        unassembled_bytes_ -= data.<span class="hljs-built_in">size</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// no overlap</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        unassembled_bytes_ -= new_data.<span class="hljs-built_in">size</span>();<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( new_index &gt; unassembled_index ) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">is_closed</span>() ) &#123; <span class="hljs-comment">// important!</span><br>    output.<span class="hljs-built_in">close</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reassembler::bytes_pending</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// Your code here.</span><br>  <span class="hljs-keyword">return</span> unassembled_bytes_;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>改用map后第14个测试点超时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;reassembler.hh&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reassembler::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> closed_ &amp;&amp; <span class="hljs-built_in">bytes_pending</span>() == <span class="hljs-number">0</span>; &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reassembler::insert</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> first_index, string data, <span class="hljs-type">bool</span> is_last_substring, Writer &amp;output)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (is_last_substring) &#123;<br>        closed_ = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Remember index_ points to where the current byte located at.</span><br>    <span class="hljs-comment">// 1. Unacceptable index: first_index overwhelms the capability range.</span><br>    <span class="hljs-comment">// 2. All overlapped: The end index of the substring is smaller than current index_.</span><br>    <span class="hljs-comment">// 3. data is empty.</span><br>    <span class="hljs-comment">// 4. No available space.</span><br>    <span class="hljs-keyword">if</span> (first_index &gt;= unassembled_index_ + output.<span class="hljs-built_in">available_capacity</span>() || <span class="hljs-comment">/* Out of bound */</span><br>        first_index + data.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span> &lt; unassembled_index_ ||            <span class="hljs-comment">/* Data have been transferred */</span><br>        data.<span class="hljs-built_in">empty</span>() || output.<span class="hljs-built_in">available_capacity</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_closed</span>()) &#123;<br>            output.<span class="hljs-built_in">close</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> cap = output.<span class="hljs-built_in">available_capacity</span>();<br>    <span class="hljs-comment">// new_index actually distinguish where the current data start, the start index</span><br>    <span class="hljs-type">uint64_t</span> new_index = first_index;<br><br>    <span class="hljs-comment">// Data needs to fit the capability limitation</span><br>    <span class="hljs-keyword">if</span> (first_index &lt;= unassembled_index_) &#123;<br>        new_index = unassembled_index_;<br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> overlapped_length = unassembled_index_ - first_index;<br>        data = data.<span class="hljs-built_in">substr</span>(overlapped_length, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>() - overlapped_length, cap));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">min</span>(data.<span class="hljs-built_in">size</span>(), cap));<br>        <span class="hljs-keyword">if</span> (first_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt; unassembled_index_ + cap - <span class="hljs-number">1</span>) &#123;<br>            data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, unassembled_index_ + cap - first_index);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Get the rear substring and merge the overlapped part</span><br>    <span class="hljs-keyword">auto</span> rear_iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(new_index);<br>    <span class="hljs-keyword">while</span> (rear_iter != unassembled_substrings_.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[rear_index, rear_data] = *rear_iter;<br>        <span class="hljs-keyword">if</span> (new_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; rear_index) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-comment">// No overlap conflict</span><br>        <span class="hljs-type">uint64_t</span> rear_overlapped_length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (new_index + data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; rear_index + rear_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            rear_overlapped_length = new_index + data.<span class="hljs-built_in">size</span>() - rear_index;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            rear_overlapped_length = rear_data.<span class="hljs-built_in">size</span>();<br>        &#125;<br>        <span class="hljs-comment">// Prepare for next rear early, because the data may be erased afterwards.</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> next_rear = rear_index + rear_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (rear_overlapped_length == rear_data.<span class="hljs-built_in">size</span>()) &#123;<br>            unassembled_bytes_ -= rear_data.<span class="hljs-built_in">size</span>();<br>            unassembled_substrings_.<span class="hljs-built_in">erase</span>(rear_index);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// We don&#x27;t combine current data and rear data.</span><br>            <span class="hljs-comment">// Erase the overlapped part in current data is more efficient.</span><br>            data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">end</span>() - <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(rear_overlapped_length), data.<span class="hljs-built_in">end</span>());<br>        &#125;<br>        rear_iter = unassembled_substrings_.<span class="hljs-built_in">lower_bound</span>(next_rear);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (first_index &gt; unassembled_index_) &#123;<br>        <span class="hljs-keyword">auto</span> front_iter = unassembled_substrings_.<span class="hljs-built_in">upper_bound</span>(new_index);<br>        <span class="hljs-keyword">if</span> (front_iter != unassembled_substrings_.<span class="hljs-built_in">begin</span>()) &#123;<br>            front_iter--;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[front_index, front_data] = *front_iter;<br>            <span class="hljs-keyword">if</span> (front_index + front_data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &gt;= first_index) &#123;<br>                <span class="hljs-type">uint64_t</span> overlapped_length = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (front_index + front_data.<span class="hljs-built_in">size</span>() &lt;= first_index + data.<span class="hljs-built_in">size</span>()) &#123;<br>                    overlapped_length = front_index + front_data.<span class="hljs-built_in">size</span>() - first_index;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    overlapped_length = data.<span class="hljs-built_in">size</span>();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (overlapped_length == front_data.<span class="hljs-built_in">size</span>()) &#123;<br>                    unassembled_bytes_ -= front_data.<span class="hljs-built_in">size</span>();<br>                    unassembled_substrings_.<span class="hljs-built_in">erase</span>(front_index);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    data.<span class="hljs-built_in">erase</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">begin</span>() + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(overlapped_length));<br>                    <span class="hljs-comment">// Don&#x27;t forget to update the inserted location</span><br>                    new_index = first_index + overlapped_length;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If the processed data is empty, no need to insert it.</span><br>    <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        unassembled_bytes_ += data.<span class="hljs-built_in">size</span>();<br>        unassembled_substrings_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(new_index, std::<span class="hljs-built_in">move</span>(data)));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = unassembled_substrings_.<span class="hljs-built_in">begin</span>(); iter != unassembled_substrings_.<span class="hljs-built_in">end</span>(); <span class="hljs-comment">/* nop */</span>) &#123;<br>        <span class="hljs-keyword">auto</span> &amp;[sub_index, sub_data] = *iter;<br>        <span class="hljs-keyword">if</span> (sub_index == unassembled_index_) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> prev_bytes_pushed = output.<span class="hljs-built_in">bytes_pushed</span>();<br>            output.<span class="hljs-built_in">push</span>(sub_data);<br>            <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> bytes_pushed = output.<span class="hljs-built_in">bytes_pushed</span>();<br>            <span class="hljs-keyword">if</span> (bytes_pushed != prev_bytes_pushed + sub_data.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-comment">// Cannot push all data, we need to reserve the un-pushed part.</span><br>                <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> pushed_length = bytes_pushed - prev_bytes_pushed;<br>                unassembled_index_ += pushed_length;<br>                unassembled_bytes_ -= pushed_length;<br>                unassembled_substrings_.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(unassembled_index_, sub_data.<span class="hljs-built_in">substr</span>(pushed_length)));<br>                <span class="hljs-comment">// Don&#x27;t forget to remove the previous incompletely transferred data</span><br>                unassembled_substrings_.<span class="hljs-built_in">erase</span>(sub_index);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            unassembled_index_ += sub_data.<span class="hljs-built_in">size</span>();<br>            unassembled_bytes_ -= sub_data.<span class="hljs-built_in">size</span>();<br>            unassembled_substrings_.<span class="hljs-built_in">erase</span>(sub_index);<br>            iter = unassembled_substrings_.<span class="hljs-built_in">find</span>(unassembled_index_);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// No need to do more. Data has been discontinuous.</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_closed</span>()) &#123;<br>        output.<span class="hljs-built_in">close</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reassembler::bytes_pending</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> unassembled_bytes_; &#125;<br></code></pre></td></tr></table></figure><p>最后还是直接参考了大佬的代码，因为花在lab1上的时间太久了</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230819181925740.png"></p><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230819181854325.png"></p><h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230827203700808.png"></p><h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><p>实现ARP，这节实验开始难度骤降</p><p>参考博客：<a href="https://www.cnblogs.com/chenshengkai/p/13936532.html">ARP报文结构</a>      <a href="https://akaedu.github.io/book/ch36s03.html">ARP</a></p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230830223804712.png"></p><h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><p>这节要求实现基于最长前缀匹配规则的路由器转发功能，基本没有难度 </p><p>没有复杂度要求，就直接用vector了，方便一点</p><p><img src="https://raw.githubusercontent.com/MadFrey/homework.img/master/image-20230901111001853.png"></p>]]></content>
    
    
    <categories>
      
      <category>lab</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cs144</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重新建站后的第一篇博客</title>
    <link href="/2023/07/29/%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%99%E5%90%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/07/29/%E9%87%8D%E6%96%B0%E5%BB%BA%E7%AB%99%E5%90%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>​这已经是第二次搭建博客了，距离上一次搭建自己的博客已经有一年多了。之前在大一的时候用的typecho在自己服务器上搭的，主要也是记录的一些算法相关的东西。由于各种因素影响，最后还是放弃了之前的博客，选择重新搭建。</p><p>​这次搭博客，主要还是想要记录一下个人觉得比较有意思的事，发表发表观点，其次是技术方面会写一些有技术深度和广度的博客，做CSDN,掘金搬运工就太没意思了。（这也是放弃之前的博客的原因之一吧）然后写写大学阶段的年度总结吧。总之，写博客是我对于自己所学内容的一种内容输出，也是这次想要重新搭建博客的主要原因。</p><p>​只能说写博客确实挺费时间的，想要坚持一直下去确实有一定难度，但时间挤一挤还是会有的。嗯，大概就这些吧。</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
